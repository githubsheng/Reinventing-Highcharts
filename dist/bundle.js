/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/Weaver.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Axis/Axis.js":
/*!**************************!*\
  !*** ./src/Axis/Axis.js ***!
  \**************************/
/*! exports provided: Axis, X_Axis, Y_Axis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Axis\", function() { return Axis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"X_Axis\", function() { return X_Axis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Y_Axis\", function() { return Y_Axis; });\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Draw/Draw */ \"./src/Draw/Draw.js\");\n/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Util/Util */ \"./src/Util/Util.js\");\n/**\n * Axis serves as the parent of X_Axis and Y_Axis and its prototype holds common functions shared by X_Axis and Y_Axis.\n *\n * The methods defined in these parent class uses the following properties from a child:\n * min, max, length, preferredMarkPixelInterval, markDataInterval, markPixelInterval, originPosition, leftPadding, rightPadding,\n * labelPositions, markPositions and svg\n *\n * !important. note that i can just define the above arguments here in this constructor and have the child classes call the\n * parent constructor. but this parent constructor really just does nothing. So I will just directly assign the above\n * arguments to instance property in child constructors.\n *\n * @constructor\n */\n\n\n\nfunction Axis(){\n    this.preferredMarkDataIntervals = [1, 2, 2.5, 5, 10];\n}\n\n/**\n * draw the whole axis, this method should only be called AFTER the axis is analyzed (after we figured out where to draw what)\n */\nAxis.prototype.draw = function(){\n    this.drawMarks();\n    this.drawLabels();\n};\n\n/**\n * assume the axis is linear and calculate the interval based on min, max, preferred pixel and length values. This method\n * does not adjust min max value.\n *\n * this method is the key why we are able to get pretty intervals.\n */\nAxis.prototype.adjustMarkInterval = function(){\n    let dataPerPixel = (this.max - this.min) / this.length;\n    let dataInterval = dataPerPixel * this.preferredMarkPixelInterval;\n    let perfectDataInterval = dataInterval;\n\n    let magnitude = Math.pow(10, Math.floor(Math.log(dataInterval) / Math.log(10)));\n    dataInterval = dataInterval / magnitude;\n    for(let i = 0; i < this.preferredMarkDataIntervals.length; i++){\n        if(dataInterval < (this.preferredMarkDataIntervals[i] + _Util_Util__WEBPACK_IMPORTED_MODULE_1__[\"util\"].pickFirstAvailable(this.preferredMarkDataIntervals[i+1], this.preferredMarkDataIntervals[i])) / 2){\n            dataInterval =  this.preferredMarkDataIntervals[i];\n            break;\n        }\n    }\n\n    dataInterval = dataInterval * magnitude;\n    this.markDataInterval = dataInterval;\n    this.markPixelInterval = (dataInterval / perfectDataInterval) * this.preferredMarkPixelInterval;\n};\n\n/**\n * Construct an X axis. The default implementation is for linear axis, that is, X_LinearAxis. I chose this implementation because\n * most other types of axises are similar to linear axis.\n */\nfunction X_Axis(){}\n\nX_Axis.prototype = new Axis();\nX_Axis.prototype.constructor = X_Axis;\n\n/**\n * get all statuses and numbers correct.\n * @returns {{startPoint: number, pixelPerData: number, length: number, min: number}}\n */\nX_Axis.prototype.analyze = function(){\n    this.adjustMarkInterval();\n    this.calculateMarkPositions();\n    this.calculateLabelPositions();\n\n    return this.analyzeReturn();\n};\n\n/**\n * calculate and get the information we need so that we can correctly draw the axis later\n * @returns {{startPoint: number, pixelPerData: number, length: number, min: number}}\n */\nX_Axis.prototype.analyzeReturn = function(){\n    let startPoint = this.originPosition[0] + this.leftPadding;\n    let pixelPerData = this.markPixelInterval / this.markDataInterval;\n    let min = this.min;\n\n    return {\n        startPoint: startPoint,\n        pixelPerData: pixelPerData,\n        length: this.length,\n        min: min\n    };\n};\n\n\n/**\n * draw the marks of the axis based on the calculated mark position\n */\nX_Axis.prototype.drawMarks = function(){\n    let dValue = \"\";\n    for(let i = 0; i < this.markPositions.length; i = i + 2) {\n        let x1 = this.markPositions[i];\n        let y1 = this.markPositions[i + 1];\n        let x2 = x1;\n        let y2 = y1 + 5;\n        dValue = dValue + \"M\" + x1 + \" \" + y1 + \" L\" + x2 + \" \" + y2 + \" \";\n    }\n    dValue = dValue.trim();\n    let marks = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createPath(dValue);\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setStrokeFill(marks, \"darkgray\", false, false);\n    this.svg.appendChild(marks);\n};\n\n/**\n * draw the labels of the axis based on the calculated label position\n */\nX_Axis.prototype.drawLabels = function(){\n    let labelGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createGroup();\n    let text = this.min;\n    for(let i = 0; i < this.labelPositions.length; i = i + 2){\n        text = _Util_Util__WEBPACK_IMPORTED_MODULE_1__[\"util\"].perfectNumber(this.min + this.markDataInterval * i / 2); //divide i by 2 because i = i + 2 in the loop\n        labelGroup.appendChild(_Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createText(this.labelPositions[i], this.labelPositions[i+1], text, 11, \"middle\", false));\n    }\n    this.svg.appendChild(labelGroup);\n};\n\n/**\n * calculate the mark positions. The first mark starts at origin + padding\n */\nX_Axis.prototype.calculateMarkPositions = function(){\n    let x = this.originPosition[0] + this.leftPadding;\n    let y = this.originPosition[1];\n    let currentDataPoint = this.min;\n    while(currentDataPoint < this.max || currentDataPoint === this.max) {\n        this.markPositions.push(x);\n        this.markPositions.push(y);\n        x = x + this.markPixelInterval;\n        currentDataPoint = _Util_Util__WEBPACK_IMPORTED_MODULE_1__[\"util\"].perfectNumber(currentDataPoint + this.markDataInterval);\n    }\n};\n\n/**\n * calculate the label positions. By default the label positions are a little bit below the mark position.\n */\nX_Axis.prototype.calculateLabelPositions = function(){\n    for(let i = 0; i < this.markPositions.length; i = i + 2){\n        this.labelPositions.push(this.markPositions[i]);\n        this.labelPositions.push(this.markPositions[i + 1] + 16);\n    }\n};\n\n/**\n * Construct an Y axis. The default implementation is for linear axis, that is, Y_LinearAxis. I chose this implementation because\n * most other types of axises are similar to linear axis.\n * @constructor\n */\nfunction Y_Axis(){}\n\n//extends the Axis class\nY_Axis.prototype = new Axis();\nY_Axis.prototype.constructor = Y_Axis;\n\n/**\n * get all statuses and numbers correct. we need this information to properly draw the axis\n * @returns {{startPoint: number, pixelPerData: number, min: number}}\n */\nY_Axis.prototype.analyze = function(){\n    this.adjustMarkInterval();\n    this.calculateMarkPositions();\n    this.calculateLabelPositions();\n\n    let startPoint = this.originPosition[1];\n    let pixelPerData = this.markPixelInterval / this.markDataInterval;\n    let min = this.min;\n\n    return {\n        startPoint: startPoint,\n        pixelPerData: pixelPerData,\n        min: min\n    };\n};\n\n/**\n * adjust both mark data interval and mark pixel interval. This method also adjusts the min value and the max value.\n * We need to adjust the min and max value because sometimes the min max values are quite ugly(say, 1.372), we want to\n * make them pretty, say (1.3) or (1.2). If we want to keep the original min max value (not making them pretty looking)\n * then we can configure the `this.doNotExpandMin` and `this.doNotExpandMax` settings.\n */\nY_Axis.prototype.adjustMarkInterval = function(){\n    Axis.prototype.adjustMarkInterval.apply(this);\n    let min2 = _Util_Util__WEBPACK_IMPORTED_MODULE_1__[\"util\"].perfectNumber(this.markDataInterval * Math.floor(this.min / this.markDataInterval));\n\n\n    if(this.min === min2 && !this.doNotExpandMin){\n        this.min = _Util_Util__WEBPACK_IMPORTED_MODULE_1__[\"util\"].perfectNumber(this.min - this.markDataInterval);\n    } else {\n        this.min = min2;\n    }\n\n    let max2 = _Util_Util__WEBPACK_IMPORTED_MODULE_1__[\"util\"].perfectNumber(this.markDataInterval * Math.ceil(this.max / this.markDataInterval));\n    if(this.max === max2 && !this.doNotExpandMax){\n        this.max = _Util_Util__WEBPACK_IMPORTED_MODULE_1__[\"util\"].perfectNumber(this.max + this.markDataInterval); //so that there is always some room unoccupied at the top.\n    } else {\n        this.max = max2;\n    }\n    let numOfIntervals = (this.max - this.min) / this.markDataInterval;\n    this.markPixelInterval = this.length / numOfIntervals;\n};\n\n\n/**\n * calculate the mark positions assuming its a linear axis.\n */\nY_Axis.prototype.calculateMarkPositions = function(){\n    let x = this.originPosition[0];\n    let y = this.originPosition[1];\n    let currentDataPoint = this.min;\n    while(currentDataPoint < this.max || currentDataPoint === this.max) {\n        this.markPositions.push(x);\n        this.markPositions.push(y);\n        y = y - this.markPixelInterval;\n        currentDataPoint = _Util_Util__WEBPACK_IMPORTED_MODULE_1__[\"util\"].perfectNumber(currentDataPoint + this.markDataInterval);\n    }\n};\n\n/**\n * calculate the label positions\n */\nY_Axis.prototype.calculateLabelPositions = function(){\n    for(let i = 0; i < this.markPositions.length; i = i + 2){\n        this.labelPositions.push(this.markPositions[i]);\n        //font size = 11 and therefore moving the font downwards by 5.5 (11/2) vertically centers the text.\n        this.labelPositions.push(this.markPositions[i + 1]);\n    }\n};\n\n/**\n * draw all the marks. The marks are very wide, almost as wide as the chart, and run through the data section.\n */\nY_Axis.prototype.drawMarks = function(){\n    let dValue = \"\";\n    let markWidth = this.x_axis.length\n        + _Util_Util__WEBPACK_IMPORTED_MODULE_1__[\"util\"].pickFirstAvailable(this.x_axis.leftPadding, 0)\n        + _Util_Util__WEBPACK_IMPORTED_MODULE_1__[\"util\"].pickFirstAvailable(this.x_axis.rightPadding, 0);\n    for(let i = 0; i < this.markPositions.length; i = i + 2) {\n        let x1 = this.markPositions[i];\n        let y1 = this.markPositions[i + 1];\n        let x2 = x1 + markWidth;\n        let y2 = y1;\n        dValue = dValue + \"M\" + x1 + \" \" + y1 + \" L\" + x2 + \" \" + y2 + \" \";\n    }\n    dValue = dValue.trim();\n    let marks = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createPath(dValue);\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setStrokeFill(marks, \"darkgray\", \"1\", \"none\");\n    this.svg.appendChild(marks);\n};\n\nY_Axis.prototype.drawLabels = function(){\n    let text = this.min;\n    for(let i = 0; i < this.labelPositions.length; i = i + 2){\n        text = _Util_Util__WEBPACK_IMPORTED_MODULE_1__[\"util\"].perfectNumber(this.min + this.markDataInterval * i / 2); //divide i by 2 because i = i + 2 in the loop\n        this.svg.appendChild(_Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createText(this.labelPositions[i] - 10, this.labelPositions[i+1], text, \"11\", \"end\", \"middle\"));\n    }\n};\n\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/Axis/Axis.js?");

/***/ }),

/***/ "./src/Axis/Sub/CategoryAxis.js":
/*!**************************************!*\
  !*** ./src/Axis/Sub/CategoryAxis.js ***!
  \**************************************/
/*! exports provided: X_CategoryAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"X_CategoryAxis\", function() { return X_CategoryAxis; });\n/* harmony import */ var _Axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Axis */ \"./src/Axis/Axis.js\");\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Draw/Draw */ \"./src/Draw/Draw.js\");\n/**\n * this class creates a x axis for category charts\n * @param svg               this is the svg element to which we will be appending new svg element\n * @param length            length of the axis. length does not include left padding or right padding.\n * @param categoriesNames   the names of the categories, we need to render them as labels along the axis\n * @param originPosition    the origin position of the cartesian coordinate system.\n * @param leftPadding       the left padding of the axis\n * @param rightPadding      the right padding of the axis\n * @constructor\n */\n\n\n\nfunction X_CategoryAxis(svg, length, originPosition, categoriesNames, leftPadding, rightPadding){\n    this.svg = svg;\n    this.originPosition = originPosition;\n    this.length = length;\n    this.markPixelInterval = 0;\n    this.markPositions = [];\n    this.labelPositions = [];\n    this.originPosition = originPosition;\n    this.categoriesNames = categoriesNames;\n    //category axis has fixed left and right padding.\n    this.leftPadding = leftPadding;\n    this.rightPadding = rightPadding;\n\n}\n\n//this class extends X_Axis\nX_CategoryAxis.prototype = new _Axis__WEBPACK_IMPORTED_MODULE_0__[\"X_Axis\"]();\nX_CategoryAxis.constructor = X_CategoryAxis;\n\n/**\n * adjust the mark pixel interval based on number of categories and length of the axis.\n */\nX_CategoryAxis.prototype.adjustMarkInterval = function(){\n    this.markPixelInterval = this.length / this.categoriesNames.length;\n};\n\n/**\n * calculate the mark pixel positions\n */\nX_CategoryAxis.prototype.calculateMarkPositions = function(){\n    let firstMarkPositionX = this.originPosition[0] + this.leftPadding;\n    let markPositionY = this.originPosition[1];\n    this.markPositions.push(firstMarkPositionX);\n    this.markPositions.push(markPositionY);\n\n    for(let i = 0; i < this.categoriesNames.length; i++){\n        this.markPositions.push(firstMarkPositionX + this.markPixelInterval * (i + 1));\n        this.markPositions.push(markPositionY);\n    }\n};\n\n/**\n * calculate the positions of the labels\n */\nX_CategoryAxis.prototype.calculateLabelPositions = function(){\n    let halfMarkInterval = this.markPixelInterval / 2;\n    let l = this.markPositions.length - 2; //最后一个mark不需要\n    for(let i = 0; i < l; i = i + 2){\n        this.labelPositions.push(this.markPositions[i] + halfMarkInterval);\n        this.labelPositions.push(this.markPositions[i+1] + 5);\n    }\n};\n\n/**\n * draw the labels below the axis\n */\nX_CategoryAxis.prototype.drawLabels = function(){\n    for(let i = 0; i < this.labelPositions.length; i = i + 2){\n        let categoryName = this.categoriesNames[i/2];\n        let label = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createText(this.labelPositions[i], this.labelPositions[i+1], categoryName, false, \"middle\", \"top\");\n        this.svg.appendChild(label);\n    }\n};\n\n\n/**\n * based on the mark pixel intervals and label positions, analyze the positions of category column positions\n * and the column width\n * @returns {{categoryBasePositions: Array, columnWidth: number}} a tuple of: category column positions and column width\n */\nX_CategoryAxis.prototype.analyzeReturn = function() {\n    let categoryBasePositions = [];\n    for(let i = 0; i < this.labelPositions.length; i = i + 2){\n        categoryBasePositions.push(this.labelPositions[i]);\n        //because when calculating the label positions i shift them 5 px down from the origin Y\n        categoryBasePositions.push(this.labelPositions[i + 1] - 5);\n    }\n\n    //adjust the column width.based on the mark interval\n    let columnWidth;\n    if(this.markPixelInterval < 8){\n        columnWidth = 4;\n    } else if (this.markPixelInterval > 40){\n        columnWidth = 40;\n    } else {\n        columnWidth = this.markPixelInterval / 2;\n    }\n\n    return {\n        categoryBasePositions: categoryBasePositions,\n        columnWidth: columnWidth\n    };\n};\n\n\n\n//# sourceURL=webpack:///./src/Axis/Sub/CategoryAxis.js?");

/***/ }),

/***/ "./src/Axis/Sub/LinearAxis.js":
/*!************************************!*\
  !*** ./src/Axis/Sub/LinearAxis.js ***!
  \************************************/
/*! exports provided: X_LinearAxis, Y_LinearAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"X_LinearAxis\", function() { return X_LinearAxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Y_LinearAxis\", function() { return Y_LinearAxis; });\n/* harmony import */ var _Axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Axis */ \"./src/Axis/Axis.js\");\n/**\n * construct a linear x axis.\n * @param svg               svg element\n * @param length            the length here does not include padding. That is, this is the part that is associated with data.\n * @param min               original min value on the axis\n * @param max               original max value on the axis\n * @param originPosition    the position of the origin (of the cartesian system)\n * @param leftPadding       left padding of the x axis\n * @param rightPadding      right padding of the x axis\n * @constructor\n */\n\n\nfunction X_LinearAxis(svg, length, min, max, originPosition, leftPadding, rightPadding){\n    this.leftPadding = leftPadding;\n    this.rightPadding = rightPadding;\n    this.svg = svg;\n    this.originPosition = originPosition;\n    this.length = length - leftPadding - rightPadding;\n    this.min = min;\n    this.max = max;\n    this.preferredMarkPixelInterval = 100;\n    this.markDataInterval = 0;\n    this.markPixelInterval = 0;\n    this.markPositions = [];\n    this.labelPositions = [];\n    this.originPosition = originPosition;\n}\n\n//extends x axis\nX_LinearAxis.prototype = new _Axis__WEBPACK_IMPORTED_MODULE_0__[\"X_Axis\"]();\nX_LinearAxis.prototype.constructor = X_LinearAxis;\n\n/**\n * creates a linear y axis. It pretty much inherit all methods from Y_Axis.\n *\n * @param svg               svg element\n * @param length            the length here does not include padding. That is, this is the part that is associated with data.\n * @param min               original min value on the axis\n * @param max               original max value on the axis\n * @param originPosition    the position of the origin (of the cartesian system)\n * @param x_axis            the related x axis. this is needed as we sometimes need to draw marks across the chart (parallel to x axis)\n * @param doNotExpandMin    if true, it will not make the min value to look pretty\n * @param doNotExpandMax    if true, it will not make the max value to look pretty.\n * @constructor\n */\nfunction Y_LinearAxis(svg, length, min, max, originPosition, x_axis, doNotExpandMin, doNotExpandMax){\n    this.svg = svg;\n    this.originPosition = originPosition;\n    this.length = length;\n    this.min = min;\n    this.max = max;\n    this.preferredMarkPixelInterval = 75;\n    this.markDataInterval = 0;\n    this.markPixelInterval = 0;\n    this.originPosition = originPosition;\n    this.x_axis = x_axis;\n    this.doNotExpandMin = doNotExpandMin;\n    this.doNotExpandMax = doNotExpandMax;\n\n    this.markPositions = [];\n    this.labelPositions = [];\n}\n\nY_LinearAxis.prototype = new _Axis__WEBPACK_IMPORTED_MODULE_0__[\"Y_Axis\"]();\nY_LinearAxis.prototype.constructor = Y_LinearAxis;\n\n/**\n * draw the y linear axis\n */\nY_LinearAxis.prototype.draw = function(){\n    this.drawMarks();\n    this.drawLabels();\n};\n\n//# sourceURL=webpack:///./src/Axis/Sub/LinearAxis.js?");

/***/ }),

/***/ "./src/Axis/Sub/TimeAxis.js":
/*!**********************************!*\
  !*** ./src/Axis/Sub/TimeAxis.js ***!
  \**********************************/
/*! exports provided: TimeAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimeAxis\", function() { return TimeAxis; });\n/* harmony import */ var _Axis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Axis */ \"./src/Axis/Axis.js\");\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Draw/Draw */ \"./src/Draw/Draw.js\");\n/**\n * Units: MS(milliseconds), S(second), M(minute), H(hour), D(day), MON(month), Y(year)\n *\n * preferred data interval for MS is TODO\n *\n * preferred data interval for S is 1, 2, 5, 10, 15, 30, 60, 120.\n *\n * preferred data interval for M is 1, 2, 5, 10, 15, 30, 60, 120.\n *\n * preferred data interval for H is 1, 2, 3, 6, 12, 24(1D), 48(2D), 72(3D), 96(4D), 168(7D).\n *\n * preferred data interval for D is 1, 2, 4, 7(1W), 14(1W), 28-31(1M, requires calculation of the days of that particular month..),\n * 2MON(roughly 60D), 3MON(one season, roughly 100D)\n *\n * preferred data interval for MON is 1, 2, 3(1 season), 6(half year), 12(1Y), 24(2Y), 48(4Y), 120(10Y, 1 decade).\n *\n * preferred data interval for Y is 1, 2, 3, 5, 10 或者是这些数乘以10的整数倍。\n *\n * Values bigger than the greatest data interval is not allowed. This is because with the preferred pixel interval being 100 pixels.\n * A greater data interval (than the greatest preferred) will leads to the case in which a single pixel maps to more than 1 data.\n * In this case an error should be thrown and user should told to split the data into a smaller set.\n *\n *\n * @param svg               the svg element to which we are going to append the axis\n * @param length            the length of the axis\n * @param max               this is like the end. Say you have 431 points and the unit is M(minute), then the end is 431 minutes.\n * @param originPosition    origin position\n * @param unit              should be MS, S, M, H, D, MON or Y\n * @param interval          the time interval, if interval is 5 and unit is M, then it means there is 5 minutes between each data point.\n * @constructor\n */\n\n\n\nfunction TimeAxis(svg, length, max, originPosition, unit, interval){\n    this.svg = svg;\n    this.originPosition = originPosition;\n    this.length = length;\n    this.min = 0; //this is the start\n    this.max = max;\n    this.preferredMarkPixelInterval = 100;\n    this.markDataInterval = 0;\n    this.markPixelInterval = 0;\n    this.markPositions = [];\n    this.labelPositions = [];\n    this.originPosition = originPosition;\n    this.leftPadding = 0;//left padding is 0\n    this.rightPadding = 0; //right padding is also 0 in this case\n    this.unit = unit;\n    this.interval = interval;\n}\n\nTimeAxis.prototype = new _Axis__WEBPACK_IMPORTED_MODULE_0__[\"X_Axis\"]();\nTimeAxis.prototype.constructor = TimeAxis;\n\n/**\n * see the same method defined in Axis.js\n */\nTimeAxis.prototype.adjustMarkInterval = function(){\n    let dataPerPixel = (this.max - this.min) / this.length;\n    let dataInterval = dataPerPixel * this.preferredMarkPixelInterval;\n    let perfectDataInterval = dataInterval;\n\n    //right now let me just simply write the code for S, M, and H\n    switch(this.unit){\n        case \"s\":\n        case \"m\":\n            this.preferredMarkDataIntervals = [1, 2, 5, 10, 15, 30, 60, 120];\n            break;\n        case \"h\":\n            this.preferredMarkDataIntervals = [1, 2, 3, 6, 12, 24, 48, 72, 96, 168];\n            break;\n    }\n\n    let largest = this.preferredMarkDataIntervals[this.preferredMarkDataIntervals.length - 1];\n    if(dataInterval > largest){\n        dataInterval = largest;\n    } else {\n        for(let i = 0; i < this.preferredMarkDataIntervals.length; i++){\n            if(dataInterval < (this.preferredMarkDataIntervals[i] + util.pickFirstAvailable(this.preferredMarkDataIntervals[i+1], this.preferredMarkDataIntervals[i])) / 2){\n                dataInterval =  this.preferredMarkDataIntervals[i];\n                break;\n            }\n        }\n    }\n    this.markDataInterval = dataInterval;\n    this.markPixelInterval = (dataInterval / perfectDataInterval) * this.preferredMarkPixelInterval;\n};\n\n/**\n * see the same method defined in Axis.js X_Axis.\n */\nTimeAxis.prototype.drawLabels = function(){\n    let labelGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createGroup();\n    let start = this.min;\n    for(let i = 0; i < this.labelPositions.length; i = i + 2){\n        let label = start + this.markDataInterval * i / 2; //divide i by 2 because i = i + 2 in the loop\n        label = this.appendUnit(label);\n        labelGroup.appendChild(_Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createText(this.labelPositions[i], this.labelPositions[i+1], label, 11, \"middle\", false));\n    }\n    this.svg.appendChild(labelGroup);\n};\n\n/**\n * depending on the unit and the data interval, this function may switch to a greater unit. For example, if the data interval is\n * 15 and the unit is m, then this function simply append letter \"m\" to 15 and make the label \"15m\". However, if the data interval\n * is 60 and the unit is m, the this function transforms \"60m\" to \"1h\" and \"120m\" to \"2h\".\n */\nTimeAxis.prototype.appendUnit = function(label){\n    //TODO: right now i have only implement the case in which the unit is \"minute\" or \"second\".\n    switch(this.unit){\n        case \"s\":\n            if(this.markDataInterval === 60 || this.markDataInterval === 120){\n                return label / 60 + \"m\";\n            } else {\n                return label + \"s\";\n            }\n        case \"m\":\n            if(this.markDataInterval === 60 || this.markDataInterval === 120){\n                return label / 60 + \"h\";\n            } else {\n                return label + \"m\";\n            }\n    }\n};\n\n/**\n * see the the same method in X_Axis  (Axis.js)\n * @returns {{startPoint: number, pixelPerData: number, min: number}}\n */\nTimeAxis.prototype.analyzeReturn = function(){\n    let startPoint = this.originPosition[0] + this.leftPadding;\n    let pixelPerData = this.markPixelInterval / this.markDataInterval;\n    let min = this.min;\n\n    /*this is xDrawInfo*/\n    return {\n        startPoint: startPoint,\n        length: this.length, //excluding left and right padding.\n        pixelPerData: pixelPerData,\n        min: min\n    }\n};\n\n//# sourceURL=webpack:///./src/Axis/Sub/TimeAxis.js?");

/***/ }),

/***/ "./src/DataAnalyst/BasicLine/BasicLineIrregularDataAnalyst.js":
/*!********************************************************************!*\
  !*** ./src/DataAnalyst/BasicLine/BasicLineIrregularDataAnalyst.js ***!
  \********************************************************************/
/*! exports provided: BasicLineIrregularDataAnalyst */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicLineIrregularDataAnalyst\", function() { return BasicLineIrregularDataAnalyst; });\n/* harmony import */ var _DataAnalystCommons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DataAnalystCommons */ \"./src/DataAnalyst/DataAnalystCommons.js\");\n\n\n/**\n * this implementation analyzes the data for a basic line chart that has both linear data y axis and linear data x axis.\n * @param input                 the input that carries data belonging to different series.\n * @param xAxisDataAreaLength   the area where we are going to display the data (using node), if the area is too small,\n *                              we will display a continual line, otherwise we will display a node for each of the data point\n * @constructor\n */\nfunction BasicLineIrregularDataAnalyst(input, xAxisDataAreaLength){\n    this.input = input;\n    this.xAxisDataAreaLength = xAxisDataAreaLength;\n}\n\n/**\n * find the min max in all series' data, also find if we need to draw a continual line to represent the data,\n * or do we need to draw each node for each data point, depending on how much space we have.\n * @returns {{minX: number, maxX: number, minY: number, maxY: number, isContinual: (boolean)}}\n */\nBasicLineIrregularDataAnalyst.prototype.analyze = function(){\n    let series = this.input.series;\n    //find the smallest & biggest value on x axis, and find the smallest & biggest value on y axis.\n    let minX = series[0][1][1][0]; //first piece of data's x\n    let maxX = series[0][1][1][0];\n    let minY = series[0][1][1][1];\n    let maxY = series[0][1][1][1];\n    let maxNodeCount = 0;\n\n    //loop through different series\n    for(let i = 0; i < series.length; i++){\n        let singleSeriesData = series[i][1];\n        for(let ii = 0; ii < singleSeriesData.length; ii++){\n            let point = singleSeriesData[ii];\n            if(point[0] < minX){\n                minX = point[0];\n            }\n            if(point[0] > maxX){\n                maxX = point[0];\n            }\n            if(point[1] < minY){\n                minY = point[1];\n            }\n            if(point[1] > maxY){\n                maxY = point[1];\n            }\n        }\n\n        if(singleSeriesData.length > maxNodeCount){\n            maxNodeCount = singleSeriesData.length;\n        }\n    }\n\n    let isContinual = _DataAnalystCommons__WEBPACK_IMPORTED_MODULE_0__[\"dataAnalystCommons\"].isContinual(this.xAxisDataAreaLength, maxNodeCount);\n\n    return {\n        minX: minX,\n        maxX: maxX,\n        minY: minY,\n        maxY: maxY,\n        isContinual: isContinual\n    };\n};\n\n\n//# sourceURL=webpack:///./src/DataAnalyst/BasicLine/BasicLineIrregularDataAnalyst.js?");

/***/ }),

/***/ "./src/DataAnalyst/BasicLine/BasicLineRegularDataAnalyst.js":
/*!******************************************************************!*\
  !*** ./src/DataAnalyst/BasicLine/BasicLineRegularDataAnalyst.js ***!
  \******************************************************************/
/*! exports provided: BasicLineRegularDataAnalyst */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicLineRegularDataAnalyst\", function() { return BasicLineRegularDataAnalyst; });\n/* harmony import */ var _DataAnalystCommons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DataAnalystCommons */ \"./src/DataAnalyst/DataAnalystCommons.js\");\n/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Util/Util */ \"./src/Util/Util.js\");\n\n\n\n/**\n * this implementation analyzes the data for a basic line chart that has both linear data y axis and linear data x axis.\n * @param input                 the input that carries data belonging to different series.\n * @param xAxisDataAreaLength   the area where we are going to display the data (using node), if the area is too small,\n *                              we will display a continual line, otherwise we will display a node for each of the data point\n * @constructor\n */\nfunction BasicLineRegularDataAnalyst(input, xAxisDataAreaLength){\n    this.input = input;\n    this.xAxisDataAreaLength = xAxisDataAreaLength;\n}\n\n/**\n * find the min max in all series' data, also find if we need to draw a continual line to represent the data,\n * or do we need to draw each node for each data point, depending on how much space we have.\n * @returns {{minX: number, maxX: number, minY: number, maxY: number, isContinual: (boolean)}}\n */\nBasicLineRegularDataAnalyst.prototype.analyze = function(){\n    let maxX = null;\n    let minY = null;\n    let maxY = null;\n    let isContinual = false;\n    for(let i = 0; i < this.input.series.length; i++){\n        let singleSeriesResult = this.analyzeSingleSeries(this.input.series[i][1]);\n\n        if(maxX === null){\n            maxX = singleSeriesResult.maxX;\n        }\n\n        if(minY === null){\n            minY = singleSeriesResult.minY;\n        } else if (minY > singleSeriesResult.minY){\n            minY = singleSeriesResult.minY;\n        }\n\n        if(maxY === null){\n            maxY = singleSeriesResult.maxY;\n        } else if (maxY < singleSeriesResult.maxY){\n            maxY = singleSeriesResult.maxY;\n        }\n\n        if(singleSeriesResult.isContinual){\n            isContinual = true;//true if any series is continual, because all series are of same length.\n        }\n\n    }\n\n    return  {\n        minX: this.input.start,\n        maxX: maxX,\n        minY: minY,\n        maxY: maxY,\n        isContinual: isContinual\n    };\n};\n\n/**\n * find the min max in a single serie's data, also find if we need to draw a continual line to represent the data,\n * or do we need to draw each node for each data point, depending on how much space we have.\n * @returns {{maxX: number, minY: number, maxY: number, isContinual: (boolean)}}\n */\nBasicLineRegularDataAnalyst.prototype.analyzeSingleSeries = function(singleSeriesData){\n    let minY = singleSeriesData[0];\n    let maxY = singleSeriesData[0];\n    let maxX = _Util_Util__WEBPACK_IMPORTED_MODULE_1__[\"util\"].chooseBetween(this.input.start === undefined, 0, this.input.start) + (singleSeriesData.length - 1) * this.input.interval; //length - 1是因为从第二个元素起才开始加interval\n    let maxNodeCount = singleSeriesData.length;\n\n    for(let i = 0; i < singleSeriesData.length; i++){\n        if(singleSeriesData[i] > maxY){\n            maxY = singleSeriesData[i];\n        }\n\n        if(singleSeriesData[i] < minY){\n            minY = singleSeriesData[i];\n        }\n    }\n\n    let isContinual = _DataAnalystCommons__WEBPACK_IMPORTED_MODULE_0__[\"dataAnalystCommons\"].isContinual(this.xAxisDataAreaLength, maxNodeCount);\n\n    return  {\n        maxX: maxX,\n        minY: minY,\n        maxY: maxY,\n        isContinual: isContinual\n    };\n};\n\n//# sourceURL=webpack:///./src/DataAnalyst/BasicLine/BasicLineRegularDataAnalyst.js?");

/***/ }),

/***/ "./src/DataAnalyst/Category/BasicCategoryDataAnalyst.js":
/*!**************************************************************!*\
  !*** ./src/DataAnalyst/Category/BasicCategoryDataAnalyst.js ***!
  \**************************************************************/
/*! exports provided: BasicCategoryDataAnalyst */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicCategoryDataAnalyst\", function() { return BasicCategoryDataAnalyst; });\n/**\n * this class is used to find out the min max value in the data, for a category chart.\n * @param input     input data of a basic category chart\n * @constructor\n */\nfunction BasicCategoryDataAnalyst(input){\n    this.input = input;\n    this.results = null;\n}\n\n/**\n * find out the min max value in the data. the analysis result is stored in this analyst instance as `this.result`.\n * @returns {{minY: number, maxY: number, seriesNames: Array }}\n */\nBasicCategoryDataAnalyst.prototype.analyze = function(){\n    if(this.results !== null){\n        return this.results;\n    }\n\n    let minY = 0;\n    let maxY = 0;\n\n    //loop through different series\n    let series = this.input.series;\n    let seriesNames = [];\n    for(let i = 0; i < series.length; i++){\n        seriesNames.push(series[i][0]);\n        let seriesData = series[i][1];\n\n        if(seriesData < minY){\n            minY = seriesData;\n        }\n\n        if(seriesData > maxY){\n            maxY = seriesData;\n        }\n    }\n\n    this.results = {\n        minY: minY,\n        maxY: maxY,\n        seriesNames: seriesNames\n    };\n\n    return this.results;\n};\n\n//# sourceURL=webpack:///./src/DataAnalyst/Category/BasicCategoryDataAnalyst.js?");

/***/ }),

/***/ "./src/DataAnalyst/DataAnalystCommons.js":
/*!***********************************************!*\
  !*** ./src/DataAnalyst/DataAnalystCommons.js ***!
  \***********************************************/
/*! exports provided: dataAnalystCommons */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"dataAnalystCommons\", function() { return dataAnalystCommons; });\n/**\n * a utility class for other data analyst\n */\nconst dataAnalystCommons = {\n\n    /**\n     * check if the space is big enough for drawing a node for each data point\n     * @param xAxisDataAreaLength   space\n     * @param maxNodeCount          max node count\n     * @returns {boolean}           if big enough\n     */\n    isContinual: function(xAxisDataAreaLength, maxNodeCount){\n        return xAxisDataAreaLength / maxNodeCount < 20;\n    }\n};\n\n//# sourceURL=webpack:///./src/DataAnalyst/DataAnalystCommons.js?");

/***/ }),

/***/ "./src/DataAnalyst/Pie/BasicPieDataAnalyst.js":
/*!****************************************************!*\
  !*** ./src/DataAnalyst/Pie/BasicPieDataAnalyst.js ***!
  \****************************************************/
/*! exports provided: BasicPieDataAnalyst */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicPieDataAnalyst\", function() { return BasicPieDataAnalyst; });\n/**\n * this class analyze the input data of a pie chart\n * @param input     input data of a pie chart\n * @constructor\n */\nfunction BasicPieDataAnalyst(input){\n    this.input = input;\n}\n\n/**\n * finds the total of all series' value\n * @returns {{total: number}}\n */\nBasicPieDataAnalyst.prototype.analyze = function(){\n    let total = 0;\n    for(let i = 0; i < this.input.series.length; i++){\n        total = total + this.input.series[i][1];\n    }\n\n    return {\n        total: total\n    }\n};\n\n\n//# sourceURL=webpack:///./src/DataAnalyst/Pie/BasicPieDataAnalyst.js?");

/***/ }),

/***/ "./src/DataAnalyst/Stack/BasicStackRegularDataAnalyst.js":
/*!***************************************************************!*\
  !*** ./src/DataAnalyst/Stack/BasicStackRegularDataAnalyst.js ***!
  \***************************************************************/
/*! exports provided: BasicStackRegularDataAnalyst */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicStackRegularDataAnalyst\", function() { return BasicStackRegularDataAnalyst; });\n/* harmony import */ var _DataAnalystCommons__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../DataAnalystCommons */ \"./src/DataAnalyst/DataAnalystCommons.js\");\n/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Util/Util */ \"./src/Util/Util.js\");\n/**\n * this class analyze the input data of a basic stack chart\n * @param input                 the input data of a basic stack chart\n * @param xAxisDataAreaLength   the display area length of the data. this is used to determine if the space is enough for drawing\n *                              a node for each single data point.\n * @constructor\n */\n\n\n\nfunction BasicStackRegularDataAnalyst(input, xAxisDataAreaLength){\n    this.input = input;\n    this.xAxisDataAreaLength = xAxisDataAreaLength;\n}\n\n/**\n * finds the min max value, and if the space is big enough for drawing a node for every single data point.\n * @returns the result of the analysis.\n */\nBasicStackRegularDataAnalyst.prototype.analyze = function(){\n    //initialize the minY and maxY to be 0, so that if all other values are positive, the minY is set to be 0 no matter\n    //what the smallest value is. If all other values are negative, the maxY is set to be 0 no matter what the biggest value\n    //is\n    let minY = 0;\n    let maxY = 0;\n\n    let singleSeriesLength = this.input.series[0][1].length;\n\n\n    for(let s = 0; s < singleSeriesLength; s++){\n        let stackedData = 0;\n        for(let i = 0; i < this.input.series.length; i++){\n            stackedData = stackedData +  this.input.series[i][1][s];\n\n            //compare the minY and maxY with data ever stacked (does not need to be final stacked value)/\n            if(stackedData < minY){\n                minY = stackedData;\n            }\n\n            if(stackedData > maxY){\n                maxY = stackedData\n            }\n        }\n    }\n\n    let isContinual = _DataAnalystCommons__WEBPACK_IMPORTED_MODULE_0__[\"dataAnalystCommons\"].isContinual(this.xAxisDataAreaLength, singleSeriesLength);\n\n    let maxX = _Util_Util__WEBPACK_IMPORTED_MODULE_1__[\"util\"].chooseBetween(this.input.start === undefined, 0, this.input.start) + (singleSeriesLength - 1) * this.input.interval;\n\n    return  {\n        minX: this.input.start,\n        maxX: maxX,\n        minY: minY,\n        maxY: maxY,\n        isContinual: isContinual\n    };\n};\n\n//# sourceURL=webpack:///./src/DataAnalyst/Stack/BasicStackRegularDataAnalyst.js?");

/***/ }),

/***/ "./src/DataViewer/3D/canvas-label-generator.js":
/*!*****************************************************!*\
  !*** ./src/DataViewer/3D/canvas-label-generator.js ***!
  \*****************************************************/
/*! exports provided: canvasLabelGenerator */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"canvasLabelGenerator\", function() { return canvasLabelGenerator; });\nconst canvasLabelGenerator = {\n\n    ctx : null,\n    width: 1500,\n    height: 40,\n    create: function(offScreenCanvas){\n        if(this.ctx === null){\n            offScreenCanvas.width = this.width; //make it wide enough so that I can render whatever text i want.\n            offScreenCanvas.height = this.height; //should be enough if the font size is 20px.\n            this.ctx = offScreenCanvas.getContext(\"2d\");\n        }\n        return this;\n    },\n\n    generateLabelImageDataBasedOnText: function(text){\n        this.ctx.clearRect(0, 0, this.width, this.height);\n        this.ctx.fillStyle = \"white\";\n        this.ctx.fillRect(0, 0, this.width, this.height);\n        this.ctx.fillStyle = \"black\";\n        this.ctx.font = \"30px Arial\";\n        this.ctx.textAlign = \"center\";\n        this.ctx.textBaseline = \"middle\";\n\n        let textWidth = this.ctx.measureText(text).width + 10;//plus 10 to allow some buffer...\n        this.ctx.fillText(text, textWidth/2, this.height/2);\n\n        return {\n            imageData: this.ctx.getImageData(0, 0, textWidth, this.height),\n            textWidth: textWidth,\n            textHeight: this.height\n        };\n    }\n};\n\n\n//# sourceURL=webpack:///./src/DataViewer/3D/canvas-label-generator.js?");

/***/ }),

/***/ "./src/DataViewer/3D/gl-matrix.js":
/*!****************************************!*\
  !*** ./src/DataViewer/3D/gl-matrix.js ***!
  \****************************************/
/*! exports provided: glMatrix, vec2, vec3, vec4, mat2, mat2d, mat3, mat4, quat */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"glMatrix\", function() { return glMatrix; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vec2\", function() { return vec2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vec3\", function() { return vec3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"vec4\", function() { return vec4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mat2\", function() { return mat2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mat2d\", function() { return mat2d; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mat3\", function() { return mat3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"mat4\", function() { return mat4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"quat\", function() { return quat; });\n/**\n * @fileoverview gl-matrix - High performance matrix and vector operations\n * @author Brandon Jones\n * @author Colin MacKenzie IV\n * @version 2.2.1\n */\n\n/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\n\n\n/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\n\n\nif (!GLMAT_EPSILON) {\n    var GLMAT_EPSILON = 0.000001;\n}\n\nif (!GLMAT_ARRAY_TYPE) {\n    var GLMAT_ARRAY_TYPE = (typeof Float32Array !== 'undefined') ? Float32Array : Array;\n}\n\nif (!GLMAT_RANDOM) {\n    var GLMAT_RANDOM = Math.random;\n}\n\n/**\n * @class Common utilities\n * @name glMatrix\n */\nconst glMatrix = {};\n\n/**\n * Sets the type of array used when creating new vectors and matricies\n *\n * @param {Type} type Array type, such as Float32Array or Array\n */\nglMatrix.setMatrixArrayType = function (type) {\n    GLMAT_ARRAY_TYPE = type;\n}\n\n\nvar degree = Math.PI / 180;\n\n/**\n * Convert Degree To Radian\n *\n * @param {Number} Angle in Degrees\n */\nglMatrix.toRadian = function (a) {\n    return a * degree;\n}\n;\n/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\n\n/**\n * @class 2 Dimensional Vector\n * @name vec2\n */\n\nconst vec2 = {};\n\n/**\n * Creates a new, empty vec2\n *\n * @returns {vec2} a new 2D vector\n */\nvec2.create = function () {\n    var out = new GLMAT_ARRAY_TYPE(2);\n    out[0] = 0;\n    out[1] = 0;\n    return out;\n};\n\n/**\n * Creates a new vec2 initialized with values from an existing vector\n *\n * @param {vec2} a vector to clone\n * @returns {vec2} a new 2D vector\n */\nvec2.clone = function (a) {\n    var out = new GLMAT_ARRAY_TYPE(2);\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n};\n\n/**\n * Creates a new vec2 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} a new 2D vector\n */\nvec2.fromValues = function (x, y) {\n    var out = new GLMAT_ARRAY_TYPE(2);\n    out[0] = x;\n    out[1] = y;\n    return out;\n};\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the source vector\n * @returns {vec2} out\n */\nvec2.copy = function (out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n};\n\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\nvec2.set = function (out, x, y) {\n    out[0] = x;\n    out[1] = y;\n    return out;\n};\n\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.add = function (out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    return out;\n};\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.subtract = function (out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    return out;\n};\n\n/**\n * Alias for {@link vec2.subtract}\n * @function\n */\nvec2.sub = vec2.subtract;\n\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.multiply = function (out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    return out;\n};\n\n/**\n * Alias for {@link vec2.multiply}\n * @function\n */\nvec2.mul = vec2.multiply;\n\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.divide = function (out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    return out;\n};\n\n/**\n * Alias for {@link vec2.divide}\n * @function\n */\nvec2.div = vec2.divide;\n\n/**\n * Returns the minimum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.min = function (out, a, b) {\n    out[0] = Math.min(a[0], b[0]);\n    out[1] = Math.min(a[1], b[1]);\n    return out;\n};\n\n/**\n * Returns the maximum of two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nvec2.max = function (out, a, b) {\n    out[0] = Math.max(a[0], b[0]);\n    out[1] = Math.max(a[1], b[1]);\n    return out;\n};\n\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\nvec2.scale = function (out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    return out;\n};\n\n/**\n * Adds two vec2's after scaling the second operand by a scalar value\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec2} out\n */\nvec2.scaleAndAdd = function (out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    return out;\n};\n\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} distance between a and b\n */\nvec2.distance = function (a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return Math.sqrt(x * x + y * y);\n};\n\n/**\n * Alias for {@link vec2.distance}\n * @function\n */\nvec2.dist = vec2.distance;\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\nvec2.squaredDistance = function (a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return x * x + y * y;\n};\n\n/**\n * Alias for {@link vec2.squaredDistance}\n * @function\n */\nvec2.sqrDist = vec2.squaredDistance;\n\n/**\n * Calculates the length of a vec2\n *\n * @param {vec2} a vector to calculate length of\n * @returns {Number} length of a\n */\nvec2.length = function (a) {\n    var x = a[0],\n        y = a[1];\n    return Math.sqrt(x * x + y * y);\n};\n\n/**\n * Alias for {@link vec2.length}\n * @function\n */\nvec2.len = vec2.length;\n\n/**\n * Calculates the squared length of a vec2\n *\n * @param {vec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nvec2.squaredLength = function (a) {\n    var x = a[0],\n        y = a[1];\n    return x * x + y * y;\n};\n\n/**\n * Alias for {@link vec2.squaredLength}\n * @function\n */\nvec2.sqrLen = vec2.squaredLength;\n\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to negate\n * @returns {vec2} out\n */\nvec2.negate = function (out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    return out;\n};\n\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to normalize\n * @returns {vec2} out\n */\nvec2.normalize = function (out, a) {\n    var x = a[0],\n        y = a[1];\n    var len = x * x + y * y;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n        out[0] = a[0] * len;\n        out[1] = a[1] * len;\n    }\n    return out;\n};\n\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} dot product of a and b\n */\nvec2.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n};\n\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product must by definition produce a 3D vector\n *\n * @param {vec3} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec3} out\n */\nvec2.cross = function (out, a, b) {\n    var z = a[0] * b[1] - a[1] * b[0];\n    out[0] = out[1] = 0;\n    out[2] = z;\n    return out;\n};\n\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec2} out\n */\nvec2.lerp = function (out, a, b, t) {\n    var ax = a[0],\n        ay = a[1];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    return out;\n};\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec2} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec2} out\n */\nvec2.random = function (out, scale) {\n    scale = scale || 1.0;\n    var r = GLMAT_RANDOM() * 2.0 * Math.PI;\n    out[0] = Math.cos(r) * scale;\n    out[1] = Math.sin(r) * scale;\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat2 = function (out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y;\n    out[1] = m[1] * x + m[3] * y;\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2d} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat2d = function (out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y + m[4];\n    out[1] = m[1] * x + m[3] * y + m[5];\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat3} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat3 = function (out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[3] * y + m[6];\n    out[1] = m[1] * x + m[4] * y + m[7];\n    return out;\n};\n\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec2} out\n */\nvec2.transformMat4 = function (out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[4] * y + m[12];\n    out[1] = m[1] * x + m[5] * y + m[13];\n    return out;\n};\n\n/**\n * Perform some operation over an array of vec2s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nvec2.forEach = (function () {\n    var vec = vec2.create();\n\n    return function (a, stride, offset, count, fn, arg) {\n        var i, l;\n        if (!stride) {\n            stride = 2;\n        }\n\n        if (!offset) {\n            offset = 0;\n        }\n\n        if (count) {\n            l = Math.min((count * stride) + offset, a.length);\n        } else {\n            l = a.length;\n        }\n\n        for (i = offset; i < l; i += stride) {\n            vec[0] = a[i];\n            vec[1] = a[i + 1];\n            fn(vec, vec, arg);\n            a[i] = vec[0];\n            a[i + 1] = vec[1];\n        }\n\n        return a;\n    };\n})();\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec2} vec vector to represent as a string\n * @returns {String} string representation of the vector\n */\nvec2.str = function (a) {\n    return 'vec2(' + a[0] + ', ' + a[1] + ')';\n};\n\n/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\n\n/**\n * @class 3 Dimensional Vector\n * @name vec3\n */\n\nconst vec3 = {};\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\nvec3.create = function () {\n    var out = new GLMAT_ARRAY_TYPE(3);\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    return out;\n};\n\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {vec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\nvec3.clone = function (a) {\n    var out = new GLMAT_ARRAY_TYPE(3);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    return out;\n};\n\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\nvec3.fromValues = function (x, y, z) {\n    var out = new GLMAT_ARRAY_TYPE(3);\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    return out;\n};\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nvec3.copy = function (out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    return out;\n};\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nvec3.set = function (out, x, y, z) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    return out;\n};\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.add = function (out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    return out;\n};\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.subtract = function (out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    return out;\n};\n\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\nvec3.sub = vec3.subtract;\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.multiply = function (out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    out[2] = a[2] * b[2];\n    return out;\n};\n\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\nvec3.mul = vec3.multiply;\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.divide = function (out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    out[2] = a[2] / b[2];\n    return out;\n};\n\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\nvec3.div = vec3.divide;\n\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.min = function (out, a, b) {\n    out[0] = Math.min(a[0], b[0]);\n    out[1] = Math.min(a[1], b[1]);\n    out[2] = Math.min(a[2], b[2]);\n    return out;\n};\n\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.max = function (out, a, b) {\n    out[0] = Math.max(a[0], b[0]);\n    out[1] = Math.max(a[1], b[1]);\n    out[2] = Math.max(a[2], b[2]);\n    return out;\n};\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nvec3.scale = function (out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    return out;\n};\n\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\nvec3.scaleAndAdd = function (out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    return out;\n};\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nvec3.distance = function (a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2];\n    return Math.sqrt(x * x + y * y + z * z);\n};\n\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\nvec3.dist = vec3.distance;\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nvec3.squaredDistance = function (a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2];\n    return x * x + y * y + z * z;\n};\n\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\nvec3.sqrDist = vec3.squaredDistance;\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nvec3.length = function (a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2];\n    return Math.sqrt(x * x + y * y + z * z);\n};\n\n/**\n * Alias for {@link vec3.length}\n * @function\n */\nvec3.len = vec3.length;\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nvec3.squaredLength = function (a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2];\n    return x * x + y * y + z * z;\n};\n\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\nvec3.sqrLen = vec3.squaredLength;\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nvec3.negate = function (out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    return out;\n};\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nvec3.normalize = function (out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2];\n    var len = x * x + y * y + z * z;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n        out[0] = a[0] * len;\n        out[1] = a[1] * len;\n        out[2] = a[2] * len;\n    }\n    return out;\n};\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nvec3.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n};\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nvec3.cross = function (out, a, b) {\n    var ax = a[0], ay = a[1], az = a[2],\n        bx = b[0], by = b[1], bz = b[2];\n\n    out[0] = ay * bz - az * by;\n    out[1] = az * bx - ax * bz;\n    out[2] = ax * by - ay * bx;\n    return out;\n};\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nvec3.lerp = function (out, a, b, t) {\n    var ax = a[0],\n        ay = a[1],\n        az = a[2];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    return out;\n};\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\nvec3.random = function (out, scale) {\n    scale = scale || 1.0;\n\n    var r = GLMAT_RANDOM() * 2.0 * Math.PI;\n    var z = (GLMAT_RANDOM() * 2.0) - 1.0;\n    var zScale = Math.sqrt(1.0 - z * z) * scale;\n\n    out[0] = Math.cos(r) * zScale;\n    out[1] = Math.sin(r) * zScale;\n    out[2] = z * scale;\n    return out;\n};\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nvec3.transformMat4 = function (out, a, m) {\n    var x = a[0], y = a[1], z = a[2];\n    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];\n    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];\n    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];\n    return out;\n};\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nvec3.transformMat3 = function (out, a, m) {\n    var x = a[0], y = a[1], z = a[2];\n    out[0] = x * m[0] + y * m[3] + z * m[6];\n    out[1] = x * m[1] + y * m[4] + z * m[7];\n    out[2] = x * m[2] + y * m[5] + z * m[8];\n    return out;\n};\n\n/**\n * Transforms the vec3 with a quat\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\nvec3.transformQuat = function (out, a, q) {\n    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations\n\n    var x = a[0], y = a[1], z = a[2],\n        qx = q[0], qy = q[1], qz = q[2], qw = q[3],\n\n        // calculate quat * vec\n        ix = qw * x + qy * z - qz * y,\n        iy = qw * y + qz * x - qx * z,\n        iz = qw * z + qx * y - qy * x,\n        iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    return out;\n};\n\n/*\n* Rotate a 3D vector around the x-axis\n* @param {vec3} out The receiving vec3\n* @param {vec3} a The vec3 point to rotate\n* @param {vec3} b The origin of the rotation\n* @param {Number} c The angle of rotation\n* @returns {vec3} out\n*/\nvec3.rotateX = function (out, a, b, c) {\n    var p = [], r = [];\n    //Translate point to the origin\n    p[0] = a[0] - b[0];\n    p[1] = a[1] - b[1];\n    p[2] = a[2] - b[2];\n\n    //perform rotation\n    r[0] = p[0];\n    r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);\n    r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);\n\n    //translate to correct position\n    out[0] = r[0] + b[0];\n    out[1] = r[1] + b[1];\n    out[2] = r[2] + b[2];\n\n    return out;\n};\n\n/*\n* Rotate a 3D vector around the y-axis\n* @param {vec3} out The receiving vec3\n* @param {vec3} a The vec3 point to rotate\n* @param {vec3} b The origin of the rotation\n* @param {Number} c The angle of rotation\n* @returns {vec3} out\n*/\nvec3.rotateY = function (out, a, b, c) {\n    var p = [], r = [];\n    //Translate point to the origin\n    p[0] = a[0] - b[0];\n    p[1] = a[1] - b[1];\n    p[2] = a[2] - b[2];\n\n    //perform rotation\n    r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);\n    r[1] = p[1];\n    r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);\n\n    //translate to correct position\n    out[0] = r[0] + b[0];\n    out[1] = r[1] + b[1];\n    out[2] = r[2] + b[2];\n\n    return out;\n};\n\n/*\n* Rotate a 3D vector around the z-axis\n* @param {vec3} out The receiving vec3\n* @param {vec3} a The vec3 point to rotate\n* @param {vec3} b The origin of the rotation\n* @param {Number} c The angle of rotation\n* @returns {vec3} out\n*/\nvec3.rotateZ = function (out, a, b, c) {\n    var p = [], r = [];\n    //Translate point to the origin\n    p[0] = a[0] - b[0];\n    p[1] = a[1] - b[1];\n    p[2] = a[2] - b[2];\n\n    //perform rotation\n    r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);\n    r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);\n    r[2] = p[2];\n\n    //translate to correct position\n    out[0] = r[0] + b[0];\n    out[1] = r[1] + b[1];\n    out[2] = r[2] + b[2];\n\n    return out;\n};\n\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nvec3.forEach = (function () {\n    var vec = vec3.create();\n\n    return function (a, stride, offset, count, fn, arg) {\n        var i, l;\n        if (!stride) {\n            stride = 3;\n        }\n\n        if (!offset) {\n            offset = 0;\n        }\n\n        if (count) {\n            l = Math.min((count * stride) + offset, a.length);\n        } else {\n            l = a.length;\n        }\n\n        for (i = offset; i < l; i += stride) {\n            vec[0] = a[i];\n            vec[1] = a[i + 1];\n            vec[2] = a[i + 2];\n            fn(vec, vec, arg);\n            a[i] = vec[0];\n            a[i + 1] = vec[1];\n            a[i + 2] = vec[2];\n        }\n\n        return a;\n    };\n})();\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec3} vec vector to represent as a string\n * @returns {String} string representation of the vector\n */\nvec3.str = function (a) {\n    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';\n};\n\n/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\n\n/**\n * @class 4 Dimensional Vector\n * @name vec4\n */\n\nconst vec4 = {};\n\n/**\n * Creates a new, empty vec4\n *\n * @returns {vec4} a new 4D vector\n */\nvec4.create = function () {\n    var out = new GLMAT_ARRAY_TYPE(4);\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    return out;\n};\n\n/**\n * Creates a new vec4 initialized with values from an existing vector\n *\n * @param {vec4} a vector to clone\n * @returns {vec4} a new 4D vector\n */\nvec4.clone = function (a) {\n    var out = new GLMAT_ARRAY_TYPE(4);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Creates a new vec4 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} a new 4D vector\n */\nvec4.fromValues = function (x, y, z, w) {\n    var out = new GLMAT_ARRAY_TYPE(4);\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = w;\n    return out;\n};\n\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the source vector\n * @returns {vec4} out\n */\nvec4.copy = function (out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\nvec4.set = function (out, x, y, z, w) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = w;\n    return out;\n};\n\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.add = function (out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    return out;\n};\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.subtract = function (out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    return out;\n};\n\n/**\n * Alias for {@link vec4.subtract}\n * @function\n */\nvec4.sub = vec4.subtract;\n\n/**\n * Multiplies two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.multiply = function (out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    out[2] = a[2] * b[2];\n    out[3] = a[3] * b[3];\n    return out;\n};\n\n/**\n * Alias for {@link vec4.multiply}\n * @function\n */\nvec4.mul = vec4.multiply;\n\n/**\n * Divides two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.divide = function (out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    out[2] = a[2] / b[2];\n    out[3] = a[3] / b[3];\n    return out;\n};\n\n/**\n * Alias for {@link vec4.divide}\n * @function\n */\nvec4.div = vec4.divide;\n\n/**\n * Returns the minimum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.min = function (out, a, b) {\n    out[0] = Math.min(a[0], b[0]);\n    out[1] = Math.min(a[1], b[1]);\n    out[2] = Math.min(a[2], b[2]);\n    out[3] = Math.min(a[3], b[3]);\n    return out;\n};\n\n/**\n * Returns the maximum of two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nvec4.max = function (out, a, b) {\n    out[0] = Math.max(a[0], b[0]);\n    out[1] = Math.max(a[1], b[1]);\n    out[2] = Math.max(a[2], b[2]);\n    out[3] = Math.max(a[3], b[3]);\n    return out;\n};\n\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\nvec4.scale = function (out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    return out;\n};\n\n/**\n * Adds two vec4's after scaling the second operand by a scalar value\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec4} out\n */\nvec4.scaleAndAdd = function (out, a, b, scale) {\n    out[0] = a[0] + (b[0] * scale);\n    out[1] = a[1] + (b[1] * scale);\n    out[2] = a[2] + (b[2] * scale);\n    out[3] = a[3] + (b[3] * scale);\n    return out;\n};\n\n/**\n * Calculates the euclidian distance between two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} distance between a and b\n */\nvec4.distance = function (a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2],\n        w = b[3] - a[3];\n    return Math.sqrt(x * x + y * y + z * z + w * w);\n};\n\n/**\n * Alias for {@link vec4.distance}\n * @function\n */\nvec4.dist = vec4.distance;\n\n/**\n * Calculates the squared euclidian distance between two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} squared distance between a and b\n */\nvec4.squaredDistance = function (a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1],\n        z = b[2] - a[2],\n        w = b[3] - a[3];\n    return x * x + y * y + z * z + w * w;\n};\n\n/**\n * Alias for {@link vec4.squaredDistance}\n * @function\n */\nvec4.sqrDist = vec4.squaredDistance;\n\n/**\n * Calculates the length of a vec4\n *\n * @param {vec4} a vector to calculate length of\n * @returns {Number} length of a\n */\nvec4.length = function (a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2],\n        w = a[3];\n    return Math.sqrt(x * x + y * y + z * z + w * w);\n};\n\n/**\n * Alias for {@link vec4.length}\n * @function\n */\nvec4.len = vec4.length;\n\n/**\n * Calculates the squared length of a vec4\n *\n * @param {vec4} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nvec4.squaredLength = function (a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2],\n        w = a[3];\n    return x * x + y * y + z * z + w * w;\n};\n\n/**\n * Alias for {@link vec4.squaredLength}\n * @function\n */\nvec4.sqrLen = vec4.squaredLength;\n\n/**\n * Negates the components of a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to negate\n * @returns {vec4} out\n */\nvec4.negate = function (out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] = -a[3];\n    return out;\n};\n\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to normalize\n * @returns {vec4} out\n */\nvec4.normalize = function (out, a) {\n    var x = a[0],\n        y = a[1],\n        z = a[2],\n        w = a[3];\n    var len = x * x + y * y + z * z + w * w;\n    if (len > 0) {\n        len = 1 / Math.sqrt(len);\n        out[0] = a[0] * len;\n        out[1] = a[1] * len;\n        out[2] = a[2] * len;\n        out[3] = a[3] * len;\n    }\n    return out;\n};\n\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} dot product of a and b\n */\nvec4.dot = function (a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n};\n\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec4} out\n */\nvec4.lerp = function (out, a, b, t) {\n    var ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    out[3] = aw + t * (b[3] - aw);\n    return out;\n};\n\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec4} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec4} out\n */\nvec4.random = function (out, scale) {\n    scale = scale || 1.0;\n\n    //TODO: This is a pretty awful way of doing this. Find something better.\n    out[0] = GLMAT_RANDOM();\n    out[1] = GLMAT_RANDOM();\n    out[2] = GLMAT_RANDOM();\n    out[3] = GLMAT_RANDOM();\n    vec4.normalize(out, out);\n    vec4.scale(out, out, scale);\n    return out;\n};\n\n/**\n * Transforms the vec4 with a mat4.\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec4} out\n */\nvec4.transformMat4 = function (out, a, m) {\n    var x = a[0], y = a[1], z = a[2], w = a[3];\n    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;\n    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;\n    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;\n    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;\n    return out;\n};\n\n/**\n * Transforms the vec4 with a quat\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec4} out\n */\nvec4.transformQuat = function (out, a, q) {\n    var x = a[0], y = a[1], z = a[2],\n        qx = q[0], qy = q[1], qz = q[2], qw = q[3],\n\n        // calculate quat * vec\n        ix = qw * x + qy * z - qz * y,\n        iy = qw * y + qz * x - qx * z,\n        iz = qw * z + qx * y - qy * x,\n        iw = -qx * x - qy * y - qz * z;\n\n    // calculate result * inverse quat\n    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n    return out;\n};\n\n/**\n * Perform some operation over an array of vec4s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\nvec4.forEach = (function () {\n    var vec = vec4.create();\n\n    return function (a, stride, offset, count, fn, arg) {\n        var i, l;\n        if (!stride) {\n            stride = 4;\n        }\n\n        if (!offset) {\n            offset = 0;\n        }\n\n        if (count) {\n            l = Math.min((count * stride) + offset, a.length);\n        } else {\n            l = a.length;\n        }\n\n        for (i = offset; i < l; i += stride) {\n            vec[0] = a[i];\n            vec[1] = a[i + 1];\n            vec[2] = a[i + 2];\n            vec[3] = a[i + 3];\n            fn(vec, vec, arg);\n            a[i] = vec[0];\n            a[i + 1] = vec[1];\n            a[i + 2] = vec[2];\n            a[i + 3] = vec[3];\n        }\n\n        return a;\n    };\n})();\n\n/**\n * Returns a string representation of a vector\n *\n * @param {vec4} vec vector to represent as a string\n * @returns {String} string representation of the vector\n */\nvec4.str = function (a) {\n    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n};\n\n/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\n\n/**\n * @class 2x2 Matrix\n * @name mat2\n */\n\nconst mat2 = {};\n\n/**\n * Creates a new identity mat2\n *\n * @returns {mat2} a new 2x2 matrix\n */\nmat2.create = function () {\n    var out = new GLMAT_ARRAY_TYPE(4);\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n};\n\n/**\n * Creates a new mat2 initialized with values from an existing matrix\n *\n * @param {mat2} a matrix to clone\n * @returns {mat2} a new 2x2 matrix\n */\nmat2.clone = function (a) {\n    var out = new GLMAT_ARRAY_TYPE(4);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Copy the values from one mat2 to another\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nmat2.copy = function (out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Set a mat2 to the identity matrix\n *\n * @param {mat2} out the receiving matrix\n * @returns {mat2} out\n */\nmat2.identity = function (out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n};\n\n/**\n * Transpose the values of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nmat2.transpose = function (out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        var a1 = a[1];\n        out[1] = a[2];\n        out[2] = a1;\n    } else {\n        out[0] = a[0];\n        out[1] = a[2];\n        out[2] = a[1];\n        out[3] = a[3];\n    }\n\n    return out;\n};\n\n/**\n * Inverts a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nmat2.invert = function (out, a) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],\n\n        // Calculate the determinant\n        det = a0 * a3 - a2 * a1;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = a3 * det;\n    out[1] = -a1 * det;\n    out[2] = -a2 * det;\n    out[3] = a0 * det;\n\n    return out;\n};\n\n/**\n * Calculates the adjugate of a mat2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the source matrix\n * @returns {mat2} out\n */\nmat2.adjoint = function (out, a) {\n    // Caching this value is nessecary if out == a\n    var a0 = a[0];\n    out[0] = a[3];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] = a0;\n\n    return out;\n};\n\n/**\n * Calculates the determinant of a mat2\n *\n * @param {mat2} a the source matrix\n * @returns {Number} determinant of a\n */\nmat2.determinant = function (a) {\n    return a[0] * a[3] - a[2] * a[1];\n};\n\n/**\n * Multiplies two mat2's\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the first operand\n * @param {mat2} b the second operand\n * @returns {mat2} out\n */\nmat2.multiply = function (out, a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];\n    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    out[0] = a0 * b0 + a2 * b1;\n    out[1] = a1 * b0 + a3 * b1;\n    out[2] = a0 * b2 + a2 * b3;\n    out[3] = a1 * b2 + a3 * b3;\n    return out;\n};\n\n/**\n * Alias for {@link mat2.multiply}\n * @function\n */\nmat2.mul = mat2.multiply;\n\n/**\n * Rotates a mat2 by the given angle\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2} out\n */\nmat2.rotate = function (out, a, rad) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],\n        s = Math.sin(rad),\n        c = Math.cos(rad);\n    out[0] = a0 * c + a2 * s;\n    out[1] = a1 * c + a3 * s;\n    out[2] = a0 * -s + a2 * c;\n    out[3] = a1 * -s + a3 * c;\n    return out;\n};\n\n/**\n * Scales the mat2 by the dimensions in the given vec2\n *\n * @param {mat2} out the receiving matrix\n * @param {mat2} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat2} out\n **/\nmat2.scale = function (out, a, v) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],\n        v0 = v[0], v1 = v[1];\n    out[0] = a0 * v0;\n    out[1] = a1 * v0;\n    out[2] = a2 * v1;\n    out[3] = a3 * v1;\n    return out;\n};\n\n/**\n * Returns a string representation of a mat2\n *\n * @param {mat2} mat matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nmat2.str = function (a) {\n    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n};\n\n/**\n * Returns Frobenius norm of a mat2\n *\n * @param {mat2} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nmat2.frob = function (a) {\n    return (Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2)))\n};\n\n/**\n * Returns L, D and U matrices (Lower triangular, Diagonal and Upper triangular) by factorizing the input matrix\n * @param {mat2} L the lower triangular matrix\n * @param {mat2} D the diagonal matrix\n * @param {mat2} U the upper triangular matrix\n * @param {mat2} a the input matrix to factorize\n */\n\nmat2.LDU = function (L, D, U, a) {\n    L[2] = a[2] / a[0];\n    U[0] = a[0];\n    U[1] = a[1];\n    U[3] = a[3] - L[2] * U[1];\n    return [L, D, U];\n};\n\n/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\n\n/**\n * @class 2x3 Matrix\n * @name mat2d\n *\n * @description\n * A mat2d contains six elements defined as:\n * <pre>\n * [a, c, tx,\n *  b, d, ty]\n * </pre>\n * This is a short form for the 3x3 matrix:\n * <pre>\n * [a, c, tx,\n *  b, d, ty,\n *  0, 0, 1]\n * </pre>\n * The last row is ignored so the array is shorter and operations are faster.\n */\n\nconst mat2d = {};\n\n/**\n * Creates a new identity mat2d\n *\n * @returns {mat2d} a new 2x3 matrix\n */\nmat2d.create = function () {\n    var out = new GLMAT_ARRAY_TYPE(6);\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    out[4] = 0;\n    out[5] = 0;\n    return out;\n};\n\n/**\n * Creates a new mat2d initialized with values from an existing matrix\n *\n * @param {mat2d} a matrix to clone\n * @returns {mat2d} a new 2x3 matrix\n */\nmat2d.clone = function (a) {\n    var out = new GLMAT_ARRAY_TYPE(6);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    return out;\n};\n\n/**\n * Copy the values from one mat2d to another\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the source matrix\n * @returns {mat2d} out\n */\nmat2d.copy = function (out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    return out;\n};\n\n/**\n * Set a mat2d to the identity matrix\n *\n * @param {mat2d} out the receiving matrix\n * @returns {mat2d} out\n */\nmat2d.identity = function (out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    out[4] = 0;\n    out[5] = 0;\n    return out;\n};\n\n/**\n * Inverts a mat2d\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the source matrix\n * @returns {mat2d} out\n */\nmat2d.invert = function (out, a) {\n    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],\n        atx = a[4], aty = a[5];\n\n    var det = aa * ad - ab * ac;\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = ad * det;\n    out[1] = -ab * det;\n    out[2] = -ac * det;\n    out[3] = aa * det;\n    out[4] = (ac * aty - ad * atx) * det;\n    out[5] = (ab * atx - aa * aty) * det;\n    return out;\n};\n\n/**\n * Calculates the determinant of a mat2d\n *\n * @param {mat2d} a the source matrix\n * @returns {Number} determinant of a\n */\nmat2d.determinant = function (a) {\n    return a[0] * a[3] - a[1] * a[2];\n};\n\n/**\n * Multiplies two mat2d's\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the first operand\n * @param {mat2d} b the second operand\n * @returns {mat2d} out\n */\nmat2d.multiply = function (out, a, b) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],\n        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5];\n    out[0] = a0 * b0 + a2 * b1;\n    out[1] = a1 * b0 + a3 * b1;\n    out[2] = a0 * b2 + a2 * b3;\n    out[3] = a1 * b2 + a3 * b3;\n    out[4] = a0 * b4 + a2 * b5 + a4;\n    out[5] = a1 * b4 + a3 * b5 + a5;\n    return out;\n};\n\n/**\n * Alias for {@link mat2d.multiply}\n * @function\n */\nmat2d.mul = mat2d.multiply;\n\n\n/**\n * Rotates a mat2d by the given angle\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat2d} out\n */\nmat2d.rotate = function (out, a, rad) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],\n        s = Math.sin(rad),\n        c = Math.cos(rad);\n    out[0] = a0 * c + a2 * s;\n    out[1] = a1 * c + a3 * s;\n    out[2] = a0 * -s + a2 * c;\n    out[3] = a1 * -s + a3 * c;\n    out[4] = a4;\n    out[5] = a5;\n    return out;\n};\n\n/**\n * Scales the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to translate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat2d} out\n **/\nmat2d.scale = function (out, a, v) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],\n        v0 = v[0], v1 = v[1];\n    out[0] = a0 * v0;\n    out[1] = a1 * v0;\n    out[2] = a2 * v1;\n    out[3] = a3 * v1;\n    out[4] = a4;\n    out[5] = a5;\n    return out;\n};\n\n/**\n * Translates the mat2d by the dimensions in the given vec2\n *\n * @param {mat2d} out the receiving matrix\n * @param {mat2d} a the matrix to translate\n * @param {vec2} v the vec2 to translate the matrix by\n * @returns {mat2d} out\n **/\nmat2d.translate = function (out, a, v) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3], a4 = a[4], a5 = a[5],\n        v0 = v[0], v1 = v[1];\n    out[0] = a0;\n    out[1] = a1;\n    out[2] = a2;\n    out[3] = a3;\n    out[4] = a0 * v0 + a2 * v1 + a4;\n    out[5] = a1 * v0 + a3 * v1 + a5;\n    return out;\n};\n\n/**\n * Returns a string representation of a mat2d\n *\n * @param {mat2d} a matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nmat2d.str = function (a) {\n    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +\n        a[3] + ', ' + a[4] + ', ' + a[5] + ')';\n};\n\n/**\n * Returns Frobenius norm of a mat2d\n *\n * @param {mat2d} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nmat2d.frob = function (a) {\n    return (Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + 1))\n};\n\n/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\n\n/**\n * @class 3x3 Matrix\n * @name mat3\n */\n\nconst mat3 = {};\n\n/**\n * Creates a new identity mat3\n *\n * @returns {mat3} a new 3x3 matrix\n */\nmat3.create = function () {\n    var out = new GLMAT_ARRAY_TYPE(9);\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n};\n\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {mat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\nmat3.fromMat4 = function (out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[4];\n    out[4] = a[5];\n    out[5] = a[6];\n    out[6] = a[8];\n    out[7] = a[9];\n    out[8] = a[10];\n    return out;\n};\n\n/**\n * Creates a new mat3 initialized with values from an existing matrix\n *\n * @param {mat3} a matrix to clone\n * @returns {mat3} a new 3x3 matrix\n */\nmat3.clone = function (a) {\n    var out = new GLMAT_ARRAY_TYPE(9);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n};\n\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nmat3.copy = function (out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n};\n\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nmat3.identity = function (out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n};\n\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nmat3.transpose = function (out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        var a01 = a[1], a02 = a[2], a12 = a[5];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a01;\n        out[5] = a[7];\n        out[6] = a02;\n        out[7] = a12;\n    } else {\n        out[0] = a[0];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a[1];\n        out[4] = a[4];\n        out[5] = a[7];\n        out[6] = a[2];\n        out[7] = a[5];\n        out[8] = a[8];\n    }\n\n    return out;\n};\n\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nmat3.invert = function (out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8],\n\n        b01 = a22 * a11 - a12 * a21,\n        b11 = -a22 * a10 + a12 * a20,\n        b21 = a21 * a10 - a11 * a20,\n\n        // Calculate the determinant\n        det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = b01 * det;\n    out[1] = (-a22 * a01 + a02 * a21) * det;\n    out[2] = (a12 * a01 - a02 * a11) * det;\n    out[3] = b11 * det;\n    out[4] = (a22 * a00 - a02 * a20) * det;\n    out[5] = (-a12 * a00 + a02 * a10) * det;\n    out[6] = b21 * det;\n    out[7] = (-a21 * a00 + a01 * a20) * det;\n    out[8] = (a11 * a00 - a01 * a10) * det;\n    return out;\n};\n\n/**\n * Calculates the adjugate of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nmat3.adjoint = function (out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8];\n\n    out[0] = (a11 * a22 - a12 * a21);\n    out[1] = (a02 * a21 - a01 * a22);\n    out[2] = (a01 * a12 - a02 * a11);\n    out[3] = (a12 * a20 - a10 * a22);\n    out[4] = (a00 * a22 - a02 * a20);\n    out[5] = (a02 * a10 - a00 * a12);\n    out[6] = (a10 * a21 - a11 * a20);\n    out[7] = (a01 * a20 - a00 * a21);\n    out[8] = (a00 * a11 - a01 * a10);\n    return out;\n};\n\n/**\n * Calculates the determinant of a mat3\n *\n * @param {mat3} a the source matrix\n * @returns {Number} determinant of a\n */\nmat3.determinant = function (a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8];\n\n    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n};\n\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nmat3.multiply = function (out, a, b) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8],\n\n        b00 = b[0], b01 = b[1], b02 = b[2],\n        b10 = b[3], b11 = b[4], b12 = b[5],\n        b20 = b[6], b21 = b[7], b22 = b[8];\n\n    out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n    out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n    out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n    out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n    out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n    out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n    out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n    out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n    out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n    return out;\n};\n\n/**\n * Alias for {@link mat3.multiply}\n * @function\n */\nmat3.mul = mat3.multiply;\n\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to translate\n * @param {vec2} v vector to translate by\n * @returns {mat3} out\n */\nmat3.translate = function (out, a, v) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8],\n        x = v[0], y = v[1];\n\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n\n    out[3] = a10;\n    out[4] = a11;\n    out[5] = a12;\n\n    out[6] = x * a00 + y * a10 + a20;\n    out[7] = x * a01 + y * a11 + a21;\n    out[8] = x * a02 + y * a12 + a22;\n    return out;\n};\n\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nmat3.rotate = function (out, a, rad) {\n    var a00 = a[0], a01 = a[1], a02 = a[2],\n        a10 = a[3], a11 = a[4], a12 = a[5],\n        a20 = a[6], a21 = a[7], a22 = a[8],\n\n        s = Math.sin(rad),\n        c = Math.cos(rad);\n\n    out[0] = c * a00 + s * a10;\n    out[1] = c * a01 + s * a11;\n    out[2] = c * a02 + s * a12;\n\n    out[3] = c * a10 - s * a00;\n    out[4] = c * a11 - s * a01;\n    out[5] = c * a12 - s * a02;\n\n    out[6] = a20;\n    out[7] = a21;\n    out[8] = a22;\n    return out;\n};\n\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\nmat3.scale = function (out, a, v) {\n    var x = v[0], y = v[1];\n\n    out[0] = x * a[0];\n    out[1] = x * a[1];\n    out[2] = x * a[2];\n\n    out[3] = y * a[3];\n    out[4] = y * a[4];\n    out[5] = y * a[5];\n\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n};\n\n/**\n * Copies the values from a mat2d into a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat2d} a the matrix to copy\n * @returns {mat3} out\n **/\nmat3.fromMat2d = function (out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = 0;\n\n    out[3] = a[2];\n    out[4] = a[3];\n    out[5] = 0;\n\n    out[6] = a[4];\n    out[7] = a[5];\n    out[8] = 1;\n    return out;\n};\n\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\nmat3.fromQuat = function (out, q) {\n    var x = q[0], y = q[1], z = q[2], w = q[3],\n        x2 = x + x,\n        y2 = y + y,\n        z2 = z + z,\n\n        xx = x * x2,\n        yx = y * x2,\n        yy = y * y2,\n        zx = z * x2,\n        zy = z * y2,\n        zz = z * z2,\n        wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n\n    out[0] = 1 - yy - zz;\n    out[3] = yx - wz;\n    out[6] = zx + wy;\n\n    out[1] = yx + wz;\n    out[4] = 1 - xx - zz;\n    out[7] = zy - wx;\n\n    out[2] = zx - wy;\n    out[5] = zy + wx;\n    out[8] = 1 - xx - yy;\n\n    return out;\n};\n\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {mat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\nmat3.normalFromMat4 = function (out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],\n\n        b00 = a00 * a11 - a01 * a10,\n        b01 = a00 * a12 - a02 * a10,\n        b02 = a00 * a13 - a03 * a10,\n        b03 = a01 * a12 - a02 * a11,\n        b04 = a01 * a13 - a03 * a11,\n        b05 = a02 * a13 - a03 * a12,\n        b06 = a20 * a31 - a21 * a30,\n        b07 = a20 * a32 - a22 * a30,\n        b08 = a20 * a33 - a23 * a30,\n        b09 = a21 * a32 - a22 * a31,\n        b10 = a21 * a33 - a23 * a31,\n        b11 = a22 * a33 - a23 * a32,\n\n        // Calculate the determinant\n        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n\n    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n\n    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n\n    return out;\n};\n\n/**\n * Returns a string representation of a mat3\n *\n * @param {mat3} mat matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nmat3.str = function (a) {\n    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +\n        a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +\n        a[6] + ', ' + a[7] + ', ' + a[8] + ')';\n};\n\n/**\n * Returns Frobenius norm of a mat3\n *\n * @param {mat3} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nmat3.frob = function (a) {\n    return (Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2)))\n};\n\n/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\n\n/**\n * @class 4x4 Matrix\n * @name mat4\n */\n\nconst mat4 = {};\n\n/**\n * Creates a new identity mat4\n *\n * @returns {mat4} a new 4x4 matrix\n */\nmat4.create = function () {\n    var out = new GLMAT_ARRAY_TYPE(16);\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n};\n\n/**\n * Creates a new mat4 initialized with values from an existing matrix\n *\n * @param {mat4} a matrix to clone\n * @returns {mat4} a new 4x4 matrix\n */\nmat4.clone = function (a) {\n    var out = new GLMAT_ARRAY_TYPE(16);\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n};\n\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.copy = function (out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n};\n\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nmat4.identity = function (out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n};\n\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.transpose = function (out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        var a01 = a[1], a02 = a[2], a03 = a[3],\n            a12 = a[6], a13 = a[7],\n            a23 = a[11];\n\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a01;\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a02;\n        out[9] = a12;\n        out[11] = a[14];\n        out[12] = a03;\n        out[13] = a13;\n        out[14] = a23;\n    } else {\n        out[0] = a[0];\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a[1];\n        out[5] = a[5];\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a[2];\n        out[9] = a[6];\n        out[10] = a[10];\n        out[11] = a[14];\n        out[12] = a[3];\n        out[13] = a[7];\n        out[14] = a[11];\n        out[15] = a[15];\n    }\n\n    return out;\n};\n\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.invert = function (out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],\n\n        b00 = a00 * a11 - a01 * a10,\n        b01 = a00 * a12 - a02 * a10,\n        b02 = a00 * a13 - a03 * a10,\n        b03 = a01 * a12 - a02 * a11,\n        b04 = a01 * a13 - a03 * a11,\n        b05 = a02 * a13 - a03 * a12,\n        b06 = a20 * a31 - a21 * a30,\n        b07 = a20 * a32 - a22 * a30,\n        b08 = a20 * a33 - a23 * a30,\n        b09 = a21 * a32 - a22 * a31,\n        b10 = a21 * a33 - a23 * a31,\n        b11 = a22 * a33 - a23 * a32,\n\n        // Calculate the determinant\n        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n    return out;\n};\n\n/**\n * Calculates the adjugate of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nmat4.adjoint = function (out, a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n    out[0] = (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));\n    out[1] = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));\n    out[2] = (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));\n    out[3] = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));\n    out[4] = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));\n    out[5] = (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));\n    out[6] = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));\n    out[7] = (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));\n    out[8] = (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));\n    out[9] = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));\n    out[10] = (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));\n    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));\n    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));\n    out[13] = (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));\n    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));\n    out[15] = (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));\n    return out;\n};\n\n/**\n * Calculates the determinant of a mat4\n *\n * @param {mat4} a the source matrix\n * @returns {Number} determinant of a\n */\nmat4.determinant = function (a) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],\n\n        b00 = a00 * a11 - a01 * a10,\n        b01 = a00 * a12 - a02 * a10,\n        b02 = a00 * a13 - a03 * a10,\n        b03 = a01 * a12 - a02 * a11,\n        b04 = a01 * a13 - a03 * a11,\n        b05 = a02 * a13 - a03 * a12,\n        b06 = a20 * a31 - a21 * a30,\n        b07 = a20 * a32 - a22 * a30,\n        b08 = a20 * a33 - a23 * a30,\n        b09 = a21 * a32 - a22 * a31,\n        b10 = a21 * a33 - a23 * a31,\n        b11 = a22 * a33 - a23 * a32;\n\n    // Calculate the determinant\n    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n};\n\n/**\n * Multiplies two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nmat4.multiply = function (out, a, b) {\n    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],\n        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],\n        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],\n        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];\n\n    // Cache only the current line of the second matrix\n    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];\n    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = b[4];\n    b1 = b[5];\n    b2 = b[6];\n    b3 = b[7];\n    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = b[8];\n    b1 = b[9];\n    b2 = b[10];\n    b3 = b[11];\n    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = b[12];\n    b1 = b[13];\n    b2 = b[14];\n    b3 = b[15];\n    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    return out;\n};\n\n/**\n * Alias for {@link mat4.multiply}\n * @function\n */\nmat4.mul = mat4.multiply;\n\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nmat4.translate = function (out, a, v) {\n    var x = v[0], y = v[1], z = v[2],\n        a00, a01, a02, a03,\n        a10, a11, a12, a13,\n        a20, a21, a22, a23;\n\n    if (a === out) {\n        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n    } else {\n        a00 = a[0];\n        a01 = a[1];\n        a02 = a[2];\n        a03 = a[3];\n        a10 = a[4];\n        a11 = a[5];\n        a12 = a[6];\n        a13 = a[7];\n        a20 = a[8];\n        a21 = a[9];\n        a22 = a[10];\n        a23 = a[11];\n\n        out[0] = a00;\n        out[1] = a01;\n        out[2] = a02;\n        out[3] = a03;\n        out[4] = a10;\n        out[5] = a11;\n        out[6] = a12;\n        out[7] = a13;\n        out[8] = a20;\n        out[9] = a21;\n        out[10] = a22;\n        out[11] = a23;\n\n        out[12] = a00 * x + a10 * y + a20 * z + a[12];\n        out[13] = a01 * x + a11 * y + a21 * z + a[13];\n        out[14] = a02 * x + a12 * y + a22 * z + a[14];\n        out[15] = a03 * x + a13 * y + a23 * z + a[15];\n    }\n\n    return out;\n};\n\n/**\n * Scales the mat4 by the dimensions in the given vec3\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nmat4.scale = function (out, a, v) {\n    var x = v[0], y = v[1], z = v[2];\n\n    out[0] = a[0] * x;\n    out[1] = a[1] * x;\n    out[2] = a[2] * x;\n    out[3] = a[3] * x;\n    out[4] = a[4] * y;\n    out[5] = a[5] * y;\n    out[6] = a[6] * y;\n    out[7] = a[7] * y;\n    out[8] = a[8] * z;\n    out[9] = a[9] * z;\n    out[10] = a[10] * z;\n    out[11] = a[11] * z;\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n};\n\n/**\n * Rotates a mat4 by the given angle\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nmat4.rotate = function (out, a, rad, axis) {\n    var x = axis[0], y = axis[1], z = axis[2],\n        len = Math.sqrt(x * x + y * y + z * z),\n        s, c, t,\n        a00, a01, a02, a03,\n        a10, a11, a12, a13,\n        a20, a21, a22, a23,\n        b00, b01, b02,\n        b10, b11, b12,\n        b20, b21, b22;\n\n    if (Math.abs(len) < GLMAT_EPSILON) {\n        return null;\n    }\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n\n    s = Math.sin(rad);\n    c = Math.cos(rad);\n    t = 1 - c;\n\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n\n    // Construct the elements of the rotation matrix\n    b00 = x * x * t + c;\n    b01 = y * x * t + z * s;\n    b02 = z * x * t - y * s;\n    b10 = x * y * t - z * s;\n    b11 = y * y * t + c;\n    b12 = z * y * t + x * s;\n    b20 = x * z * t + y * s;\n    b21 = y * z * t - x * s;\n    b22 = z * z * t + c;\n\n    // Perform rotation-specific matrix multiplication\n    out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n    out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n    out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n    out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n    out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n    out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n    out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n    out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n    out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n    out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n    out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n    out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged last row\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the X axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.rotateX = function (out, a, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad),\n        a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7],\n        a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged rows\n        out[0] = a[0];\n        out[1] = a[1];\n        out[2] = a[2];\n        out[3] = a[3];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    out[4] = a10 * c + a20 * s;\n    out[5] = a11 * c + a21 * s;\n    out[6] = a12 * c + a22 * s;\n    out[7] = a13 * c + a23 * s;\n    out[8] = a20 * c - a10 * s;\n    out[9] = a21 * c - a11 * s;\n    out[10] = a22 * c - a12 * s;\n    out[11] = a23 * c - a13 * s;\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the Y axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.rotateY = function (out, a, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad),\n        a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3],\n        a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged rows\n        out[4] = a[4];\n        out[5] = a[5];\n        out[6] = a[6];\n        out[7] = a[7];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    out[0] = a00 * c - a20 * s;\n    out[1] = a01 * c - a21 * s;\n    out[2] = a02 * c - a22 * s;\n    out[3] = a03 * c - a23 * s;\n    out[8] = a00 * s + a20 * c;\n    out[9] = a01 * s + a21 * c;\n    out[10] = a02 * s + a22 * c;\n    out[11] = a03 * s + a23 * c;\n    return out;\n};\n\n/**\n * Rotates a matrix by the given angle around the Z axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat4} out\n */\nmat4.rotateZ = function (out, a, rad) {\n    var s = Math.sin(rad),\n        c = Math.cos(rad),\n        a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3],\n        a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n\n    if (a !== out) { // If the source and destination differ, copy the unchanged last row\n        out[8] = a[8];\n        out[9] = a[9];\n        out[10] = a[10];\n        out[11] = a[11];\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n\n    // Perform axis-specific matrix multiplication\n    out[0] = a00 * c + a10 * s;\n    out[1] = a01 * c + a11 * s;\n    out[2] = a02 * c + a12 * s;\n    out[3] = a03 * c + a13 * s;\n    out[4] = a10 * c - a00 * s;\n    out[5] = a11 * c - a01 * s;\n    out[6] = a12 * c - a02 * s;\n    out[7] = a13 * c - a03 * s;\n    return out;\n};\n\n/**\n * Creates a matrix from a quaternion rotation and vector translation\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     var quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @returns {mat4} out\n */\nmat4.fromRotationTranslation = function (out, q, v) {\n    // Quaternion math\n    var x = q[0], y = q[1], z = q[2], w = q[3],\n        x2 = x + x,\n        y2 = y + y,\n        z2 = z + z,\n\n        xx = x * x2,\n        xy = x * y2,\n        xz = x * z2,\n        yy = y * y2,\n        yz = y * z2,\n        zz = z * z2,\n        wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n\n    out[0] = 1 - (yy + zz);\n    out[1] = xy + wz;\n    out[2] = xz - wy;\n    out[3] = 0;\n    out[4] = xy - wz;\n    out[5] = 1 - (xx + zz);\n    out[6] = yz + wx;\n    out[7] = 0;\n    out[8] = xz + wy;\n    out[9] = yz - wx;\n    out[10] = 1 - (xx + yy);\n    out[11] = 0;\n    out[12] = v[0];\n    out[13] = v[1];\n    out[14] = v[2];\n    out[15] = 1;\n\n    return out;\n};\n\nmat4.fromQuat = function (out, q) {\n    var x = q[0], y = q[1], z = q[2], w = q[3],\n        x2 = x + x,\n        y2 = y + y,\n        z2 = z + z,\n\n        xx = x * x2,\n        yx = y * x2,\n        yy = y * y2,\n        zx = z * x2,\n        zy = z * y2,\n        zz = z * z2,\n        wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n\n    out[0] = 1 - yy - zz;\n    out[1] = yx + wz;\n    out[2] = zx - wy;\n    out[3] = 0;\n\n    out[4] = yx - wz;\n    out[5] = 1 - xx - zz;\n    out[6] = zy + wx;\n    out[7] = 0;\n\n    out[8] = zx + wy;\n    out[9] = zy - wx;\n    out[10] = 1 - xx - yy;\n    out[11] = 0;\n\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n\n    return out;\n};\n\n/**\n * Generates a frustum matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {Number} left Left bound of the frustum\n * @param {Number} right Right bound of the frustum\n * @param {Number} bottom Bottom bound of the frustum\n * @param {Number} top Top bound of the frustum\n * @param {Number} near Near bound of the frustum\n * @param {Number} far Far bound of the frustum\n * @returns {mat4} out\n */\nmat4.frustum = function (out, left, right, bottom, top, near, far) {\n    var rl = 1 / (right - left),\n        tb = 1 / (top - bottom),\n        nf = 1 / (near - far);\n    out[0] = (near * 2) * rl;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = (near * 2) * tb;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = (right + left) * rl;\n    out[9] = (top + bottom) * tb;\n    out[10] = (far + near) * nf;\n    out[11] = -1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = (far * near * 2) * nf;\n    out[15] = 0;\n    return out;\n};\n\n/**\n * Generates a perspective projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nmat4.perspective = function (out, fovy, aspect, near, far) {\n    var f = 1.0 / Math.tan(fovy / 2),\n        nf = 1 / (near - far);\n    out[0] = f / aspect;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = f;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = (far + near) * nf;\n    out[11] = -1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = (2 * far * near) * nf;\n    out[15] = 0;\n    return out;\n};\n\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nmat4.ortho = function (out, left, right, bottom, top, near, far) {\n    var lr = 1 / (left - right),\n        bt = 1 / (bottom - top),\n        nf = 1 / (near - far);\n    out[0] = -2 * lr;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = -2 * bt;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 2 * nf;\n    out[11] = 0;\n    out[12] = (left + right) * lr;\n    out[13] = (top + bottom) * bt;\n    out[14] = (far + near) * nf;\n    out[15] = 1;\n    return out;\n};\n\n/**\n * Generates a look-at matrix with the given eye position, focal point, and up axis\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} center Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\nmat4.lookAt = function (out, eye, center, up) {\n    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,\n        eyex = eye[0],\n        eyey = eye[1],\n        eyez = eye[2],\n        upx = up[0],\n        upy = up[1],\n        upz = up[2],\n        centerx = center[0],\n        centery = center[1],\n        centerz = center[2];\n\n    if (Math.abs(eyex - centerx) < GLMAT_EPSILON &&\n        Math.abs(eyey - centery) < GLMAT_EPSILON &&\n        Math.abs(eyez - centerz) < GLMAT_EPSILON) {\n        return mat4.identity(out);\n    }\n\n    z0 = eyex - centerx;\n    z1 = eyey - centery;\n    z2 = eyez - centerz;\n\n    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n    z0 *= len;\n    z1 *= len;\n    z2 *= len;\n\n    x0 = upy * z2 - upz * z1;\n    x1 = upz * z0 - upx * z2;\n    x2 = upx * z1 - upy * z0;\n    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n    if (!len) {\n        x0 = 0;\n        x1 = 0;\n        x2 = 0;\n    } else {\n        len = 1 / len;\n        x0 *= len;\n        x1 *= len;\n        x2 *= len;\n    }\n\n    y0 = z1 * x2 - z2 * x1;\n    y1 = z2 * x0 - z0 * x2;\n    y2 = z0 * x1 - z1 * x0;\n\n    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n    if (!len) {\n        y0 = 0;\n        y1 = 0;\n        y2 = 0;\n    } else {\n        len = 1 / len;\n        y0 *= len;\n        y1 *= len;\n        y2 *= len;\n    }\n\n    out[0] = x0;\n    out[1] = y0;\n    out[2] = z0;\n    out[3] = 0;\n    out[4] = x1;\n    out[5] = y1;\n    out[6] = z1;\n    out[7] = 0;\n    out[8] = x2;\n    out[9] = y2;\n    out[10] = z2;\n    out[11] = 0;\n    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);\n    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);\n    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);\n    out[15] = 1;\n\n    return out;\n};\n\n/**\n * Returns a string representation of a mat4\n *\n * @param {mat4} mat matrix to represent as a string\n * @returns {String} string representation of the matrix\n */\nmat4.str = function (a) {\n    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +\n        a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +\n        a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +\n        a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';\n};\n\n/**\n * Returns Frobenius norm of a mat4\n *\n * @param {mat4} a the matrix to calculate Frobenius norm of\n * @returns {Number} Frobenius norm\n */\nmat4.frob = function (a) {\n    return (Math.sqrt(Math.pow(a[0], 2) + Math.pow(a[1], 2) + Math.pow(a[2], 2) + Math.pow(a[3], 2) + Math.pow(a[4], 2) + Math.pow(a[5], 2) + Math.pow(a[6], 2) + Math.pow(a[6], 2) + Math.pow(a[7], 2) + Math.pow(a[8], 2) + Math.pow(a[9], 2) + Math.pow(a[10], 2) + Math.pow(a[11], 2) + Math.pow(a[12], 2) + Math.pow(a[13], 2) + Math.pow(a[14], 2) + Math.pow(a[15], 2)))\n};\n\n/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n  * Redistributions of source code must retain the above copyright notice, this\n    list of conditions and the following disclaimer.\n  * Redistributions in binary form must reproduce the above copyright notice,\n    this list of conditions and the following disclaimer in the documentation\n    and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\nANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\nANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */\n\n/**\n * @class Quaternion\n * @name quat\n */\n\nconst quat = {};\n\n/**\n * Creates a new identity quat\n *\n * @returns {quat} a new quaternion\n */\nquat.create = function () {\n    var out = new GLMAT_ARRAY_TYPE(4);\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n};\n\n/**\n * Sets a quaternion to represent the shortest rotation from one\n * vector to another.\n *\n * Both vectors are assumed to be unit length.\n *\n * @param {quat} out the receiving quaternion.\n * @param {vec3} a the initial vector\n * @param {vec3} b the destination vector\n * @returns {quat} out\n */\nquat.rotationTo = (function () {\n    var tmpvec3 = vec3.create();\n    var xUnitVec3 = vec3.fromValues(1, 0, 0);\n    var yUnitVec3 = vec3.fromValues(0, 1, 0);\n\n    return function (out, a, b) {\n        var dot = vec3.dot(a, b);\n        if (dot < -0.999999) {\n            vec3.cross(tmpvec3, xUnitVec3, a);\n            if (vec3.length(tmpvec3) < 0.000001)\n                vec3.cross(tmpvec3, yUnitVec3, a);\n            vec3.normalize(tmpvec3, tmpvec3);\n            quat.setAxisAngle(out, tmpvec3, Math.PI);\n            return out;\n        } else if (dot > 0.999999) {\n            out[0] = 0;\n            out[1] = 0;\n            out[2] = 0;\n            out[3] = 1;\n            return out;\n        } else {\n            vec3.cross(tmpvec3, a, b);\n            out[0] = tmpvec3[0];\n            out[1] = tmpvec3[1];\n            out[2] = tmpvec3[2];\n            out[3] = 1 + dot;\n            return quat.normalize(out, out);\n        }\n    };\n})();\n\n/**\n * Sets the specified quaternion with values corresponding to the given\n * axes. Each axis is a vec3 and is expected to be unit length and\n * perpendicular to all other specified axes.\n *\n * @param {vec3} view  the vector representing the viewing direction\n * @param {vec3} right the vector representing the local \"right\" direction\n * @param {vec3} up    the vector representing the local \"up\" direction\n * @returns {quat} out\n */\nquat.setAxes = (function () {\n    var matr = mat3.create();\n\n    return function (out, view, right, up) {\n        matr[0] = right[0];\n        matr[3] = right[1];\n        matr[6] = right[2];\n\n        matr[1] = up[0];\n        matr[4] = up[1];\n        matr[7] = up[2];\n\n        matr[2] = -view[0];\n        matr[5] = -view[1];\n        matr[8] = -view[2];\n\n        return quat.normalize(out, quat.fromMat3(out, matr));\n    };\n})();\n\n/**\n * Creates a new quat initialized with values from an existing quaternion\n *\n * @param {quat} a quaternion to clone\n * @returns {quat} a new quaternion\n * @function\n */\nquat.clone = vec4.clone;\n\n/**\n * Creates a new quat initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} a new quaternion\n * @function\n */\nquat.fromValues = vec4.fromValues;\n\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the source quaternion\n * @returns {quat} out\n * @function\n */\nquat.copy = vec4.copy;\n\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\nquat.set = vec4.set;\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nquat.identity = function (out) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n};\n\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\nquat.setAxisAngle = function (out, axis, rad) {\n    rad = rad * 0.5;\n    var s = Math.sin(rad);\n    out[0] = s * axis[0];\n    out[1] = s * axis[1];\n    out[2] = s * axis[2];\n    out[3] = Math.cos(rad);\n    return out;\n};\n\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n * @function\n */\nquat.add = vec4.add;\n\n/**\n * Multiplies two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n */\nquat.multiply = function (out, a, b) {\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n    out[0] = ax * bw + aw * bx + ay * bz - az * by;\n    out[1] = ay * bw + aw * by + az * bx - ax * bz;\n    out[2] = az * bw + aw * bz + ax * by - ay * bx;\n    out[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return out;\n};\n\n/**\n * Alias for {@link quat.multiply}\n * @function\n */\nquat.mul = quat.multiply;\n\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {quat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\nquat.scale = vec4.scale;\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nquat.rotateX = function (out, a, rad) {\n    rad *= 0.5;\n\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        bx = Math.sin(rad), bw = Math.cos(rad);\n\n    out[0] = ax * bw + aw * bx;\n    out[1] = ay * bw + az * bx;\n    out[2] = az * bw - ay * bx;\n    out[3] = aw * bw - ax * bx;\n    return out;\n};\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nquat.rotateY = function (out, a, rad) {\n    rad *= 0.5;\n\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        by = Math.sin(rad), bw = Math.cos(rad);\n\n    out[0] = ax * bw - az * by;\n    out[1] = ay * bw + aw * by;\n    out[2] = az * bw + ax * by;\n    out[3] = aw * bw - ay * by;\n    return out;\n};\n\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nquat.rotateZ = function (out, a, rad) {\n    rad *= 0.5;\n\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        bz = Math.sin(rad), bw = Math.cos(rad);\n\n    out[0] = ax * bw + ay * bz;\n    out[1] = ay * bw - ax * bz;\n    out[2] = az * bw + aw * bz;\n    out[3] = aw * bw - az * bz;\n    return out;\n};\n\n/**\n * Calculates the W component of a quat from the X, Y, and Z components.\n * Assumes that quaternion is 1 unit in length.\n * Any existing W component will be ignored.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate W component of\n * @returns {quat} out\n */\nquat.calculateW = function (out, a) {\n    var x = a[0], y = a[1], z = a[2];\n\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));\n    return out;\n};\n\n/**\n * Calculates the dot product of two quat's\n *\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nquat.dot = vec4.dot;\n\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n * @function\n */\nquat.lerp = vec4.lerp;\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n */\nquat.slerp = function (out, a, b, t) {\n    // benchmarks:\n    //    http://jsperf.com/quaternion-slerp-implementations\n\n    var ax = a[0], ay = a[1], az = a[2], aw = a[3],\n        bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n    var omega, cosom, sinom, scale0, scale1;\n\n    // calc cosine\n    cosom = ax * bx + ay * by + az * bz + aw * bw;\n    // adjust signs (if necessary)\n    if (cosom < 0.0) {\n        cosom = -cosom;\n        bx = -bx;\n        by = -by;\n        bz = -bz;\n        bw = -bw;\n    }\n    // calculate coefficients\n    if ((1.0 - cosom) > 0.000001) {\n        // standard case (slerp)\n        omega = Math.acos(cosom);\n        sinom = Math.sin(omega);\n        scale0 = Math.sin((1.0 - t) * omega) / sinom;\n        scale1 = Math.sin(t * omega) / sinom;\n    } else {\n        // \"from\" and \"to\" quaternions are very close\n        //  ... so we can do a linear interpolation\n        scale0 = 1.0 - t;\n        scale1 = t;\n    }\n    // calculate final values\n    out[0] = scale0 * ax + scale1 * bx;\n    out[1] = scale0 * ay + scale1 * by;\n    out[2] = scale0 * az + scale1 * bz;\n    out[3] = scale0 * aw + scale1 * bw;\n\n    return out;\n};\n\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate inverse of\n * @returns {quat} out\n */\nquat.invert = function (out, a) {\n    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],\n        dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3,\n        invDot = dot ? 1.0 / dot : 0;\n\n    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n    out[0] = -a0 * invDot;\n    out[1] = -a1 * invDot;\n    out[2] = -a2 * invDot;\n    out[3] = a3 * invDot;\n    return out;\n};\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate conjugate of\n * @returns {quat} out\n */\nquat.conjugate = function (out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] = a[3];\n    return out;\n};\n\n/**\n * Calculates the length of a quat\n *\n * @param {quat} a vector to calculate length of\n * @returns {Number} length of a\n * @function\n */\nquat.length = vec4.length;\n\n/**\n * Alias for {@link quat.length}\n * @function\n */\nquat.len = quat.length;\n\n/**\n * Calculates the squared length of a quat\n *\n * @param {quat} a vector to calculate squared length of\n * @returns {Number} squared length of a\n * @function\n */\nquat.squaredLength = vec4.squaredLength;\n\n/**\n * Alias for {@link quat.squaredLength}\n * @function\n */\nquat.sqrLen = quat.squaredLength;\n\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\nquat.normalize = vec4.normalize;\n\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {mat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\nquat.fromMat3 = function (out, m) {\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    var fTrace = m[0] + m[4] + m[8];\n    var fRoot;\n\n    if (fTrace > 0.0) {\n        // |w| > 1/2, may as well choose w > 1/2\n        fRoot = Math.sqrt(fTrace + 1.0);  // 2w\n        out[3] = 0.5 * fRoot;\n        fRoot = 0.5 / fRoot;  // 1/(4w)\n        out[0] = (m[7] - m[5]) * fRoot;\n        out[1] = (m[2] - m[6]) * fRoot;\n        out[2] = (m[3] - m[1]) * fRoot;\n    } else {\n        // |w| <= 1/2\n        var i = 0;\n        if (m[4] > m[0])\n            i = 1;\n        if (m[8] > m[i * 3 + i])\n            i = 2;\n        var j = (i + 1) % 3;\n        var k = (i + 2) % 3;\n\n        fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n        out[i] = 0.5 * fRoot;\n        fRoot = 0.5 / fRoot;\n        out[3] = (m[k * 3 + j] - m[j * 3 + k]) * fRoot;\n        out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n        out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n    }\n\n    return out;\n};\n\n/**\n * Returns a string representation of a quatenion\n *\n * @param {quat} vec vector to represent as a string\n * @returns {String} string representation of the vector\n */\nquat.str = function (a) {\n    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';\n};\n\n\n//# sourceURL=webpack:///./src/DataViewer/3D/gl-matrix.js?");

/***/ }),

/***/ "./src/DataViewer/3D/three-model.js":
/*!******************************************!*\
  !*** ./src/DataViewer/3D/three-model.js ***!
  \******************************************/
/*! exports provided: threeModels */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"threeModels\", function() { return threeModels; });\n/* harmony import */ var _gl_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gl-matrix */ \"./src/DataViewer/3D/gl-matrix.js\");\n/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./webgl-util */ \"./src/DataViewer/3D/webgl-util.js\");\n/* harmony import */ var _Draw_Color__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Draw/Color */ \"./src/Draw/Color.js\");\n/* harmony import */ var _Sub_Tip_Sub_StaticControl_StaticTipControl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Sub/Tip/Sub/StaticControl/StaticTipControl */ \"./src/DataViewer/Sub/Tip/Sub/StaticControl/StaticTipControl.js\");\n\n\n\n\n\nfunction CuboidModel(translate/* [x,y,z] */, scale, mcColor, dataY, rowName, columnName, htmlContainer, staticTipControlTopShift, isStaticTipControlSingleLine) {\n    this.translate = translate;\n    this.scale = scale;\n    this.modelMatrix = _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create();\n    this.MVMatrix = _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create();\n    this.MVPMatrix = _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create();\n    this.normalMatrix = _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat3\"].create();\n    this.isFocus = false;\n    this.identityMatrix = _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create();\n\n    this.mcColor = mcColor;\n    this.fillColorArray = _Draw_Color__WEBPACK_IMPORTED_MODULE_2__[\"colors\"].convertToWebGLcolorArray(mcColor.fillColor);\n    this.strokeColorArray = _Draw_Color__WEBPACK_IMPORTED_MODULE_2__[\"colors\"].convertToWebGLcolorArray(mcColor.strokeColor);\n\n    this.label = rowName ;\n    this.dataY = columnName + \" -- \" + dataY;\n    this.staticTipControl = new _Sub_Tip_Sub_StaticControl_StaticTipControl__WEBPACK_IMPORTED_MODULE_3__[\"StaticTipControl\"](htmlContainer, staticTipControlTopShift, isStaticTipControlSingleLine);\n    this.staticTipControl.createTip();\n}\n\nCuboidModel.prototype.calculateModelMatrix = function(angleY) {\n    // calculate the model's model matrix and save it.\n    _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].rotate(this.modelMatrix, this.identityMatrix, angleY, [0,1,0]/*auto rotate around Y axis*/);\n    _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].translate(this.modelMatrix, this.modelMatrix, this.translate);\n    _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].scale(this.modelMatrix, this.modelMatrix, this.scale);\n};\n\nlet numOfFocus = 0;\nfunction isAnythingFocused(){\n    return numOfFocus !== 0;\n}\n\nCuboidModel.prototype.toggleFocus = function(){\n    if(this.isFocus){\n        this.cancelFocus();\n    } else {\n        this.setFocus();\n    }\n    return this.isFocus;\n};\n\nCuboidModel.prototype.setFocus = function(){\n    numOfFocus++;\n    this.isFocus = true;\n};\n\nCuboidModel.prototype.cancelFocus = function(){\n    numOfFocus--;\n    this.isFocus = false;\n};\n\nfunction PlaneModel(translate,  scale, isReverse/*to tell whether I should display the text up side down.*/){\n    this.translate = translate;\n    this.modelMatrix = _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create();\n    this.MVMatrix = _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create();\n    this.MVPMatrix = _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create();\n    this.identityMatrix = _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].create();\n    this.scale = scale;\n    this.texture = null;\n}\n\nPlaneModel.prototype.connectWithTexture = function(imageData, gl){\n    this.texture = _webgl_util__WEBPACK_IMPORTED_MODULE_1__[\"webglUtil\"].prepareLabelTexture(imageData, gl);\n};\n\nPlaneModel.prototype.calculateModelMatrix = function(angleY){\n    // calculate the model's model matrix and save it.\n    _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].rotate(this.modelMatrix, this.identityMatrix, angleY, [0,1,0]/*auto rotate around Y axis*/);\n    _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].translate(this.modelMatrix, this.modelMatrix, this.translate);\n    _gl_matrix__WEBPACK_IMPORTED_MODULE_0__[\"mat4\"].scale(this.modelMatrix, this.modelMatrix, this.scale);\n};\n\nconst threeModels = {\n    CuboidModel,\n    isAnythingFocused,\n    PlaneModel\n};\n\n\n\n\n//# sourceURL=webpack:///./src/DataViewer/3D/three-model.js?");

/***/ }),

/***/ "./src/DataViewer/3D/webgl-main.js":
/*!*****************************************!*\
  !*** ./src/DataViewer/3D/webgl-main.js ***!
  \*****************************************/
/*! exports provided: threeDgridWebgl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"threeDgridWebgl\", function() { return threeDgridWebgl; });\n/* harmony import */ var _webgl_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webgl-util */ \"./src/DataViewer/3D/webgl-util.js\");\n/* harmony import */ var _three_model__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./three-model */ \"./src/DataViewer/3D/three-model.js\");\n/* harmony import */ var _gl_matrix__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gl-matrix */ \"./src/DataViewer/3D/gl-matrix.js\");\n/* harmony import */ var _webgl_parse_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./webgl-parse-data */ \"./src/DataViewer/3D/webgl-parse-data.js\");\n/* harmony import */ var _Sub_Tip_TipControl__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Sub/Tip/TipControl */ \"./src/DataViewer/Sub/Tip/TipControl.js\");\n\n\n\n\n\n\nconst threeDgridWebgl = {\n    draw: function(input, canvas, offScreenCanvas, canvasTrigger, tipContainer){\n        //glContext and program that are used everywhere.\n        let gl;\n        let normalProgram;\n        let simpleProgram;\n        let labelProgram;\n        let frameBuffer;\n\n        //variable and statics used for calculating rotation.\n\n        let angleYStart = 0;\n        let angleY = input.startAngle; //for demonstration purpose\n\n        //all kinds of matrices.\n        let projectionMatrix = _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"mat4\"].create();\n        let viewMatrix = _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"mat4\"].create();\n        let VPMatrix = _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"mat4\"].create(); //this is static\n\n        //the universal vertices/indices buffers that all objects in this application use\n        let buffers;\n\n        //holds the cuboids to be drawn.\n        let cuboidList = [];\n        //holds the planes to be drawn.\n        let planeList = [];\n\n        //flags to controls\n        let isStopAnimation = false;\n\n        //for mouse interaction.\n        let mouseStartX = 0;\n        let mouseStartY = 0; //I will need this for vertical angle adjust and therefore I will keep it for now.\n        let mouseX = 0;\n        let mouseY = 0;\n        let maxAngelPerDrag = Math.PI / 2;\n\n        //tip\n        let tipControl = new _Sub_Tip_TipControl__WEBPACK_IMPORTED_MODULE_4__[\"TipControl\"](tipContainer, 7, false);\n        tipControl.createTip();\n\n        //convert input to the old day format the webgl main uses.\n        input.meta = {};\n        input.meta.rows = input.series.rows;\n        input.meta.columns = input.series.columns;\n        input.data = input.series.data;\n\n//          how data looks like after conversion\n//            input = {\n//                meta : {\n//                    \"rows\" : [ \"Apple\", \"Orange\", \"Plum\", \"Pineapple\"],\n//                    \"columns\" : [ \"Several times per day\", \"Once per day\", \"Several times per week\" ]\n//                },\n//\n//                data : [ [ 101, 122, 143 ], [ 111, 122, 143 ], [ 91, 112, 153 ], [ 34, 78, 26 ] ]\n//            };\n\n        init(input);\n\n        function init(input) {\n            gl = _webgl_util__WEBPACK_IMPORTED_MODULE_0__[\"webglUtil\"].createGLContext(canvas);\n            //create program for normal rendering.\n            normalProgram = _webgl_util__WEBPACK_IMPORTED_MODULE_0__[\"webglUtil\"].createProgram(\"shader-vertex\", \"shader-fragment\", gl);\n            simpleProgram = _webgl_util__WEBPACK_IMPORTED_MODULE_0__[\"webglUtil\"].createProgram(\"shader-simple-vertex\", \"shader-simple-fragment\", gl);\n            labelProgram = _webgl_util__WEBPACK_IMPORTED_MODULE_0__[\"webglUtil\"].createProgram(\"shader-label-vertex\", \"shader-label-fragment\", gl);\n            frameBuffer = _webgl_util__WEBPACK_IMPORTED_MODULE_0__[\"webglUtil\"].createFrameBufferObject(gl);\n\n            console.log(\"program successfully created\");\n\n            gl.enable(gl.DEPTH_TEST);\n\n            cuboidList = Object(_webgl_parse_data__WEBPACK_IMPORTED_MODULE_3__[\"convertToCuboidModels\"])(input, tipContainer, 7, false, input.series.focus);\n            planeList = Object(_webgl_parse_data__WEBPACK_IMPORTED_MODULE_3__[\"createLabelPlanes\"])(input, gl, offScreenCanvas);\n\n\n            buffers = _webgl_util__WEBPACK_IMPORTED_MODULE_0__[\"webglUtil\"].prepareModelBuffers(gl);\n\n            console.log(\"model data buffers successfully created.\");\n\n            prepareStaticSettingsForNormalProgram();\n            prepareStaticSettingsForWireFrameProgram();\n            prepareStaticSettingsForLabelProgram();\n            console.log(\"webgl stuffs ready\");\n\n            enableMouseInteraction(canvasTrigger);\n\n            drawStatic();\n            showAllStaticTip();\n        }\n\n        function prepareStaticSettingsForNormalProgram(){\n            gl.useProgram(normalProgram);\n\n            //feed the buffers to the shaders\n            let aPositionIdx = gl.getAttribLocation(normalProgram, \"MCVertex\");\n            normalProgram.aPositionIdx = aPositionIdx;\n\n            let aNormalIdx = gl.getAttribLocation(normalProgram, \"MCNormal\");\n            normalProgram.aNormalIdx = aNormalIdx;\n\n            //get the matrix indices in the shaders.\n            normalProgram.uMVPMatrixIdx = gl.getUniformLocation(normalProgram, \"MVPMatrix\");\n            normalProgram.uNormalMatrixIdx = gl.getUniformLocation(normalProgram, \"NormalMatrix\");\n            normalProgram.uMVMatrixIdx = gl.getUniformLocation(normalProgram, \"MVMatrix\");\n\n            //projection matrix, view matrix, and VP matrix.\n            _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"mat4\"].perspective(projectionMatrix, Math.PI * 0.2, gl.viewportWidth / gl.viewportHeight, 1, 2000.0);\n            _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"mat4\"].lookAt(viewMatrix, _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"vec3\"].fromValues(5, 40, 40), _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"vec3\"].fromValues(0,4,0), _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"vec3\"].fromValues(0,1,0));\n            _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"mat4\"].multiply(VPMatrix, projectionMatrix, viewMatrix);\n\n            //directional light. I only include directional light here for the sake of simplicity. TODO: adjust the light position\n            let ecDirectionalLightOneIdx = gl.getUniformLocation(normalProgram, \"ecDirectionalLightPositionOne\");\n            let wcDirectionalLightPositionOne = _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"vec3\"].fromValues(-100, 100, 100);\n            let ecDirectionalLightPositionOne = _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"vec3\"].create();\n            _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"vec3\"].transformMat4(ecDirectionalLightPositionOne, wcDirectionalLightPositionOne, viewMatrix);\n            gl.uniform3fv(ecDirectionalLightOneIdx, ecDirectionalLightPositionOne);\n\n            let ecDirectionalLightTwoIdx = gl.getUniformLocation(normalProgram, \"ecDirectionalLightPositionTwo\");\n            let wcDirectionalLightPositionTwo = _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"vec3\"].fromValues(100, -100, 0);\n            let ecDirectionalLightPositionTwo = _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"vec3\"].create();\n            _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"vec3\"].transformMat4(ecDirectionalLightPositionTwo, wcDirectionalLightPositionTwo, viewMatrix);\n            gl.uniform3fv(ecDirectionalLightTwoIdx, ecDirectionalLightPositionTwo);\n\n            //material color\n            normalProgram.uMaterialColorIdx = gl.getUniformLocation(normalProgram, \"materialColor\");\n            //translucent control\n            normalProgram.uIsTranslucentIdx = gl.getUniformLocation(normalProgram, \"IsTranslucent\");\n\n            //for this order independent blending to work, clear color has to be \"white\".\n            gl.clearColor(1.0, 1.0, 1.0, 1.0);\n        }\n\n        function prepareStaticSettingsForWireFrameProgram(){\n            gl.useProgram(simpleProgram);\n            //feed the buffers to the shaders\n            simpleProgram.aPositionIdx = gl.getAttribLocation(simpleProgram, \"MCVertex\");\n            simpleProgram.uMVPMatrixIdx = gl.getUniformLocation(simpleProgram, \"MVPMatrix\");\n            simpleProgram.uMaterialColorIdx = gl.getUniformLocation(simpleProgram, \"materialColor\");\n        }\n\n        function prepareStaticSettingsForLabelProgram(){\n            gl.useProgram(labelProgram);\n            labelProgram.aPositionIdx = gl.getAttribLocation(labelProgram, \"MCVertex\");\n            labelProgram.aTexCoordIdx = gl.getAttribLocation(labelProgram, \"aTexCoord\");\n\n            labelProgram.uMVPMatrixIdx = gl.getUniformLocation(labelProgram, \"MVPMatrix\");\n            labelProgram.uSamplerIdx = gl.getUniformLocation(labelProgram, \"uSampler\");\n        }\n\n        function animate(){\n            if(!isStopAnimation){\n                angleY = angleYStart + (((mouseX - mouseStartX) / 600) * maxAngelPerDrag);\n                drawAll();\n                requestAnimationFrame(animate);\n            }\n        }\n\n        function startAnimation(){\n            //angleX means rotate around x axis\n            isStopAnimation = false;\n            angleYStart = angleY;\n            animate();\n        }\n\n        function stopAnimation(){\n            isStopAnimation = true;\n        }\n\n        function drawStatic(){\n            drawAll();\n        }\n\n        function drawAll() {\n            //draw all the objects\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            drawAllLabels();\n            drawAllCuboids();\n            drawAllOutlines();\n        }\n\n        function drawAllCuboids(){\n            gl.useProgram(normalProgram);\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.verticesBuffer);\n            gl.vertexAttribPointer(normalProgram.aPositionIdx, 3, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(normalProgram.aPositionIdx);\n            gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.normalsBuffer);\n            gl.vertexAttribPointer(normalProgram.aNormalIdx, 3, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(normalProgram.aNormalIdx);\n            gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indicesBuffer);\n\n            drawAllNoneTransparentCuboids();\n            drawAllSemiTransparentCuboids();\n        }\n\n        function drawAllNoneTransparentCuboids(){\n            gl.uniform1i(normalProgram.uIsTranslucentIdx, 0);\n\n            if(_three_model__WEBPACK_IMPORTED_MODULE_1__[\"threeModels\"].isAnythingFocused()){\n                for(let modelIdx in cuboidList) {\n                    if(cuboidList[modelIdx].isFocus){\n                        drawSingleCuboid(cuboidList[modelIdx], false);\n                    }\n                }\n            } else {\n                for(let modelIdx in cuboidList) {\n                    drawSingleCuboid(cuboidList[modelIdx], false);\n                }\n            }\n        }\n\n        function drawAllSemiTransparentCuboids(){\n            if(_three_model__WEBPACK_IMPORTED_MODULE_1__[\"threeModels\"].isAnythingFocused()){\n                gl.depthMask(false);\n                gl.enable(gl.BLEND);\n                gl.blendEquation(gl.FUNC_ADD);\n                gl.blendFunc(gl.ZERO, gl.SRC_COLOR);\n                gl.uniform1i(normalProgram.uIsTranslucentIdx, 1);\n\n                for(let modelIdx in cuboidList) {\n                    drawSingleCuboid(cuboidList[modelIdx], true);\n                }\n\n                gl.depthMask(true);\n                gl.disable(gl.BLEND);\n            }\n        }\n\n        function drawAllOutlines(){\n            gl.useProgram(simpleProgram);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.wireFrameVerticesBuffer);\n            gl.vertexAttribPointer(simpleProgram.aPositionIdx, 3, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(simpleProgram.aPositionIdx);\n            gl.bindBuffer(gl.ARRAY_BUFFER, null);\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.cubeWireFrameIndicesBuffer);\n\n            for(let modelIdx in cuboidList) {\n                drawSingleOutline(cuboidList[modelIdx]);\n            }\n        }\n\n        function drawAllLabels(){\n            gl.useProgram(labelProgram);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.planeVerticesBuffer);\n            gl.vertexAttribPointer(labelProgram.aPositionIdx, 3, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(labelProgram.aPositionIdx);\n\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.planeTextureCoordinatesBuffer);\n            gl.vertexAttribPointer(labelProgram.aTexCoordIdx, 2, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(labelProgram.aTexCoordIdx);\n\n            gl.activeTexture(gl.TEXTURE0);\n            //bind texture happens later in draw single plane.\n            gl.uniform1i(labelProgram.uSamplerIdx, 0);   // Pass the texture unit to u_Sampler\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.planeIndicesBuffer);\n\n            for(let modelIdx in planeList){\n                drawSinglePlane(planeList[modelIdx]);\n            }\n        }\n\n\n        function drawSingleCuboid(model, isSemiTransparent) {\n            //upload MVP matrix\n            model.calculateModelMatrix(angleY);\n            _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"mat4\"].multiply(model.MVPMatrix, VPMatrix, model.modelMatrix);\n            gl.uniformMatrix4fv(normalProgram.uMVPMatrixIdx, false, model.MVPMatrix);\n\n            //upload normal transform matrix\n            _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"mat4\"].multiply(model.MVMatrix, viewMatrix, model.modelMatrix);\n            _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"mat3\"].normalFromMat4(model.normalMatrix, model.MVMatrix);\n            gl.uniformMatrix4fv(normalProgram.uMVMatrixIdx, false,  model.MVMatrix);\n            gl.uniformMatrix3fv(normalProgram.uNormalMatrixIdx, false, model.normalMatrix);\n\n            //upload the object color\n            if(!isSemiTransparent){\n                //console.log(\"draw focused\");\n                let fillColorArray = model.fillColorArray;\n                let fillColor = _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"vec3\"].fromValues(fillColorArray[0], fillColorArray[1], fillColorArray[2]);\n                gl.uniform3fv(normalProgram.uMaterialColorIdx, fillColor);\n            }  else {\n                let fillColor = _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"vec3\"].fromValues(1.0, 1.0, 1.0);\n                gl.uniform3fv(normalProgram.uMaterialColorIdx, fillColor);\n            }\n\n            //draw the cube.\n            gl.drawElements(gl.TRIANGLES, buffers.indicesBuffer.numOfIndices, gl.UNSIGNED_BYTE, 0);\n        }\n\n        function drawSingleOutline(model){\n            //now lets start to draw the wire frame.\n            //make use of the mvp matrix that has been calculated.\n            let strokeColor;\n            if(!model.isFocus && _three_model__WEBPACK_IMPORTED_MODULE_1__[\"threeModels\"].isAnythingFocused()){\n                strokeColor = _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"vec3\"].fromValues(0.6, 0.6, 0.6);\n            } else {\n                strokeColor = _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"vec3\"].fromValues(0.8, 0.8, 0.8);\n            }\n            gl.uniformMatrix4fv(simpleProgram.uMVPMatrixIdx, false, model.MVPMatrix);\n            gl.uniform3fv(simpleProgram.uMaterialColorIdx, strokeColor);\n\n            gl.drawElements(gl.LINES, buffers.cubeWireFrameIndicesBuffer.numOfIndices, gl.UNSIGNED_BYTE, 0);\n        }\n\n        function drawSinglePlane(model){\n            model.calculateModelMatrix(angleY);\n\n            _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"mat4\"].multiply(model.MVPMatrix, VPMatrix, model.modelMatrix);\n            gl.uniformMatrix4fv(labelProgram.uMVPMatrixIdx, false, model.MVPMatrix);\n\n\n            gl.bindTexture(gl.TEXTURE_2D, model.texture);\n\n            gl.drawElements(gl.TRIANGLES, buffers.planeIndicesBuffer.numOfIndices, gl.UNSIGNED_BYTE, 0);\n        }\n\n        function pickObject(canvasX, canvasY){\n            gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n            gl.useProgram(simpleProgram);//wire frame program seems to perfectly fit in.\n            //feed the program with vertices.\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffers.verticesBuffer);\n            gl.vertexAttribPointer(simpleProgram.aPositionIdx, 3, gl.FLOAT, false, 0, 0);\n            gl.enableVertexAttribArray(simpleProgram.aPositionIdx);\n\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indicesBuffer);\n\n            let selectedModelIdx = -1;\n            for (let modelIdx in cuboidList) {\n                if(testSingleObject(modelIdx, canvasX, gl.viewportHeight-canvasY/*uv origin is left bottom*/)){\n                    selectedModelIdx = modelIdx;\n                    break;\n                }\n            }\n\n            gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n            return selectedModelIdx;\n        }\n\n        /**\n         * texture here use uv coordinates system and the origin of this coordinates system is left bottom.\n         * @param idxOfModelToBeTested\n         * @param u\n         * @param v\n         * @returns {boolean}\n         */\n        function testSingleObject(idxOfModelToBeTested, u, v){\n            //frame buffer does not automatically clear itself, do it manually.\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n            let pixels = new Uint8Array(4); // Array for storing the pixel value\n\n            //draw the target object as red object and everything else black.\n            for(let modelIdx in cuboidList){\n                let model = cuboidList[modelIdx];\n                //directly use the current MVPmatrix\n                gl.uniformMatrix4fv(simpleProgram.uMVPMatrixIdx, false, model.MVPMatrix);\n\n                if(modelIdx === idxOfModelToBeTested){\n                    let testColor = _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"vec3\"].fromValues(1.0, 0.0, 0.0); //red.\n                    gl.uniform3fv(simpleProgram.uMaterialColorIdx, testColor);\n                } else {\n                    let testColor = _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"vec3\"].fromValues(0.0, 0.0, 0.0); //black.\n                    gl.uniform3fv(simpleProgram.uMaterialColorIdx, testColor);\n                }\n\n                gl.drawElements(gl.TRIANGLES, buffers.indicesBuffer.numOfIndices, gl.UNSIGNED_BYTE, 0);\n            }\n\n            gl.readPixels(u, v, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixels);\n            //check if red\n            if(pixels[0] === 255 && pixels[1] === 0 && pixels[2] === 0){\n                return true;\n            }\n        }\n\n        function showTip(MVPMatrix, mcColor, viewPortWidth, viewPortHeight, label, dataY, tipControl){\n            let tipPosition = _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"vec4\"].fromValues(0, 1, 0, 1);\n            _gl_matrix__WEBPACK_IMPORTED_MODULE_2__[\"vec4\"].transformMat4(tipPosition, tipPosition, MVPMatrix);\n            //do perspective division and get normalized device coordinates.\n            //the depth value (third) is discarded since I don't need it here.\n            let ndc = [tipPosition[0]/tipPosition[3], tipPosition[1]/tipPosition[3]];\n            //convert ndc to dom position.\n            let domX = ndc[0] * (viewPortWidth / 2) + viewPortWidth / 2;\n            let domY = viewPortHeight / 2 -  ndc[1] *  (viewPortHeight / 2);\n\n            tipControl.genericShowDoubleLineTipDataYOnly(domX, domY, label, mcColor, dataY);\n        }\n\n        function showAllStaticTip(){\n            for(let i = 0; i < cuboidList.length; i ++){\n                let model = cuboidList[i];\n                if(model.isFocus){\n                    showTip(model.MVPMatrix, model.mcColor,  gl.viewportWidth, gl.viewportHeight, model.label, model.dataY, model.staticTipControl);\n                }\n            }\n\n        }\n\n        function enableMouseInteraction(trigger){\n\n            let dragging = false;\n\n            function getSelectedCuboidIdx(){\n                let bb = canvas.getBoundingClientRect();\n                let canvasX = mouseX - bb.left;\n                let canvasY = mouseY - bb.top;\n\n                return pickObject(canvasX, canvasY);\n            }\n\n            function enableMouseTracking(trigger){\n                trigger.addEventListener(\"mousemove\", function(event){\n                    mouseX = event.clientX;\n                    mouseY = event.clientY;\n                });\n            }\n\n            function enableMouseOverTip(trigger){\n                let showTipTimerIdx = -1;\n                let lastModelIdx = -1;\n                trigger.addEventListener(\"mouseover\", function(event){\n                    showTipTimerIdx = window.setInterval(function(){\n                        if(dragging){\n                            //if still dragging, do nothing.\n                            return;\n                        }\n\n                        let selectedModelIdx = getSelectedCuboidIdx();\n                        if(selectedModelIdx !== -1 && cuboidList[selectedModelIdx].isFocus){\n                            //如果对象已经被设置focus了，那么就当没选中任何东西\n                            selectedModelIdx = -1;\n                        }\n\n                        if(lastModelIdx !== -1 && selectedModelIdx === -1){\n                            tipControl.hideTip();\n                            lastModelIdx = selectedModelIdx;\n                        } else if(lastModelIdx !== selectedModelIdx){\n                            let model = cuboidList[selectedModelIdx];\n                            showTip(model.MVPMatrix, model.mcColor,  gl.viewportWidth, gl.viewportHeight, model.label, model.dataY, tipControl);\n                            lastModelIdx = selectedModelIdx;\n                        }\n\n                    }, 1000);\n                });\n\n                trigger.addEventListener(\"mouseout\", function(){\n                    tipControl.hideTip();\n                    window.clearInterval(showTipTimerIdx);\n                });\n            }\n\n            /**\n             * this function only works when 'enableMouseTracking' is called first\n             * @param canvas\n             */\n            function enableModelDragging(trigger){\n                trigger.addEventListener(\"mousedown\", function(event){\n                    dragging = true;\n                    tipControl.hideTipImmediately();\n\n                    mouseStartX = event.clientX;\n                    mouseStartY = event.clientY;\n                    startAnimation();\n                });\n\n                window.addEventListener(\"mouseup\", function(){\n                    if(Math.abs(mouseX - mouseStartX) > 3 || Math.abs(mouseY - mouseStartY) > 3){\n                        //in this case the user has dragged the chart.\n                        dragging = false;\n                        stopAnimation();\n\n                        //since when mousedown I have hide all the tips. now its time to show them up again.\n                        showAllStaticTip();\n                    } else {\n                        //the user merely clicks on a cuboid but didn't drag the chart, that means the user wants to focus on the cuboid.\n                        //in this case the user has dragged the chart.\n                        dragging = false; //this is turned on anyway when mousedown, so turn it off first.\n                        stopAnimation();\n\n                        let selectedModelIdx = getSelectedCuboidIdx();\n                        if(selectedModelIdx !== -1){\n                            let model = cuboidList[selectedModelIdx];\n                            if(model.toggleFocus()){\n                                showTip(model.MVPMatrix, model.mcColor,  gl.viewportWidth, gl.viewportHeight, model.label, model.dataY, model.staticTipControl);\n                            } else {\n                                model.staticTipControl.hideTip();\n                            }\n                            drawStatic();\n                        }\n\n                    }\n                });\n            }\n\n            enableMouseTracking(trigger);\n            enableMouseOverTip(trigger);\n            enableModelDragging(trigger);\n        }\n    }\n};\n\n\n\n\n\n\n//# sourceURL=webpack:///./src/DataViewer/3D/webgl-main.js?");

/***/ }),

/***/ "./src/DataViewer/3D/webgl-parse-data.js":
/*!***********************************************!*\
  !*** ./src/DataViewer/3D/webgl-parse-data.js ***!
  \***********************************************/
/*! exports provided: convertToCuboidModels, createLabelPlanes, getMinMax */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"convertToCuboidModels\", function() { return convertToCuboidModels; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createLabelPlanes\", function() { return createLabelPlanes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getMinMax\", function() { return getMinMax; });\n/* harmony import */ var _three_model__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./three-model */ \"./src/DataViewer/3D/three-model.js\");\n/* harmony import */ var _Util_RandomPicker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Util/RandomPicker */ \"./src/Util/RandomPicker.js\");\n/* harmony import */ var _canvas_label_generator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./canvas-label-generator */ \"./src/DataViewer/3D/canvas-label-generator.js\");\n\n\n\n\nfunction convertToCuboidModels(input/*an array of array*/, htmlContainer, staticTipControlTopShift, isStaticTipControlSingleLine, focusList){\n    let cuboidList = [];\n\n    let CUBOID_X_INTERVAL = 4; //间距\n    let CUBOID_Z_INTERVAL = 8;\n\n    let data = input.data;\n    let meta = input.meta;\n    let CuboidModel = _three_model__WEBPACK_IMPORTED_MODULE_0__[\"threeModels\"].CuboidModel;\n\n\tlet numOfRows = data.length;\n\tlet numOfColumns = data[0].length;\n    let minMax = getMinMax(data);\n\tlet biggestInData = minMax.biggestInData;\n    let smallestInData = minMax.smallestInData;\n    let greatestDataRange = biggestInData - smallestInData;\n    let random = new _Util_RandomPicker__WEBPACK_IMPORTED_MODULE_1__[\"RandomPicker\"]();\n    let rowIdx, colIdx;\n    for(rowIdx = 0; rowIdx < numOfRows; rowIdx++){\n        let mcColor = random.pickSeriesColor();\n\n        for(let colIdx = 0; colIdx < numOfColumns; colIdx++){\n\n\t\t\tlet translateX = (CUBOID_X_INTERVAL * rowIdx) - ((numOfRows - 1) * CUBOID_X_INTERVAL) / 2;\n\t\t\tlet translateZ = (CUBOID_Z_INTERVAL * colIdx) - ((numOfColumns - 1) * CUBOID_Z_INTERVAL) / 2;\n\t\t\t\n\t\t\tlet scaleFactor = ((data[rowIdx][colIdx] - smallestInData) / greatestDataRange) * 8;\n\t\t\tif(scaleFactor < 0.05){\n\t\t\t\tscaleFactor = 0.05; //in case it is so small that we end up with z fighting.\n\t\t\t}\n\t\t\tlet translateY = scaleFactor;\n\t\t\tlet translate = [translateX, translateY, translateZ];\n\t\t\t\n\t\t\tlet scale = [1, scaleFactor, 1];\n\n            let cuboid = new CuboidModel(translate, scale, mcColor, data[rowIdx][colIdx], meta.rows[rowIdx], meta.columns[colIdx], htmlContainer, staticTipControlTopShift, isStaticTipControlSingleLine);\n            cuboidList.push(cuboid);\n\n\t\t}\n\t}\n\n    //now set the focus\n    if(focusList){\n        for(let fi = 0; fi < focusList.length; fi++){\n            rowIdx = focusList[fi][0];\n            colIdx = focusList[fi][1];\n            cuboidList[rowIdx * numOfColumns + colIdx].setFocus();\n        }\n    }\n\n\n    return cuboidList;\n}\n\nfunction createLabelPlanes(input, gl, offScreenCanvas){\n    let planeList = [];\n\n    let columns = input.meta.columns;\n    let numOfRows = input.meta.rows.length;\n    let CUBOID_X_INTERVAL = 4;\n    let CUBOID_Z_INTERVAL = 8;\n    let labelGenerator = _canvas_label_generator__WEBPACK_IMPORTED_MODULE_2__[\"canvasLabelGenerator\"].create(offScreenCanvas);\n\n    let PlaneModel = _three_model__WEBPACK_IMPORTED_MODULE_0__[\"threeModels\"].PlaneModel;\n\n\n\n    //create one label plane for each column\n    for(let i = 0; i < columns.length; i++) {\n        let text = columns[i];\n        let labelImageInfo = labelGenerator.generateLabelImageDataBasedOnText(text);\n\n\n        //每一个label的长度都是不确定的，随着字数的变化而变化，但是它们的宽度必然是确定的，也就是2，2也是我所用的长方体的底面任何一边的长度。\n        //label的长度对应的字的长度，而label的宽度对应字的高度。字的高度是固定的，20px，同理label的宽度也是固定的，2个世界坐标系里的长度，由此可以推断出这里px到世界坐标的转换比例\n        let labelLength = labelImageInfo.textWidth * (2/labelImageInfo.textHeight);\n        let scale = [labelLength/2, 1, 1];\n\n        let translateX = (((numOfRows-1) * CUBOID_X_INTERVAL) + 2) / 2 + labelLength/2;\n        let translateZ = (CUBOID_Z_INTERVAL * i) - ((columns.length - 1) * CUBOID_Z_INTERVAL) / 2;\n        let translate = [translateX, 0, translateZ];\n\n        let labelPlane = new PlaneModel(translate, scale, false);\n        labelPlane.connectWithTexture(labelImageInfo.imageData, gl);\n        planeList.push(labelPlane);\n    }\n\n    return planeList;\n}\n\n//enumerate all answer data and find the biggest number..\nfunction getMinMax(answerData){\n\tlet biggestInData = answerData[0][0];\n    let smallestInData = answerData[0][0];\n\t\n\tfor(let i in answerData){\n\t\tlet row = answerData[i];\n\t\tlet biggestInRow = Math.max.apply(Math, row);\n        let smallestInRow = Math.min.apply(Math, row);\n\t\t\n\t\tif (biggestInRow > biggestInData) {\n\t\t\tbiggestInData = biggestInRow;\n\t\t}\n\n        if(smallestInRow < smallestInData){\n            smallestInData = smallestInRow;\n        }\n\t}\n\n    if(smallestInData > 0){\n        smallestInData = 0;\n    }\n\treturn {\n        biggestInData,\n        smallestInData\n    };\n}\n\n\n//# sourceURL=webpack:///./src/DataViewer/3D/webgl-parse-data.js?");

/***/ }),

/***/ "./src/DataViewer/3D/webgl-util.js":
/*!*****************************************!*\
  !*** ./src/DataViewer/3D/webgl-util.js ***!
  \*****************************************/
/*! exports provided: webglUtil */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"webglUtil\", function() { return webglUtil; });\nconst webglUtil = {\n    createGLContext: function(canvas){\n        let gl = canvas.getContext(\"webgl\");\n        gl.viewportWidth = canvas.width;\n        gl.viewportHeight = canvas.height;\n        return gl;\n    },\n\n    createProgram: function(vertexShaderId, fragmentShaderId, gl){\n        let program = gl.createProgram();\n        let shaders = this.loadShadersFromHTML(vertexShaderId, fragmentShaderId, gl);\n        gl.attachShader(program, shaders.vertexShader);\n        gl.attachShader(program, shaders.fragmentShader);\n        gl.linkProgram(program);\n        return program;\n    },\n\n    loadShadersFromHTML: function(vertexShaderId, fragmentShaderId, gl){\n        let vertexShaderSource = document.getElementById(vertexShaderId).innerHTML.trim();\n        let fragmentShaderSource = document.getElementById(fragmentShaderId).innerHTML.trim();\n\n        let vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(vertexShader, vertexShaderSource);\n        gl.compileShader(vertexShader);\n\n        let fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(fragmentShader, fragmentShaderSource);\n        gl.compileShader(fragmentShader);\n\n        let compiled = gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS);\n        if (!compiled) {\n            console.log(\"Failed to compile vertex shader\");\n        }\n\n        compiled = gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS);\n        if (!compiled) {\n            console.log(\"Failed to compile fragment shader\");\n        }\n\n        return {\n            vertexShader: vertexShader,\n            fragmentShader: fragmentShader\n        };\n    },\n\n    prepareElementBuffer: function(modelIndices, gl){\n        let buffer = gl.createBuffer();\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, modelIndices, gl.STATIC_DRAW);\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);\n        buffer.numOfIndices = modelIndices.length;\n        return buffer;\n    },\n\n    prepareArrayBuffer: function(data, gl){\n        // Create a buffer object\n        let buffer = gl.createBuffer();\n        // Write date into the buffer object\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n        gl.bindBuffer(gl.ARRAY_BUFFER, null);\n        return buffer;\n    },\n\n    prepareLabelTexture: function(imageData, gl) {\n        let texture = gl.createTexture();\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);\n\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE,\n            imageData);\n\n        //following settings are necessary cos Im using a NPOT texture.\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Prevents s-coordinate wrapping (repeating).\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); //Prevents t-coordinate wrapping (repeating).\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        return texture;\n    },\n\n    prepareModelBuffers: function(gl){\n        let cubeVertices = new Float32Array([\n            1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0,\n            1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0,\n            1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0,\n            -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0,\n            -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0,\n            1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0 ]);\n\n        let cubeNormals = new Float32Array([\n            0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0,\n            1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,\n            -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0,\n            0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0,\n            0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0 ]);\n\n        let cubeIndices = new Uint8Array([\n            0, 1, 2, 0, 2, 3,\n            4, 5, 6, 4, 6, 7,\n            8, 9, 10, 8, 10, 11,\n            12, 13, 14, 12, 14, 15,\n            16, 17, 18, 16, 18, 19,\n            20, 21, 22, 20, 22, 23 ]);\n\n\n        // Create a wire frame\n        //    v6----- v5\n        //   /|      /|\n        //  v1------v0|\n        //  | |     | |\n        //  | |v7---|-|v4\n        //  |/      |/\n        //  v2------v3\n        let cubeWireFrameVertices = new Float32Array([\n            1.001,  1.001,  1.001, // v0\n            -1.001,  1.001,  1.001,// v1\n            -1.001, -1.001,  1.001,// v2\n            1.001, -1.001,  1.001, // v3\n            1.001, -1.001, -1.001, // v4\n            1.001,  1.001, -1.001, // v5\n            -1.001,  1.001, -1.001,// v6\n            -1.001, -1.001, -1.001// v7\n        ]);\n\n        let cubeWireFrameIndices = new Uint8Array([\n            0, 1, 1, 6, 6, 5, 5, 0, //top wire frame lines\n            1, 2, 6, 7, 5, 4, 0, 3, //four vertical wire frame lines\n            3, 2, 2, 7, 7, 4, 4, 3 //bottom wire frame lines.\n        ]);\n\n        //  plane indices and text coordinates. The vertices for each plane is different.\n        //    v4------v3\n        //   /        /\n        //  v1------v2\n\n        let planeVertices = new Float32Array([\n            -1.0, 0.0, 1.0, //v1\n            1.0, 0.0, 1.0, //v2\n            1.0, 0.0, -1.0, //v3\n            -1.0, 0.0, -1.0 //v4\n        ]);\n\n        //counter clock wise\n        let planeIndices = new Uint8Array([\n            0, 1, 2,\n            2, 3, 0\n        ]);\n\n        let planeTextureCoordinates = new Float32Array([\n            0.0, 0.0, //for v1\n            1.0, 0.1, //for v2\n            1.0, 1.0, //for v3\n            0.0, 1.0 //for v4\n        ]);\n\n\n        let verticesBuffer = this.prepareArrayBuffer(cubeVertices, gl);\n        let normalsBuffer = this.prepareArrayBuffer(cubeNormals, gl);\n        let indicesBuffer = this.prepareElementBuffer(cubeIndices, gl);\n        let wireFrameVerticesBuffer = this.prepareArrayBuffer(cubeWireFrameVertices, gl);\n        let cubeWireFrameIndicesBuffer = this.prepareElementBuffer(cubeWireFrameIndices, gl);\n        let planeVerticesBuffer = this.prepareArrayBuffer(planeVertices, gl);\n        let planeIndecesBuffer = this.prepareElementBuffer(planeIndices, gl);\n        let planeTextureCoordinatesBuffer = this.prepareArrayBuffer(planeTextureCoordinates, gl);\n\n        return {\n            verticesBuffer: verticesBuffer,\n            normalsBuffer: normalsBuffer,\n            indicesBuffer: indicesBuffer,\n            wireFrameVerticesBuffer: wireFrameVerticesBuffer,\n            cubeWireFrameIndicesBuffer: cubeWireFrameIndicesBuffer,\n            planeVerticesBuffer: planeVerticesBuffer,\n            planeIndicesBuffer: planeIndecesBuffer,\n            planeTextureCoordinatesBuffer: planeTextureCoordinatesBuffer\n        };\n    },\n\n    createFrameBufferObject: function(gl) {\n        let frameBuffer = gl.createFramebuffer();\n\n        //create and configure texture.\n        let texture = gl.createTexture();\n        //gl.activeTexture(gl.TEXTURE0);\n        gl.bindTexture(gl.TEXTURE_2D, texture);\n        //it seems that this texture needs to be a square. Thats why width here equals to height.\n        //Also the webgl can draw everything in it no matter what size you choose (it can scale, even though your on screen width/height radio is not the same).\n        //I choose 512 * 512 hoping that it can provide enough accuracy. If too small, image get low resolution, and you cannot get accurate information by reading pixel from that texture.\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.viewportWidth, gl.viewportHeight, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n\n        //allows for NPOT texture.\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST); //gl.NEAREST is also allowed, instead of gl.LINEAR, as neither mipmap.\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); //Prevents s-coordinate wrapping (repeating).\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE); //Prevents t-coordinate wrapping (repeating).\n        \n        //create and configure render buffer\n        let depthBuffer = gl.createRenderbuffer();\n        gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);\n        gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, gl.viewportWidth, gl.viewportHeight);\n\n        // Attach the texture and the renderbuffer object to the FBO\n        gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);\n        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);\n\n        // Unbind the buffer object\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n        gl.bindTexture(gl.TEXTURE_2D, null);\n        gl.bindRenderbuffer(gl.RENDERBUFFER, null);\n\n        return frameBuffer;\n    }\n};\n\n//# sourceURL=webpack:///./src/DataViewer/3D/webgl-util.js?");

/***/ }),

/***/ "./src/DataViewer/BasicLine/BasicLineIrregularDataViewer.js":
/*!******************************************************************!*\
  !*** ./src/DataViewer/BasicLine/BasicLineIrregularDataViewer.js ***!
  \******************************************************************/
/*! exports provided: BasicLineIrregularDataViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicLineIrregularDataViewer\", function() { return BasicLineIrregularDataViewer; });\n/* harmony import */ var _Sub_Tip_TipControl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Sub/Tip/TipControl */ \"./src/DataViewer/Sub/Tip/TipControl.js\");\n/* harmony import */ var _Util_RandomPicker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Util/RandomPicker */ \"./src/Util/RandomPicker.js\");\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Draw/Draw */ \"./src/Draw/Draw.js\");\n/* harmony import */ var _Sub_SingleSeriesViewer_SingleLineSeriesViewer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Sub/SingleSeriesViewer/SingleLineSeriesViewer */ \"./src/DataViewer/Sub/SingleSeriesViewer/SingleLineSeriesViewer.js\");\n\n\n\n\n\n/**\n * construct a basic line linear data.\n * @param htmlContainer     the html container (html layer) is needed as we need to append the tooltip to it.\n * @param svg               to which we will append the svg elements\n * @param svgTrigger        tooltip trigger\n * @param input             the data points\n * @param xDrawInfo         the analysis of x axis, we need to draw the lines / nodes according to the axis (of course)\n * @param yDrawInfo         the analysis of y axis\n * @param isContinual       draw nodes / lines\n * @constructor\n */\nfunction BasicLineIrregularDataViewer(htmlContainer, svg, svgTrigger, input, xDrawInfo, yDrawInfo, isContinual) {\n    this.htmlContainer = htmlContainer;\n    this.svg = svg;\n    this.svgTrigger = svgTrigger;\n    this.input = input;\n    this.xDrawInfo = xDrawInfo;\n    this.yDrawInfo = yDrawInfo;\n    this.topTip = null;\n    this.isContinual = isContinual;\n}\n\n\n/**\n * need not be called after analyze() because there is no such method in this class.\n * draw the lines / nodes for data.\n */\nBasicLineIrregularDataViewer.prototype.draw = function () {\n    let tipControl = new _Sub_Tip_TipControl__WEBPACK_IMPORTED_MODULE_0__[\"TipControl\"](this.htmlContainer, 7, false);\n    tipControl.createTip();\n\n    //loop through different series\n    let series = this.input.series;\n    let randomPicker = new _Util_RandomPicker__WEBPACK_IMPORTED_MODULE_1__[\"RandomPicker\"]();\n\n    let svgDrawGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_2__[\"draw\"].createGroup();\n    let svgTriggerGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_2__[\"draw\"].createGroup();\n\n    for(let i = 0; i < series.length; i++) {\n        let singleSeriesName = series[i][0];\n        let singleSeriesData = series[i][1];\n        let nodes = this.analyzeSingleSeriesData(singleSeriesData);\n\n        let mcColor = randomPicker.pickSeriesColor();\n        let nodeShape = randomPicker.pickNodeShape();\n        //I need to pass in the this.htmlContainer rather than a div that serves as a group because I need to\n        //append the tip template to the dom in order to use its getClientBoundingRect method. And this.htmlContainer\n        //is already inserted into the DOM.\n        let singleLineSeriesViewer = new _Sub_SingleSeriesViewer_SingleLineSeriesViewer__WEBPACK_IMPORTED_MODULE_3__[\"SingleLineSeriesViewer\"](this.htmlContainer, svgDrawGroup, svgTriggerGroup, nodes, nodeShape, mcColor,\n            this.isContinual, false, singleSeriesName, tipControl, this.xDrawInfo, this.yDrawInfo);\n        singleLineSeriesViewer.draw();\n    }\n\n    this.svg.appendChild(svgDrawGroup);\n    this.svgTrigger.appendChild(svgTriggerGroup);\n};\n\n\n/**\n * returns an array that contains both pixel information and data information. The stride is 4 and the first 2 are pixel positions\n * while the last 2 are data information.\n * @param singleSeriesData      the data of a single series\n * @returns {Array}\n */\nBasicLineIrregularDataViewer.prototype.analyzeSingleSeriesData = function(singleSeriesData){\n    let nodes = []; //reset it to empty array.\n\n    for (let ii = 0; ii < singleSeriesData.length; ii++) {\n        let x = this.xDrawInfo.startPoint + (singleSeriesData[ii][0] - this.xDrawInfo.min) * this.xDrawInfo.pixelPerData;\n        let y = this.yDrawInfo.startPoint - (singleSeriesData[ii][1] - this.yDrawInfo.min) * this.yDrawInfo.pixelPerData;\n\n        nodes.push(x);\n        nodes.push(y);\n        nodes.push(singleSeriesData[ii][0]);\n        nodes.push(singleSeriesData[ii][1]);\n    }\n    return nodes;\n};\n\n\n//# sourceURL=webpack:///./src/DataViewer/BasicLine/BasicLineIrregularDataViewer.js?");

/***/ }),

/***/ "./src/DataViewer/BasicLine/BasicLineRegularDataViewer.js":
/*!****************************************************************!*\
  !*** ./src/DataViewer/BasicLine/BasicLineRegularDataViewer.js ***!
  \****************************************************************/
/*! exports provided: BasicLineRegularDataViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicLineRegularDataViewer\", function() { return BasicLineRegularDataViewer; });\n/* harmony import */ var _Sub_Tip_TipControl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Sub/Tip/TipControl */ \"./src/DataViewer/Sub/Tip/TipControl.js\");\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Draw/Draw */ \"./src/Draw/Draw.js\");\n/* harmony import */ var _Util_RandomPicker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Util/RandomPicker */ \"./src/Util/RandomPicker.js\");\n/* harmony import */ var _Sub_SingleSeriesViewer_SingleLineSeriesViewer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Sub/SingleSeriesViewer/SingleLineSeriesViewer */ \"./src/DataViewer/Sub/SingleSeriesViewer/SingleLineSeriesViewer.js\");\n\n\n\n\n\n/**\n * construct a basic line linear data. the data must be regular (ie. the data intervals between data points need to be the same)\n * @param htmlContainer     the html container (html layer) is needed as we need to append the tooltip to it.\n * @param svg               to which we will append the svg elements\n * @param svgTrigger        tooltip trigger\n * @param input             the data points\n * @param xDrawInfo         the analysis of x axis, we need to draw the lines / nodes according to the axis (of course)\n * @param yDrawInfo         the analysis of y axis\n * @param isContinual       draw nodes / lines\n * @constructor\n */\nfunction BasicLineRegularDataViewer(htmlContainer, svg, svgTrigger, input, xDrawInfo, yDrawInfo, isContinual){\n    this.htmlContainer = htmlContainer;\n    this.svg = svg;\n    this.svgTrigger = svgTrigger;\n    this.input = input;\n    this.xDrawInfo = xDrawInfo;\n    this.yDrawInfo = yDrawInfo;\n    this.isContinual = isContinual;\n}\n\n/**\n * This method draws the data between x and y axes. And it also configure the event listener.\n *\n * Since this method will only be called once it is ok to define some functions inside this method.\n */\nBasicLineRegularDataViewer.prototype.draw = function(){\n\n    let svgDrawGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createGroup();\n    let svgTriggerGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createGroup();\n    let randomPicker = new _Util_RandomPicker__WEBPACK_IMPORTED_MODULE_2__[\"RandomPicker\"]();\n    let tipControl =  new _Sub_Tip_TipControl__WEBPACK_IMPORTED_MODULE_0__[\"TipControl\"](this.htmlContainer, 7, false);\n    tipControl.createTip();\n\n    for(let i = 0; i < this.input.series.length; i++){\n        let seriesName = this.input.series[i][0];\n        let nodes = this.analyzeSingleSeriesData(this.input.series[i][1]);\n        let sssv = new _Sub_SingleSeriesViewer_SingleLineSeriesViewer__WEBPACK_IMPORTED_MODULE_3__[\"SingleLineSeriesViewer\"](this.htmlContainer, svgDrawGroup, svgTriggerGroup, nodes,\n            randomPicker.pickNodeShape(), randomPicker.pickSeriesColor(), this.isContinual, this.input.interval, seriesName,\n            tipControl, this.xDrawInfo, this.yDrawInfo);\n        sssv.draw();\n    }\n\n    this.svg.appendChild(svgDrawGroup);\n    this.svgTrigger.appendChild(svgTriggerGroup);\n\n\n};\n\n/**\n * returns an array that contains both pixel information and data information. The stride is 4 and the first 2 are pixel positions\n * while the last one are data information. The third is not really needed and therefore is set to 0;\n * @param singleSeriesData      the data of a single series\n * @returns {Array}             each element in the array contains the all necessary drawing information for a data point.\n */\nBasicLineRegularDataViewer.prototype.analyzeSingleSeriesData = function(singleSeriesData){\n    let nodes = [];\n    let interval = this.input.interval;\n    let start = this.input.start;\n    for(let i = 0; i < singleSeriesData.length; i++){\n        let pixelX = this.xDrawInfo.startPoint + i * interval * this.xDrawInfo.pixelPerData;\n        let pixelY = this.yDrawInfo.startPoint - (singleSeriesData[i] - this.yDrawInfo.min) * this.yDrawInfo.pixelPerData;\n        nodes.push(pixelX);\n        nodes.push(pixelY);\n        nodes.push(start + interval * i);\n        nodes.push(singleSeriesData[i]);\n    }\n\n    return nodes;\n};\n\n\n\n\n//# sourceURL=webpack:///./src/DataViewer/BasicLine/BasicLineRegularDataViewer.js?");

/***/ }),

/***/ "./src/DataViewer/Category/BasicCategoryDataViewer.js":
/*!************************************************************!*\
  !*** ./src/DataViewer/Category/BasicCategoryDataViewer.js ***!
  \************************************************************/
/*! exports provided: BasicCategoryDataViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicCategoryDataViewer\", function() { return BasicCategoryDataViewer; });\n/* harmony import */ var _Util_RandomPicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Util/RandomPicker */ \"./src/Util/RandomPicker.js\");\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Draw/Draw */ \"./src/Draw/Draw.js\");\n/* harmony import */ var _Sub_Tip_TipControl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Sub/Tip/TipControl */ \"./src/DataViewer/Sub/Tip/TipControl.js\");\n/* harmony import */ var _Sub_SingleSeriesViewer_SingleColumnViewer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Sub/SingleSeriesViewer/SingleColumnViewer */ \"./src/DataViewer/Sub/SingleSeriesViewer/SingleColumnViewer.js\");\n/**\n * Created by wangsheng on 12/6/14.\n */\n\n\n\n\n\n\n/**\n * this class is used to draw category columns\n *\n * @param htmlContainer     the html container (html layer) is needed as we need to append the tooltip to it.\n * @param svg               to which we will append the svg elements\n * @param svgTrigger        tooltip trigger\n * @param input             the data points\n * @param xDrawInfo         the analysis of x axis, we need to draw the lines / nodes according to the axis (of course)\n * @param yDrawInfo         the analysis of y axis\n * @constructor\n */\nfunction BasicCategoryDataViewer(htmlContainer, svg, svgTrigger, input, xDrawInfo, yDrawInfo){\n    this.htmlContainer = htmlContainer;\n    this.svg = svg;\n    this.svgTrigger = svgTrigger;\n    this.input = input;\n    this.xDrawInfo = xDrawInfo;\n    this.yDrawInfo = yDrawInfo;\n}\n\n/**\n * public method. called by the weaver to draw the columns, and also set proper event listeners on those columns\n */\nBasicCategoryDataViewer.prototype.draw = function(){\n    let random = new _Util_RandomPicker__WEBPACK_IMPORTED_MODULE_0__[\"RandomPicker\"]();\n    let svgGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createGroup();\n    let svgTriggerGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createGroup();\n    let tipControl = new _Sub_Tip_TipControl__WEBPACK_IMPORTED_MODULE_2__[\"TipControl\"](this.htmlContainer, 7, true);\n    tipControl.createTip();\n\n    for(let i = 0; i <  this.xDrawInfo.categoryBasePositions.length; i = i + 2){\n        //in this case the nodes array will contain only one node. This is because a basic column series will only have one data.\n        let nodes = [\n            this.xDrawInfo.categoryBasePositions[i]/*pixelX*/,\n            this.xDrawInfo.categoryBasePositions[i+1],\n            0/*dataX, does not matter here*/,\n            this.input.series[i/2][1]\n        ];\n\n        let seriesName = this.input.series[i/2][0];\n\n        let scv = new _Sub_SingleSeriesViewer_SingleColumnViewer__WEBPACK_IMPORTED_MODULE_3__[\"SingleColumnViewer\"]();\n\n        scv.draw(nodes[0], nodes[1], this.xDrawInfo.columnWidth, seriesName, nodes[3], random.pickSeriesColor(), nodes, svgGroup, svgTriggerGroup,\n            tipControl, this.htmlContainer, this.yDrawInfo);\n    }\n    this.svg.appendChild(svgGroup);\n    this.svgTrigger.appendChild(svgTriggerGroup);\n};\n\n\n//# sourceURL=webpack:///./src/DataViewer/Category/BasicCategoryDataViewer.js?");

/***/ }),

/***/ "./src/DataViewer/Pie/BasicPieDataViewer.js":
/*!**************************************************!*\
  !*** ./src/DataViewer/Pie/BasicPieDataViewer.js ***!
  \**************************************************/
/*! exports provided: BasicPieDataViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicPieDataViewer\", function() { return BasicPieDataViewer; });\n/* harmony import */ var _Util_RandomPicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Util/RandomPicker */ \"./src/Util/RandomPicker.js\");\n/* harmony import */ var _Sub_Tip_TipControl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Sub/Tip/TipControl */ \"./src/DataViewer/Sub/Tip/TipControl.js\");\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Draw/Draw */ \"./src/Draw/Draw.js\");\n/* harmony import */ var _Sub_SingleSeriesViewer_SinglePieSeriesViewer_SinglePieSeriesViewer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Sub/SingleSeriesViewer/SinglePieSeriesViewer/SinglePieSeriesViewer */ \"./src/DataViewer/Sub/SingleSeriesViewer/SinglePieSeriesViewer/SinglePieSeriesViewer.js\");\n/* harmony import */ var _Sub_SingleSeriesViewer_SinglePieSeriesViewer_PieDataLabelSlotsController__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../Sub/SingleSeriesViewer/SinglePieSeriesViewer/PieDataLabelSlotsController */ \"./src/DataViewer/Sub/SingleSeriesViewer/SinglePieSeriesViewer/PieDataLabelSlotsController.js\");\n\n\n\n\n\n\n/**\n *\n *\n * this draws a pie and set up the tool tips\n * @param htmlContainer                 the html container (html layer) is needed as we need to append the tooltip to it.\n * @param svg                           to which we will append the svg elements\n * @param svgTrigger                    tooltip trigger\n * @param input                         the data points\n * @param center                        the center of the pie\n * @param dataDrawAreaX                 not sure how this is useful. remove if tested to be unused.\n * @param dataDrawAreaY                 not sure how this is useful. remove if tested to be unused.\n * @param radiusForLabel                radius of the invisible circle, along which we draw the labels\n * @param radisuForPie                  radius of the pie circle\n * @param radiusForConnectionLineTurn   radius of the invisible circle, along which we set the middle point of the connection line (cubic curve).\n * @param total                         the sum of all series\n * @constructor\n */\nfunction BasicPieDataViewer(htmlContainer, svg, svgTrigger, input, center, dataDrawAreaX, dataDrawAreaY, radiusForLabel, radisuForPie, radiusForConnectionLineTurn, total){\n    this.htmlContainer = htmlContainer;\n    this.svg = svg;\n    this.svgTrigger = svgTrigger;\n    this.input = input;\n    this.center = center;\n    this.dataDrawAreaX = dataDrawAreaX;\n    this.dataDrawAreaY = dataDrawAreaY;\n    this.radiusForLabel = radiusForLabel;\n    this.radiusForPie = radisuForPie;\n    this.radiusForConnectionLineTurn = radiusForConnectionLineTurn;\n    this.total = total;\n}\n\n/**\n * draw the pie, label,s and connection lines. set up the tool tips as well.\n */\nBasicPieDataViewer.prototype.draw = function(){\n    let slices = this.analyze();\n    let random = new _Util_RandomPicker__WEBPACK_IMPORTED_MODULE_0__[\"RandomPicker\"]();\n\n    let svgGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_2__[\"draw\"].createGroup();\n    let svgTriggerGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_2__[\"draw\"].createGroup();\n\n    let tipControl = new _Sub_Tip_TipControl__WEBPACK_IMPORTED_MODULE_1__[\"TipControl\"](this.htmlContainer, 0, true);\n    tipControl.createTip();\n\n    let labelSlotsController = new _Sub_SingleSeriesViewer_SinglePieSeriesViewer_PieDataLabelSlotsController__WEBPACK_IMPORTED_MODULE_4__[\"PieDataLabelSlotsController\"]();\n    labelSlotsController.generateEmptySlots(19/*label height*/, this.center, this.radiusForLabel, this.svg);\n\n    let leftConnectorsInfo = [];\n    let rightConnectorsInfo = [];\n\n    for(let i = 0; i < slices.length; i = i + 4){\n        let startAngle = slices[i];\n        let endAngle = slices[i+1];\n        let seriesName = slices[i+2];\n        let dataY = slices[i+3];\n        let spsv = new _Sub_SingleSeriesViewer_SinglePieSeriesViewer_SinglePieSeriesViewer__WEBPACK_IMPORTED_MODULE_3__[\"SinglePieSeriesViewer\"](svgGroup, this.htmlContainer, tipControl, svgTriggerGroup, startAngle,\n            endAngle, this.radiusForLabel, this.radiusForPie, this.radiusForConnectionLineTurn, this.center, seriesName, random.pickSeriesColor(), dataY, labelSlotsController);\n        let connectorInfo = spsv.getConnectorInfo();\n\n        if(connectorInfo.isLeft){\n            leftConnectorsInfo.push(connectorInfo);\n        } else {\n            rightConnectorsInfo.push(connectorInfo);\n        }\n        spsv.draw();\n    }\n\n    if(!this.input.noDataLabel){\n        leftConnectorsInfo = labelSlotsController.processConnectorInfo(leftConnectorsInfo, true);\n        rightConnectorsInfo = labelSlotsController.processConnectorInfo(rightConnectorsInfo, false);\n        for(let i = 0; i < leftConnectorsInfo.length; i++){\n            svgGroup.appendChild(labelSlotsController.createConnectionLine(leftConnectorsInfo[i]));\n            svgGroup.appendChild(labelSlotsController.createTextInSlot(leftConnectorsInfo[i].text, leftConnectorsInfo[i].slotIdx, true));\n        }\n\n        for(let i = 0; i < rightConnectorsInfo.length; i++){\n            svgGroup.appendChild(labelSlotsController.createConnectionLine(rightConnectorsInfo[i]));\n            svgGroup.appendChild(labelSlotsController.createTextInSlot(rightConnectorsInfo[i].text, rightConnectorsInfo[i].slotIdx, false));\n        }\n    }\n\n    this.svg.appendChild(svgGroup);\n    this.svgTrigger.appendChild(svgTriggerGroup);\n};\n\nBasicPieDataViewer.prototype.analyze = function(){\n    let slices = []; //[startAngle, endAngle, seriesName, dataY, startAngle, endAngle, seriesName, dataY....]\n    let startAngle = 0;\n    for(let i = 0; i < this.input.series.length; i++){\n        let single = this.input.series[i][1];\n        let angle = (single / this.total) *  360;\n\n        slices.push(startAngle); //start angle.\n        slices.push(startAngle + angle); //end angle.\n        slices.push(this.input.series[i][0]); //single series name.\n        slices.push(single); //single series data.\n\n        startAngle = startAngle + angle;\n    }\n\n    return slices;\n};\n\n//# sourceURL=webpack:///./src/DataViewer/Pie/BasicPieDataViewer.js?");

/***/ }),

/***/ "./src/DataViewer/Stack/BasicSingleTimeDataViewer.js":
/*!***********************************************************!*\
  !*** ./src/DataViewer/Stack/BasicSingleTimeDataViewer.js ***!
  \***********************************************************/
/*! exports provided: BasicSingleTimeData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicSingleTimeData\", function() { return BasicSingleTimeData; });\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Draw/Draw */ \"./src/Draw/Draw.js\");\n/* harmony import */ var _Util_RandomPicker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Util/RandomPicker */ \"./src/Util/RandomPicker.js\");\n/* harmony import */ var _Sub_Tip_TipControl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Sub/Tip/TipControl */ \"./src/DataViewer/Sub/Tip/TipControl.js\");\n/* harmony import */ var _Sub_SingleSeriesViewer_SingleTimeSeriesViewer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Sub/SingleSeriesViewer/SingleTimeSeriesViewer */ \"./src/DataViewer/Sub/SingleSeriesViewer/SingleTimeSeriesViewer.js\");\n/**\n * draw the time based data (using a single line)\n * @param htmlContainer     the html container (html layer) is needed as we need to append the tooltip to it.\n * @param svg               to which we will append the svg elements\n * @param svgTrigger        tooltip trigger\n * @param input             the data points\n * @param xDrawInfo         the analysis of x axis, we need to draw the lines / nodes according to the axis (of course)\n * @param yDrawInfo         the analysis of y axis\n * @param isContinual       draw nodes / lines\n * @constructor\n */\n\n\n\n\n\nfunction BasicSingleTimeData(htmlContainer, svg, svgTrigger, input, xDrawInfo, yDrawInfo, isContinual){\n    this.htmlContainer = htmlContainer;\n    this.svg = svg;\n    this.svgTrigger = svgTrigger;\n    this.input = input;\n    this.xDrawInfo = xDrawInfo;\n    this.yDrawInfo = yDrawInfo;\n    this.topTip = null;\n    this.isContinual = isContinual;\n}\n\n/**\n * This method draws the data between x and y axes. And it also configure the event listener.\n *\n * Since this method will only be called once it is ok to define some functions inside this method.\n */\nBasicSingleTimeData.prototype.draw = function(){\n    let seriesName = this.input.series[0][0];\n    let nodes = this.analyzeSingleSeriesData(this.input.series[0][1]);\n\n    let svgDrawGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createGroup();\n    let svgTriggerGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createGroup();\n    let randomPicker = new _Util_RandomPicker__WEBPACK_IMPORTED_MODULE_1__[\"RandomPicker\"]();\n    let tipControl = new _Sub_Tip_TipControl__WEBPACK_IMPORTED_MODULE_2__[\"TipControl\"](this.htmlContainer, 7, false);\n    tipControl.createTip();\n\n    let sssv = new _Sub_SingleSeriesViewer_SingleTimeSeriesViewer__WEBPACK_IMPORTED_MODULE_3__[\"SingleTimeSeriesViewer\"](this.htmlContainer, svgDrawGroup, svgTriggerGroup, nodes,\n        randomPicker.pickNodeShape(), randomPicker.pickSeriesColor(), this.isContinual, this.input.interval, seriesName,\n        tipControl, this.xDrawInfo, this.yDrawInfo, 1, true);\n\n    sssv.draw();\n\n    this.svg.appendChild(svgDrawGroup);\n    this.svgTrigger.appendChild(svgTriggerGroup);\n};\n\n/**\n * returns an array that contains both pixel information and data information. The stride is 4 and the first 2 are pixel positions\n * while the last one are data information. The third is not really needed and therefore is set to 0;\n * @param singleSeriesData\n * @returns {Array}\n */\nBasicSingleTimeData.prototype.analyzeSingleSeriesData = function(singleSeriesData){\n    let nodes = [];\n    let interval = this.input.interval;\n    let startTime = this.input.startTime;\n\n    let parseTime = assembleParseTimeFunction(this.input.unit);\n\n    for(let i = 0; i < singleSeriesData.length; i++){\n        let pixelX = this.xDrawInfo.startPoint + i * interval * this.xDrawInfo.pixelPerData;\n        let pixelY = this.yDrawInfo.startPoint - (singleSeriesData[i] - this.yDrawInfo.min) * this.yDrawInfo.pixelPerData;\n        nodes.push(pixelX);\n        nodes.push(pixelY);\n        nodes.push(parseTime(i));\n        nodes.push(singleSeriesData[i]);\n    }\n\n\n    function assembleParseTimeFunction(unit){\n        switch(unit){\n            case \"s\":\n                return null;//TODO\n            case \"m\":\n                return function(idx){\n                    let date = new Date(startTime + interval * idx * 60000);\n                    return \"(\" + date.getFullYear() + \"-\" + (date.getMonth()+1) + \"-\" + date.getDate() + \" \" + (date.getHours()+1)\n                    + \":\" + (date.getMinutes()+1) + \")\";\n                };\n\n            case \"h\":\n                return null;//TODO\n\n        }\n    }\n\n    return nodes;\n};\n\n\n\n\n//# sourceURL=webpack:///./src/DataViewer/Stack/BasicSingleTimeDataViewer.js?");

/***/ }),

/***/ "./src/DataViewer/Stack/BasicStackRegularDataViewer.js":
/*!*************************************************************!*\
  !*** ./src/DataViewer/Stack/BasicStackRegularDataViewer.js ***!
  \*************************************************************/
/*! exports provided: BasicStackRegularDataViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BasicStackRegularDataViewer\", function() { return BasicStackRegularDataViewer; });\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../Draw/Draw */ \"./src/Draw/Draw.js\");\n/* harmony import */ var _Util_RandomPicker__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../Util/RandomPicker */ \"./src/Util/RandomPicker.js\");\n/* harmony import */ var _Sub_SingleSeriesViewer_SingleStackSeriesViewer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Sub/SingleSeriesViewer/SingleStackSeriesViewer */ \"./src/DataViewer/Sub/SingleSeriesViewer/SingleStackSeriesViewer.js\");\n/* harmony import */ var _Sub_Tip_Sub_SharedControl_SharedTipControl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Sub/Tip/Sub/SharedControl/SharedTipControl */ \"./src/DataViewer/Sub/Tip/Sub/SharedControl/SharedTipControl.js\");\n/**\n * draws the stacks for regular data.\n *\n * @param htmlContainer     the html container (html layer) is needed as we need to append the tooltip to it.\n * @param svg               to which we will append the svg elements\n * @param svgTrigger        tooltip trigger\n * @param input             the data points\n * @param xDrawInfo         the analysis of x axis, we need to draw the lines / nodes according to the axis (of course)\n * @param yDrawInfo         the analysis of y axis\n * @param isContinual       draw nodes / lines\n * @constructor\n */\n\n\n\n\n\nfunction BasicStackRegularDataViewer(htmlContainer, svg, svgTrigger, input, xDrawInfo, yDrawInfo, isContinual){\n    this.htmlContainer = htmlContainer;\n    this.svg = svg;\n    this.svgTrigger = svgTrigger;\n    this.input = input;\n    this.xDrawInfo = xDrawInfo;\n    this.yDrawInfo = yDrawInfo;\n    this.topTip = null;\n    this.isContinual = isContinual;\n}\n\n/**\n * This method draws the data between x and y axes. And it also configure the event listener.\n */\nBasicStackRegularDataViewer.prototype.draw = function(){\n    let svgDrawGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createGroup();\n    let svgTriggerGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createGroup();\n    let randomPicker = new _Util_RandomPicker__WEBPACK_IMPORTED_MODULE_1__[\"RandomPicker\"]();\n    let tipControl = new _Sub_Tip_Sub_SharedControl_SharedTipControl__WEBPACK_IMPORTED_MODULE_3__[\"SharedTipControl\"](this.htmlContainer, 7);\n\n    let seriesNames = [];\n    for(let i = 0; i < this.input.series.length; i++){\n        seriesNames.push(this.input.series[i][0]);\n    }\n\n    tipControl.createTip(seriesNames);//call it here after all\n\n    //since all series are of the same length i will just use the length of the first one.\n    let stackedData = new Array(this.input.series[0][1].length);\n    for(let i = 0; i < stackedData.length; i++){\n        stackedData[i] = 0;\n    }\n\n    //since the last drawn covers up the previous drawn, I need to store them first and then reverse the order.\n    let seriesDrawInfos = [];\n    for(let i = 0; i < this.input.series.length; i++){\n        let seriesName = this.input.series[i][0];\n        let nodes = this.analyzeSingleSeriesData(this.input.series[i][1], stackedData);\n        seriesDrawInfos.push([seriesName, nodes]);\n    }\n    seriesDrawInfos.reverse();\n\n    for(let i = 0; i < seriesDrawInfos.length; i++){\n        let seriesName = seriesDrawInfos[i][0];\n        let nodes = seriesDrawInfos[i][1];\n        let sssv = new _Sub_SingleSeriesViewer_SingleStackSeriesViewer__WEBPACK_IMPORTED_MODULE_2__[\"SingleStackSeriesViewer\"](this.htmlContainer, svgDrawGroup, svgTriggerGroup, nodes,\n        randomPicker.pickNodeShape(), randomPicker.pickSeriesColor(), this.isContinual, this.input.interval, seriesName,\n        tipControl, this.xDrawInfo, this.yDrawInfo, 3, false);\n        sssv.draw();\n    }\n\n    this.svg.appendChild(svgDrawGroup);\n    this.svgTrigger.appendChild(svgTriggerGroup);\n};\n\n/**\n * returns an array that contains both pixel information and data information. The stride is 4 and the first 2 are pixel positions\n * while the last one are data information. The third is not really needed and therefore is set to 0;\n * @param singleSeriesData\n * @returns {Array}\n */\nBasicStackRegularDataViewer.prototype.analyzeSingleSeriesData = function(singleSeriesData, stackedData){\n    let nodes = [];\n    let interval = this.input.interval;\n\n    for(let i = 0; i < singleSeriesData.length; i++){\n        let pixelX = this.xDrawInfo.startPoint + i * interval * this.xDrawInfo.pixelPerData;\n        stackedData[i] = singleSeriesData[i] + stackedData[i];\n        let pixelY = this.yDrawInfo.startPoint - (stackedData[i] - this.yDrawInfo.min) * this.yDrawInfo.pixelPerData;\n        nodes.push(pixelX);\n        nodes.push(pixelY);\n        nodes.push(this.input.start + this.input.interval * i);\n        nodes.push(singleSeriesData[i]);\n    }\n    return nodes;\n};\n\n\n\n\n//# sourceURL=webpack:///./src/DataViewer/Stack/BasicStackRegularDataViewer.js?");

/***/ }),

/***/ "./src/DataViewer/Sub/SingleSeriesViewer/SingleColumnViewer.js":
/*!*********************************************************************!*\
  !*** ./src/DataViewer/Sub/SingleSeriesViewer/SingleColumnViewer.js ***!
  \*********************************************************************/
/*! exports provided: SingleColumnViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SingleColumnViewer\", function() { return SingleColumnViewer; });\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Draw/Draw */ \"./src/Draw/Draw.js\");\n/* harmony import */ var _Tip_TriggerControl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Tip/TriggerControl */ \"./src/DataViewer/Sub/Tip/TriggerControl.js\");\n\n\n\n/**\n * this class is used to draw a single column\n * @constructor\n */\nfunction SingleColumnViewer(){}\n\n/**\n * draw a single column\n * @param columnBasePositionX       the position of the column (the column base, not the center of the column)\n * @param columnBasePositionY       the position of the column (the column base, not the center of the column)\n * @param columnWidth               width of the column\n * @param seriesName                name of the series\n * @param seriesData                data of the series\n * @param mcColor                   color the series, used both for the tooltip and column\n * @param nodes                     nodes\n * @param svg                       svg container to which we will append the svg elements\n * @param svgTrigger                tooltip trigger\n * @param tipControl                tooltip control, used for tool tip related stuffs\n * @param htmlContainer             html container, we append the tool tips (html elements) to it\n * @param yDrawInfo                 extra info for drawing the column\n */\nSingleColumnViewer.prototype.draw = function(columnBasePositionX, columnBasePositionY, columnWidth, seriesName,\n                                             seriesData, mcColor, nodes, svg, svgTrigger, tipControl, htmlContainer, yDrawInfo) {\n    //draw the visual column\n    let columnHeight = (seriesData - yDrawInfo.min) * yDrawInfo.pixelPerData;\n    let column = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createRectangular(columnBasePositionX - columnWidth/2, columnBasePositionY - columnHeight, columnWidth, columnHeight);\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setStrokeFill(column, mcColor.strokeColor, 2, mcColor.fillColor);\n    svg.appendChild(column);\n\n    //configure listeners.\n    this.enableColumnTip(columnBasePositionX, columnBasePositionY, columnWidth, columnHeight, seriesName, seriesData,\n        mcColor, nodes, svgTrigger, tipControl, htmlContainer);\n};\n\n/**\n * enable the tooltip for a column\n * @param columnBasePositionX       the position of the column (the column base, not the center of the column)\n * @param columnBasePositionY       the position of the column (the column base, not the center of the column)\n * @param columnWidth               width of the column\n * @param columnHeight              height of the column\n * @param seriesName                name of the series\n * @param columnData                data of the series / column\n * @param mcColor                   color the series, used both for the tooltip and column\n * @param nodes                     nodes\n * @param svgTrigger                tooltip trigger\n * @param tipControl                tooltip control, used for tool tip related stuffs\n * @param htmlContainer             html container, we append the tool tips (html elements) to it\n */\nSingleColumnViewer.prototype.enableColumnTip = function(columnBasePositionX, columnBasePositionY, columnWidth, columnHeight,\n                                                        seriesName, columnData, mcColor, nodes, svgTrigger, tipControl, htmlContainer){\n\n    let columnTrigger = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createRectangular(columnBasePositionX - columnWidth/2, columnBasePositionY - columnHeight,\n        columnWidth, columnHeight);\n\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setStrokeFill(columnTrigger, false, false, \"rgb(0,0,0)\");\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setVisibility(columnTrigger, false);\n    columnTrigger.setAttributeNS(null, \"pointer-events\", \"fill\");\n\n    let triggerControl = new _Tip_TriggerControl__WEBPACK_IMPORTED_MODULE_1__[\"TriggerControl\"](tipControl, seriesName, mcColor);\n    triggerControl.enableColumnTrigger(columnTrigger, htmlContainer, seriesName, mcColor, nodes);\n    svgTrigger.appendChild(columnTrigger);\n};\n\n//# sourceURL=webpack:///./src/DataViewer/Sub/SingleSeriesViewer/SingleColumnViewer.js?");

/***/ }),

/***/ "./src/DataViewer/Sub/SingleSeriesViewer/SingleLineSeriesViewer.js":
/*!*************************************************************************!*\
  !*** ./src/DataViewer/Sub/SingleSeriesViewer/SingleLineSeriesViewer.js ***!
  \*************************************************************************/
/*! exports provided: SingleLineSeriesViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SingleLineSeriesViewer\", function() { return SingleLineSeriesViewer; });\n/* harmony import */ var _Draw_NodeDrawer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Draw/NodeDrawer */ \"./src/Draw/NodeDrawer.js\");\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Draw/Draw */ \"./src/Draw/Draw.js\");\n/* harmony import */ var _Tip_TriggerControl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Tip/TriggerControl */ \"./src/DataViewer/Sub/Tip/TriggerControl.js\");\n/**\n * this class draws a single line for a single series, and also setup the tooltip for this series\n * @param htmlContainer             html container, we append the tool tips (html elements) to it\n * @param svg                       svg container to which we will append the svg elements\n * @param svgTrigger                tooltip trigger\n * @param nodes                     nodes\n * @param nodeShape                 node shape\n * @param mcColor                   color\n * @param isContinual               if not enough space, we will draw a continous line to represent the data of this seris\n * @param constantInterval          if not regular is should be false, otherwise it should be the interval value\n * @param seriesName                name of the series\n * @param tipControl                tool tip control\n * @param xDrawInfo                 extra info about x axis\n * @param yDrawInfo                 extra info about y axis\n * @constructor\n */\n\n\n\n\nfunction SingleLineSeriesViewer(htmlContainer, svg, svgTrigger, nodes, nodeShape, mcColor,\n                                       isContinual, constantInterval/*if not regular is should be false, otherwise it should be the interval value*/,\n                                       seriesName, tipControl, xDrawInfo, yDrawInfo){\n    this.htmlContainer = htmlContainer; //if use the default inherited 'showTip' method then this field must be set.\n    this.svg = svg;\n    this.svgTrigger = svgTrigger;\n    this.nodes = nodes;\n    this.nodeShape = nodeShape;\n    this.mcColor = mcColor;\n    this.constantInterval = constantInterval;\n    this.isContinual = isContinual;\n    this.seriesName = seriesName;\n    this.xDrawInfo = xDrawInfo;\n    this.yDrawInfo = yDrawInfo;\n\n    this.svgLayerGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createGroup();\n    this.svgTriggerGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createGroup();\n\n    this.tipControl = tipControl;\n}\n\n/**\n * draw the line / nodes, and enable the tool tip\n */\nSingleLineSeriesViewer.prototype.draw = function(){\n    this.svgLayerGroup.appendChild(this.drawLine());\n    this.drawNodes();\n    let highlightedNode = this.drawHighlightNode();\n    this.enableNodeTrigger(highlightedNode);\n    this.enableRoutineTrace();\n    this.svg.appendChild(this.svgLayerGroup);\n    this.svgTrigger.appendChild(this.svgTriggerGroup);\n};\n\n/**\n * draw line\n * @returns {*|SVGElement}\n */\nSingleLineSeriesViewer.prototype.drawLine = function(){\n    let lines = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createStraightLines(this.nodes, 4, 0);\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].setStrokeFill(lines, this.mcColor.strokeColor, 2, \"none\");\n    return lines;\n};\n\n/**\n * draw nodes\n */\nSingleLineSeriesViewer.prototype.drawNodes = function(){\n    if(this.isContinual){\n        return;\n    }\n\n    let visualNodeGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createGroup();\n    for (let i = 0; i < this.nodes.length; i = i + 4) {\n        //this is the one that users see\n        let visualNode = _Draw_NodeDrawer__WEBPACK_IMPORTED_MODULE_0__[\"nodeDrawer\"].draw(this.nodeShape, this.mcColor, this.nodes[i], this.nodes[i+1]);\n        visualNodeGroup.appendChild(visualNode);\n    }\n    this.svgLayerGroup.appendChild(visualNodeGroup);\n};\n\n/**\n * draw highlight nodes. see `nodeDrawer.drawHighlightedNode`.\n * @returns {*} highlight nodes.\n */\nSingleLineSeriesViewer.prototype.drawHighlightNode = function(){\n    let highlightedNode = _Draw_NodeDrawer__WEBPACK_IMPORTED_MODULE_0__[\"nodeDrawer\"].drawHighlightedNode(this.nodeShape, this.mcColor);\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].setVisibility(highlightedNode, false);\n    this.svgLayerGroup.appendChild(highlightedNode);\n    return highlightedNode;\n};\n\n/**\n * for each node, set a listener.\n * @param highlightedNode\n */\nSingleLineSeriesViewer.prototype.enableNodeTrigger = function(highlightedNode){\n    if(this.isContinual){\n        return;\n    }\n    //draw all those node trigger zones.\n    let nodeMouseOverSectionGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createGroup();\n    for (let i = 0; i < this.nodes.length; i = i + 4) {\n        let nodeMouseOverSection = _Draw_NodeDrawer__WEBPACK_IMPORTED_MODULE_0__[\"nodeDrawer\"].drawTrigger(this.nodes[i], this.nodes[i + 1], i/4);\n        nodeMouseOverSectionGroup.appendChild(nodeMouseOverSection);\n    }\n    this.svgTriggerGroup.appendChild(nodeMouseOverSectionGroup);\n\n    //actually add listeners.\n    let triggerControl = new _Tip_TriggerControl__WEBPACK_IMPORTED_MODULE_2__[\"TriggerControl\"](this.tipControl, this.seriesName, this.mcColor);\n    triggerControl.enableNodeTrigger(nodeMouseOverSectionGroup, this.seriesName, this.mcColor, highlightedNode, this.nodes);\n};\n\n/**\n * if we are drawing a continuous line, we need a line with similar shape (but bolder), to use as a trigger\n */\nSingleLineSeriesViewer.prototype.enableRoutineTrace = function(){\n    if(!this.isContinual){\n        return;\n    }\n\n    let lineTrigger = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createStraightLines(this.nodes, 4, 0);\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].setStrokeFill(lineTrigger, this.mcColor.strokeColor, 20, \"none\");\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].setVisibility(lineTrigger, false);\n    lineTrigger.setAttributeNS(null, \"pointer-events\", \"stroke\");\n    this.svgTriggerGroup.appendChild(lineTrigger);\n\n    //actually add listeners.\n    let triggerControl = new _Tip_TriggerControl__WEBPACK_IMPORTED_MODULE_2__[\"TriggerControl\"](this.tipControl, this.seriesName, this.mcColor);\n    triggerControl.enableRoutineTrace(this.htmlContainer, this.seriesName, this.mcColor, this.nodes, lineTrigger, this.constantInterval, this.xDrawInfo);\n};\n\n\n\n\n//# sourceURL=webpack:///./src/DataViewer/Sub/SingleSeriesViewer/SingleLineSeriesViewer.js?");

/***/ }),

/***/ "./src/DataViewer/Sub/SingleSeriesViewer/SinglePieSeriesViewer/PieDataLabelSlotsController.js":
/*!****************************************************************************************************!*\
  !*** ./src/DataViewer/Sub/SingleSeriesViewer/SinglePieSeriesViewer/PieDataLabelSlotsController.js ***!
  \****************************************************************************************************/
/*! exports provided: PieDataLabelSlotsController */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PieDataLabelSlotsController\", function() { return PieDataLabelSlotsController; });\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../Draw/Draw */ \"./src/Draw/Draw.js\");\n/**\n * this class manages the slots, texts in the slots and the connection lines that connect the slot to the pie circle.\n * @constructor\n */\n\n\nfunction PieDataLabelSlotsController(){\n    this.leftSlots = [];\n    this.rightSlots = [];\n}\n\n/**\n * generate the empty slots\n * @param dataLabelHeight           the height of a single data label, this is usually decided by the font size and the size of the pie\n * @param centerOfCircleForLabel    center of the invisible circle, along which we draw the labels.\n * @param radiusOfCircleForLabel    radius of the above circle.\n * @param svg                       we will append the new elements to this svg.\n */\nPieDataLabelSlotsController.prototype.generateEmptySlots = function(dataLabelHeight, centerOfCircleForLabel, radiusOfCircleForLabel, svg/*debug purpose only*/){\n    //the slots array format: [slotIdx, slotPixelX, slotPixelY, isTaken, slotIdx, slotPixelX, slotPixelY, isTaken.....]\n    this.leftSlots = generateSlotsOnTheOneSide(true);\n    this.rightSlots = generateSlotsOnTheOneSide(false);\n\n    //test start\n//    let group = draw.createGroup();\n//    for(let i = 0; i < this.leftSlots.length; i = i + 4){\n//        let circle = draw.createCircle(this.leftSlots[i+1], this.leftSlots[i+2], 2);\n//        group.appendChild(circle);\n//    }\n//    for(let i = 0; i < this.rightSlots.length; i = i + 4){\n//        let circle = draw.createCircle(this.rightSlots[i+1], this.rightSlots[i+2], 2);\n//        group.appendChild(circle);\n//    }\n//    svg.appendChild(group);\n    //test end\n\n    function generateSlotsOnTheOneSide(isLeftHandSide){\n        let slots = [];\n        //from top to bottom\n        let availableSpace = radiusOfCircleForLabel * 2 ;\n        let dataSlotIdx = 0; //the top most slot index is 0. this index is for the right hand side only.\n        let r2 = Math.pow(radiusOfCircleForLabel, 2);\n        while(availableSpace - (dataLabelHeight * dataSlotIdx + dataLabelHeight/5) > 0){\n\n            let spaceTaken = dataLabelHeight * dataSlotIdx + dataLabelHeight/5; //plus dataLabelHeight/4 so that we don't have a data label right on top of the circle, otherwise left hand side's top will overlap right hand side's top.\n            let s2 = Math.pow(radiusOfCircleForLabel - spaceTaken, 2); //or spaceTaken - radiusOfCircleForLabel, its the same.\n\n            let horizontalDistanceFromCenter = Math.sqrt(r2 - s2);\n\n            let x;\n            if(isLeftHandSide){\n                x = centerOfCircleForLabel[0] - horizontalDistanceFromCenter;\n            } else {\n                x = centerOfCircleForLabel[0] + horizontalDistanceFromCenter;\n            }\n\n            let y = centerOfCircleForLabel[1] + (spaceTaken - radiusOfCircleForLabel);\n\n            slots.push(dataSlotIdx);\n            slots.push(x);\n            slots.push(y);\n            slots.push(false);\n\n            dataSlotIdx++;\n        }\n\n        return slots;\n    }\n};\n\n/**\n * process connectors on the circleForPie edge.\n * @param connectorsInfo    information about the connection lines\n * @param isLeft            whether the line is drawn on the left side of the pie.\n */\nPieDataLabelSlotsController.prototype.processConnectorInfo = function(connectorsInfo, isLeft){\n    //  --head-- [slot1(taken, connector1), slot2(taken, connector2), slot3(free), slot4(taken, connector3), slot5(taken, connector4), slot6(taken, connector5)] --tail--\n    //connector 1 and connector 2 belong to the same group because their slots are next to each other.\n    //connector 3, connector 4, and connector 5 belong to same group because their slots are next to each other.\n\n    sortConnectorsInfoOrderByPixelY(connectorsInfo);\n\n    let slots = isLeft ? this.leftSlots : this.rightSlots;\n\n    for(let i = 0; i < connectorsInfo.length; i++){\n        let connectorInfo = connectorsInfo[i];\n        let suitableSlotIdx = this.findNearestAvailableSlotIdx(connectorInfo.position[0], connectorInfo.position[1], slots);\n        if(suitableSlotIdx !== -1){\n            connectorInfo.slotIdx = suitableSlotIdx;\n        } else {\n            shiftCollectorsWithSlotsForward(i);\n        }\n    }\n\n    return connectorsInfo;\n\n    function sortConnectorsInfoOrderByPixelY(connectorsInfo){\n        connectorsInfo.sort((a, b) => a.position[1] - b.position[1]);\n    }\n\n    function shiftCollectorsWithSlotsForward(pendingConnectorIdx, slots){\n        let groupHeadSlotIdx = -1;\n        let group = [];//lets say connectors whose slots sit right next to each other belong to one group.\n        for(let i = pendingConnectorIdx - 1; i > 0; i--){\n            group.push(connectorsInfo[i]);\n            if(connectorsInfo[i].slotIdx - connectorsInfo[i-1].slotIdx > 1 /*there are free slots between the slot of the current connector and the slot of the preceding connector.*/){\n                groupHeadSlotIdx = connectorsInfo[i].slotIdx;\n                break;//the next connector will belong to another group.(preceding group)\n            }\n        }\n        //shift the current group 1 slot forward.\n        for(let i = 0; i < group.length; i++){\n            group[i].slotIdx = group[i].slotIdx - 1;\n        }\n        //since we move whole group 1 slot forward, we take an extra slot and we need to mark it as \"taken\"\n        slots[groupHeadSlotIdx + 3] = true;\n\n        //now since we have shift the last group 1 slot forward, there will be 1 free slot at the end.\n        //give the new free slot to our current connector.\n        //because this slot was originally marked as \"taken\", there is no need to mark it as \"taken\" again.\n        pendingConnectorIdx.slotIdx = slots.length - 1;\n    }\n};\n\n/**\n * find the nearest available slot, to a target\n * @param pixelX        position of the target\n * @param pixelY        position of the target.\n * @param slots         all the slots\n * @returns {number}    the index of the nearest slot.\n */\nPieDataLabelSlotsController.prototype.findNearestAvailableSlotIdx = function(pixelX, pixelY, slots/*left or right*/){\n    let nearestIdx = -1;\n    let nearestDistance = 10000;\n    for(let i = 0; i < slots.length; i = i + 4){\n        if(slots[i+3]){\n            //if already taken.\n            continue;\n        }\n\n        let d = calculateDistance(pixelX, pixelY, slots[i+1], slots[i+2]);\n        if(d < nearestDistance){\n            nearestDistance = d;\n            nearestIdx = i;\n        }\n    }\n\n    if(nearestIdx === -1){\n        //the preceding pie slice has already taken the last slot, there is no suitable slot.\n        return -1; //return -1 to indicate that we cannot find suitable slot and therefore need to shift other slots.\n    }\n\n    //mark the slot as taken.\n    slots[nearestIdx + 3] = true;\n    return nearestIdx / 4;\n\n    function calculateDistance(x1, y1, x2, y2){\n        return Math.sqrt(Math.pow(x2-x1, 2)+Math.pow(y2-y1, 2));\n    }\n};\n\n/**\n * draw the connection line\n * @param connectorInfo     info needed for the drawing\n * @returns {*}\n */\nPieDataLabelSlotsController.prototype.createConnectionLine = function(connectorInfo){\n    let slots;\n\n    slots = connectorInfo.isLeft ? this.leftSlots : this.rightSlots;\n    let coordinates = [connectorInfo.position[0], connectorInfo.position[1], connectorInfo.connectionLineTurnPos[0], connectorInfo.connectionLineTurnPos[1], slots[connectorInfo.slotIdx * 4 + 1], slots[connectorInfo.slotIdx * 4 + 2]];\n\n    let curve =  _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createQuadraticBezierCurve(coordinates);\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setStrokeFill(curve, connectorInfo.mcColor.strokeColor, 1, \"none\");\n    return curve;\n};\n\n/**\n *\n * @param textString            draw the text in the slot\n * @param slotIdx               slot index\n * @param isLeft                whether its on the left, or on the right.\n * @returns {SVGTextElement} the text element (the label)\n */\nPieDataLabelSlotsController.prototype.createTextInSlot = function(textString, slotIdx, isLeft){\n    let slots;\n    if(isLeft){\n        slots = this.leftSlots;\n        return _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createText(slots[slotIdx * 4 + 1] - 5 , slots[slotIdx * 4 + 2], textString, 14, isLeft ? \"end\" : \"start\", \"middle\");\n    } else {\n        slots = this.rightSlots;\n        return _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createText(slots[slotIdx * 4 + 1] + 5, slots[slotIdx * 4 + 2], textString, 14, isLeft ? \"end\" : \"start\", \"middle\");\n    }\n};\n\n//# sourceURL=webpack:///./src/DataViewer/Sub/SingleSeriesViewer/SinglePieSeriesViewer/PieDataLabelSlotsController.js?");

/***/ }),

/***/ "./src/DataViewer/Sub/SingleSeriesViewer/SinglePieSeriesViewer/SinglePieSeriesViewer.js":
/*!**********************************************************************************************!*\
  !*** ./src/DataViewer/Sub/SingleSeriesViewer/SinglePieSeriesViewer/SinglePieSeriesViewer.js ***!
  \**********************************************************************************************/
/*! exports provided: SinglePieSeriesViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SinglePieSeriesViewer\", function() { return SinglePieSeriesViewer; });\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../Draw/Draw */ \"./src/Draw/Draw.js\");\n/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../Util/Util */ \"./src/Util/Util.js\");\n/* harmony import */ var _Tip_Sub_PieSliceControl_PieSliceTriggerControl__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../Tip/Sub/PieSliceControl/PieSliceTriggerControl */ \"./src/DataViewer/Sub/Tip/Sub/PieSliceControl/PieSliceTriggerControl.js\");\n/**\n * draw the part of pie, for a single series.\n * this is mainly used in BasicPieDataViewer, so please reference that class for the meaning of the params.\n * @param svg\n * @param htmlContainer\n * @param tipControl\n * @param svgTrigger\n * @param startAngle\n * @param endAngle\n * @param radiusForLabel\n * @param radiusForPie\n * @param radiusForConnectionLineTurn\n * @param center\n * @param seriesName\n * @param mcColor\n * @param dataY\n * @param slotsController\n * @constructor\n */\n\n\n\n\nfunction SinglePieSeriesViewer(svg, htmlContainer, tipControl, svgTrigger, startAngle, endAngle, radiusForLabel, radiusForPie, radiusForConnectionLineTurn, center, seriesName, mcColor, dataY, slotsController){\n    this.svg = svg;\n    this.htmlContainer = htmlContainer;\n    this.tipControl = tipControl;\n    this.svgTrigger = svgTrigger;\n    this.startAngle = startAngle;\n    this.endAngle = endAngle;\n    this.radiusForLabel = radiusForLabel;\n    this.radiusForPie = radiusForPie;\n    this.radiusForConnectionLineTurn = radiusForConnectionLineTurn;\n    this.center = center;\n    this.seriesName = seriesName;\n    this.mcColor = mcColor;\n    this.dataY = dataY;\n    this.slotsController = slotsController;\n}\n\n/**\n * draw the part of the pie, for a single series\n */\nSinglePieSeriesViewer.prototype.draw = function(){\n    //slice.\n    let slice = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createArcOfCircle(this.center[0], this.center[1], this.radiusForPie, this.startAngle, this.endAngle);\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setStrokeFill(slice, \"white\", 1.5, this.mcColor.fillColor);\n    this.svg.appendChild(slice);\n\n    //enable trigger.\n    this.enablePieSliceTrigger();\n};\n\nSinglePieSeriesViewer.prototype.getConnectorInfo = function(){\n    //calculate the connector that connects to label. The connector is the one on the edge of our visual circle.\n    let sliceDataLabelConnectorPosition = _Util_Util__WEBPACK_IMPORTED_MODULE_1__[\"util\"].polarToCartesian(this.center[0], this.center[1], this.radiusForPie, (this.endAngle + this.startAngle)/2);\n    let connectionLineTurnPos = _Util_Util__WEBPACK_IMPORTED_MODULE_1__[\"util\"].polarToCartesian(this.center[0], this.center[1], this.radiusForConnectionLineTurn, (this.endAngle + this.startAngle)/2);\n\n    let isLeft = false;\n    if(sliceDataLabelConnectorPosition[0] < this.center[0]){\n        isLeft = true;\n    }\n\n    //test start\n//    let circle = draw.createCircle(sliceDataLabelConnectorPosition[0], sliceDataLabelConnectorPosition[1], 2);\n//    this.svg.appendChild(circle);\n    //test end.\n\n    return {\n        position: sliceDataLabelConnectorPosition,\n        connectionLineTurnPos: connectionLineTurnPos,\n        isLeft: isLeft,\n        slotIdx: -1, //to save the slot idx information.\n        text : this.seriesName + \": \" + this.dataY,\n        mcColor: this.mcColor\n    };\n};\n\n/**\n * if the labels are already shown we probably do not need to show tooltip.\n */\nSinglePieSeriesViewer.prototype.enablePieSliceTrigger = function(){\n    //slice trigger.\n    let sliceTrigger = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createArcOfCircle(this.center[0], this.center[1], this.radiusForPie, this.startAngle, this.endAngle);\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setStrokeFill(sliceTrigger, false, false, \"white\");\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setVisibility(sliceTrigger, false);\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setPointerEvent(sliceTrigger, true, false);\n    this.svgTrigger.appendChild(sliceTrigger);\n\n    //calculate slice trigger center.\n    let sliceTriggerCenter = _Util_Util__WEBPACK_IMPORTED_MODULE_1__[\"util\"].polarToCartesian(this.center[0], this.center[1], this.radiusForPie/2, (this.endAngle + this.startAngle)/2);\n\n    let pieSliceTriggerControl = new _Tip_Sub_PieSliceControl_PieSliceTriggerControl__WEBPACK_IMPORTED_MODULE_2__[\"PieSliceTriggerControl\"]();\n    pieSliceTriggerControl.enablePieSliceTrigger(sliceTrigger, sliceTriggerCenter, this.tipControl, this.seriesName, this.mcColor, this.dataY);\n};\n\n\n//# sourceURL=webpack:///./src/DataViewer/Sub/SingleSeriesViewer/SinglePieSeriesViewer/SinglePieSeriesViewer.js?");

/***/ }),

/***/ "./src/DataViewer/Sub/SingleSeriesViewer/SingleStackSeriesViewer.js":
/*!**************************************************************************!*\
  !*** ./src/DataViewer/Sub/SingleSeriesViewer/SingleStackSeriesViewer.js ***!
  \**************************************************************************/
/*! exports provided: SingleStackSeriesViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SingleStackSeriesViewer\", function() { return SingleStackSeriesViewer; });\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Draw/Draw */ \"./src/Draw/Draw.js\");\n/* harmony import */ var _SingleLineSeriesViewer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SingleLineSeriesViewer */ \"./src/DataViewer/Sub/SingleSeriesViewer/SingleLineSeriesViewer.js\");\n/* harmony import */ var _Draw_NodeDrawer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../Draw/NodeDrawer */ \"./src/Draw/NodeDrawer.js\");\n/* harmony import */ var _Tip_TriggerControl__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Tip/TriggerControl */ \"./src/DataViewer/Sub/Tip/TriggerControl.js\");\n/**\n * draws a single stack for a series in a stack chart\n * please reference `SingleLineSeriesViewer` for the meanings of the parameters.\n * @param htmlContainer\n * @param svg\n * @param svgTrigger\n * @param nodes\n * @param nodeShape\n * @param mcColor\n * @param isContinual\n * @param constantInterval\n * @param seriesName\n * @param tipControl\n * @param xDrawInfo\n * @param yDrawInfo\n * @param lineWidth             the width of the outline\n * @param isLinearGradient      does the stack's color uses linear gradient\n * @constructor\n */\n\n\n\n\n\nfunction SingleStackSeriesViewer(htmlContainer, svg, svgTrigger, nodes, nodeShape, mcColor,\n                                        isContinual, constantInterval/*if not regular is should be false, otherwise it should be the interval value*/,\n                                        seriesName, tipControl, xDrawInfo, yDrawInfo, lineWidth, isLinearGradient){\n    this.htmlContainer = htmlContainer; //if use the default inherited 'showTip' method then this field must be set.\n    this.svg = svg;\n    this.svgTrigger = svgTrigger;\n    this.nodes = nodes;\n    this.nodeShape = nodeShape;\n    this.mcColor = mcColor;\n    this.constantInterval = constantInterval;\n    this.isContinual = isContinual;\n    this.seriesName = seriesName;\n    this.xDrawInfo = xDrawInfo;\n    this.yDrawInfo = yDrawInfo;\n    this.lineWidth = lineWidth;\n    this.isLinearGradient = isLinearGradient;\n\n    this.svgLayerGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createGroup();\n    this.svgTriggerGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createGroup();\n    this.tipControl = tipControl;\n}\n\nSingleStackSeriesViewer.prototype = new _SingleLineSeriesViewer__WEBPACK_IMPORTED_MODULE_1__[\"SingleLineSeriesViewer\"]();\nSingleStackSeriesViewer.prototype.constructor = SingleStackSeriesViewer;\n\nSingleStackSeriesViewer.prototype.draw = function(){\n    this.svgLayerGroup.appendChild(this.drawStack());\n    this.svgLayerGroup.appendChild(this.drawLine());\n    this.drawLine();\n    this.drawNodes();\n    //call 'enable routine trance' before calling 'enable node trigger' so that the nodes trigger is laid above the routine trigger.\n    let highlightedNode = this.drawHighlightNode();\n    this.enableRoutineTrace(highlightedNode);\n    this.enableNodeTrigger(highlightedNode);\n    this.svg.appendChild(this.svgLayerGroup);\n    this.svgTrigger.appendChild(this.svgTriggerGroup);\n};\n\nSingleStackSeriesViewer.prototype.drawLine = function(){\n    let lines = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createStraightLines(this.nodes, 4, 0);\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setStrokeFill(lines, this.mcColor.strokeColor, this.lineWidth, \"none\");\n    return lines;\n};\n\nSingleStackSeriesViewer.prototype.drawStack = function(){\n    //draw the stack, minus 0.5 so that i does not cover up the x axis.\n    let rightBottom = [this.xDrawInfo.startPoint + this.xDrawInfo.length, this.yDrawInfo.startPoint - 0.5];\n    let leftBottom = [this.xDrawInfo.startPoint, this.yDrawInfo.startPoint - 0.5];\n    let stack = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createStackWithStraightLines(this.nodes, 4, 0, rightBottom, leftBottom);\n    if(this.isLinearGradient){\n        _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setStrokeFill(stack, false, false, this.mcColor.linearGradientFill);\n    } else {\n        _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setStrokeFill(stack, false, false, this.mcColor.fillColor);\n    }\n\n    return stack;\n};\n\nSingleStackSeriesViewer.prototype.enableNodeTrigger = function(){\n    if(this.isContinual) return;\n\n    //draw the highlighted node.\n    let highlightedNode = _Draw_NodeDrawer__WEBPACK_IMPORTED_MODULE_2__[\"nodeDrawer\"].drawHighlightedNode(this.nodeShape, this.mcColor);\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setVisibility(highlightedNode, false);\n    this.svgLayerGroup.appendChild(highlightedNode);\n\n    //draw all those node trigger zones.\n    let nodeMouseOverSectionGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createGroup();\n    for (let i = 0; i < this.nodes.length; i = i + 4) {\n        let nodeMouseOverSection = _Draw_NodeDrawer__WEBPACK_IMPORTED_MODULE_2__[\"nodeDrawer\"].drawTrigger(this.nodes[i], this.nodes[i + 1], i/4);\n        nodeMouseOverSectionGroup.appendChild(nodeMouseOverSection);\n    }\n    this.svgTriggerGroup.appendChild(nodeMouseOverSectionGroup);\n\n    //actually add listeners.\n    let triggerControl = new _Tip_TriggerControl__WEBPACK_IMPORTED_MODULE_3__[\"TriggerControl\"](this.tipControl, this.seriesName, this.mcColor);\n    triggerControl.enableNodeTrigger(nodeMouseOverSectionGroup, this.seriesName, this.mcColor, highlightedNode, this.nodes);\n\n};\n\n\nSingleStackSeriesViewer.prototype.enableRoutineTrace = function(){\n    let stackTrigger = this.drawStack();\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setStrokeFill(stackTrigger, false, false, \"rgb(0,0,0)\");\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setVisibility(stackTrigger, false);\n    stackTrigger.setAttributeNS(null, \"pointer-events\", \"fill\");\n    this.svgTriggerGroup.appendChild(stackTrigger);\n\n    //actually add listeners.\n    let triggerControl = new _Tip_TriggerControl__WEBPACK_IMPORTED_MODULE_3__[\"TriggerControl\"](this.tipControl, this.seriesName, this.mcColor);\n    triggerControl.enableRoutineTrace(this.htmlContainer, this.seriesName, this.mcColor, this.nodes, stackTrigger, this.constantInterval, this.xDrawInfo);\n};\n\n//# sourceURL=webpack:///./src/DataViewer/Sub/SingleSeriesViewer/SingleStackSeriesViewer.js?");

/***/ }),

/***/ "./src/DataViewer/Sub/SingleSeriesViewer/SingleTimeSeriesViewer.js":
/*!*************************************************************************!*\
  !*** ./src/DataViewer/Sub/SingleSeriesViewer/SingleTimeSeriesViewer.js ***!
  \*************************************************************************/
/*! exports provided: SingleTimeSeriesViewer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SingleTimeSeriesViewer\", function() { return SingleTimeSeriesViewer; });\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Draw/Draw */ \"./src/Draw/Draw.js\");\n/* harmony import */ var _SingleStackSeriesViewer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SingleStackSeriesViewer */ \"./src/DataViewer/Sub/SingleSeriesViewer/SingleStackSeriesViewer.js\");\n\n\n\n/**\n * draws a line for a single time series\n * please reference `SingleLineSeriesViewer` for the meanings of the parameters.\n * @param htmlContainer\n * @param svg\n * @param svgTrigger\n * @param nodes\n * @param nodeShape\n * @param mcColor\n * @param isContinual\n * @param constantInterval      if not regular is should be false, otherwise it should be the interval value\n * @param seriesName\n * @param tipControl\n * @param xDrawInfo\n * @param yDrawInfo\n * @param lineWidth             the width of the outline\n * @param isLinearGradient      does the stack's color uses linear gradient\n * @constructor\n */\nfunction SingleTimeSeriesViewer(htmlContainer, svg, svgTrigger, nodes, nodeShape, mcColor,\n                                 isContinual, constantInterval,\n                                 seriesName, tipControl, xDrawInfo, yDrawInfo, lineWidth, isLinearGradient){\n    this.htmlContainer = htmlContainer; //if use the default inherited 'showTip' method then this field must be set.\n    this.svg = svg;\n    this.svgTrigger = svgTrigger;\n    this.nodes = nodes;\n    this.nodeShape = nodeShape;\n    this.mcColor = mcColor;\n    this.constantInterval = constantInterval;\n    this.isContinual = isContinual;\n    this.seriesName = seriesName;\n    this.xDrawInfo = xDrawInfo;\n    this.yDrawInfo = yDrawInfo;\n    this.lineWidth = lineWidth;\n    this.isLinearGradient = isLinearGradient;\n\n    this.svgLayerGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createGroup();\n    this.svgTriggerGroup = _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createGroup();\n    this.tipControl = tipControl;\n}\n\nSingleTimeSeriesViewer.prototype = new _SingleStackSeriesViewer__WEBPACK_IMPORTED_MODULE_1__[\"SingleStackSeriesViewer\"]();\nSingleTimeSeriesViewer.prototype.constructor = SingleTimeSeriesViewer;\n\nSingleTimeSeriesViewer.prototype.drawHighlightNode = function(){\n    return null;\n};\n\n\n//# sourceURL=webpack:///./src/DataViewer/Sub/SingleSeriesViewer/SingleTimeSeriesViewer.js?");

/***/ }),

/***/ "./src/DataViewer/Sub/Tip/Sub/PieSliceControl/PieSliceTriggerControl.js":
/*!******************************************************************************!*\
  !*** ./src/DataViewer/Sub/Tip/Sub/PieSliceControl/PieSliceTriggerControl.js ***!
  \******************************************************************************/
/*! exports provided: PieSliceTriggerControl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PieSliceTriggerControl\", function() { return PieSliceTriggerControl; });\n/**\n * this tool tip control manages the tool tip for a series in a pie chart.\n * @constructor\n */\nfunction PieSliceTriggerControl(){}\n\nPieSliceTriggerControl.prototype.enablePieSliceTrigger = function(trigger, triggerCenter, tipControl, seriesName, mcColor, dataY){\n    trigger.addEventListener(\"mouseover\", function(){\n        tipControl.genericShowTip(triggerCenter[0], triggerCenter[1], seriesName, mcColor, 0, dataY);\n    });\n\n    trigger.addEventListener(\"mouseout\", function(){\n        tipControl.hideTip();\n    });\n};\n\n//# sourceURL=webpack:///./src/DataViewer/Sub/Tip/Sub/PieSliceControl/PieSliceTriggerControl.js?");

/***/ }),

/***/ "./src/DataViewer/Sub/Tip/Sub/SharedControl/SharedSeriesInfo.js":
/*!**********************************************************************!*\
  !*** ./src/DataViewer/Sub/Tip/Sub/SharedControl/SharedSeriesInfo.js ***!
  \**********************************************************************/
/*! exports provided: SharedSeriesInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SharedSeriesInfo\", function() { return SharedSeriesInfo; });\n/**\n * this class is mainly used by `SharedTipControl`, it contains necessary information to draw a shared tool tip.\n * @constructor\n */\nfunction SharedSeriesInfo(){\n    this.multipleSeries = [];\n}\n\nSharedSeriesInfo.prototype.registerSingleSeries = function(seriesName, mcColor, highlightedNode, nodes){\n    let a = new Array(4);\n    a[0] = seriesName;\n    a[1] = mcColor;\n    a[2] = highlightedNode;\n    a[3] = nodes;\n    this.multipleSeries.push(a);\n    return this.multipleSeries.length - 1;\n};\n\nSharedSeriesInfo.prototype.getSeriesName = function(seriesIdx){\n    return this.multipleSeries[seriesIdx][0];\n};\n\nSharedSeriesInfo.prototype.getSeriesMCcolor = function(seriesIdx){\n    return this.multipleSeries[seriesIdx][1];\n};\n\nSharedSeriesInfo.prototype.getHighlightedNode = function(seriesIdx){\n    return this.multipleSeries[seriesIdx][2];\n};\n\nSharedSeriesInfo.prototype.getDataX = function(seriesIdx, nodesStrideIdx){\n    //since all series will have the same dataX when the idx is specified, i will just get it from the first series.\n    return this.multipleSeries[seriesIdx][3][nodesStrideIdx * 4 + 2];\n};\n\nSharedSeriesInfo.prototype.getDataY = function(seriesIdx, nodesStrideIdx){\n    return this.multipleSeries[seriesIdx][3][nodesStrideIdx * 4 + 3];\n};\n\nSharedSeriesInfo.prototype.getPixelX = function(seriesIdx, nodesStrideIdx){\n    return this.multipleSeries[seriesIdx][3][nodesStrideIdx * 4];\n};\n\nSharedSeriesInfo.prototype.getPixelY = function(seriesIdx, nodesStrideIdx){\n    return this.multipleSeries[seriesIdx][3][nodesStrideIdx * 4 + 1];\n};\n\nSharedSeriesInfo.prototype.reverse = function(){\n    this.multipleSeries.reverse();\n};\n\n//# sourceURL=webpack:///./src/DataViewer/Sub/Tip/Sub/SharedControl/SharedSeriesInfo.js?");

/***/ }),

/***/ "./src/DataViewer/Sub/Tip/Sub/SharedControl/SharedTipControl.js":
/*!**********************************************************************!*\
  !*** ./src/DataViewer/Sub/Tip/Sub/SharedControl/SharedTipControl.js ***!
  \**********************************************************************/
/*! exports provided: SharedTipControl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SharedTipControl\", function() { return SharedTipControl; });\n/* harmony import */ var _SharedSeriesInfo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SharedSeriesInfo */ \"./src/DataViewer/Sub/Tip/Sub/SharedControl/SharedSeriesInfo.js\");\n/* harmony import */ var _TipControl__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../TipControl */ \"./src/DataViewer/Sub/Tip/TipControl.js\");\n/**\n * a tool tip shared by multiple series. mainly used in stack chart.\n * please reference `TipControl` for the meaning of the parameters\n * @param htmlContainer\n * @param topShift\n * @constructor\n */\n\n\n\nfunction SharedTipControl(htmlContainer, topShift){\n    this.htmlContainer = htmlContainer;\n    this.topShift = topShift;\n    this.isSingleLine = false; //since it is shared, there are multiple series that need to display themselves.\n    this.sharedSeriesInfo = new _SharedSeriesInfo__WEBPACK_IMPORTED_MODULE_0__[\"SharedSeriesInfo\"]();\n}\n\nSharedTipControl.prototype = new _TipControl__WEBPACK_IMPORTED_MODULE_1__[\"TipControl\"]();\nSharedTipControl.prototype.constructor = SharedTipControl;\n\n/**\n *\n * @param seriesNames an array.\n */\nSharedTipControl.prototype.createTip = function(seriesNames){\n    function funcCreateHtmlSingleLineTipStructure(tip){\n        //is never going to be called.\n    }\n\n    function funcCreateHtmlMultipleLineTipStructure(tip){\n        let dataXslot = document.createTextNode(\"null\")\n        tip.appendChild(dataXslot);//slot for x axis value.\n        tip.ws_dataXslot = dataXslot;\n        tip.ws_dataYslots = [];\n        for(let i = 0; i < seriesNames.length; i++){\n            let div = document.createElement(\"div\");\n            tip.appendChild(div);\n            let seriesNameSpan = document.createElement(\"span\");\n            div.appendChild(seriesNameSpan);\n            seriesNameSpan.appendChild(document.createTextNode(seriesNames[i]));\n            div.appendChild(document.createTextNode(\" -- \"));\n            let dataSpan = document.createElement(\"span\");\n            div.appendChild(dataSpan);\n            let dataYslot= document.createTextNode(\"null\");\n            dataSpan.appendChild(dataYslot);\n            tip.ws_dataYslots.push(dataYslot);\n        }\n    }\n\n    _TipControl__WEBPACK_IMPORTED_MODULE_1__[\"TipControl\"].prototype.createTip.call(this, funcCreateHtmlSingleLineTipStructure, funcCreateHtmlMultipleLineTipStructure);\n};\n\nSharedTipControl.prototype.showSingleLineTip = function () {\n    //never going to get called.\n};\n\nSharedTipControl.prototype.showDoubleLineTip = function(pixelX, pixelY, sharedSeriesInfoRegisterIdx, nodesStrideIdx){\n    //change the text.\n    let mcColor = this.sharedSeriesInfo.getSeriesMCcolor(sharedSeriesInfoRegisterIdx);\n    let dataX = this.sharedSeriesInfo.getDataX(sharedSeriesInfoRegisterIdx, nodesStrideIdx);\n\n    this.tip.ws_dataXslot.nodeValue = dataX;\n\n    for (let i = 0; i < this.tip.ws_dataYslots.length; i++){\n        this.tip.ws_dataYslots[i].nodeValue = this.sharedSeriesInfo.getDataY(i, nodesStrideIdx);\n    }\n\n    this.applyTranslationAndColor(pixelX, pixelY, mcColor);\n};\n\n//# sourceURL=webpack:///./src/DataViewer/Sub/Tip/Sub/SharedControl/SharedTipControl.js?");

/***/ }),

/***/ "./src/DataViewer/Sub/Tip/Sub/StaticControl/StaticTipControl.js":
/*!**********************************************************************!*\
  !*** ./src/DataViewer/Sub/Tip/Sub/StaticControl/StaticTipControl.js ***!
  \**********************************************************************/
/*! exports provided: StaticTipControl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"StaticTipControl\", function() { return StaticTipControl; });\n/* harmony import */ var _TipControl__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../TipControl */ \"./src/DataViewer/Sub/Tip/TipControl.js\");\n/**\n * manages static tool tips. please reference `TipControl` for the meaning of the parameters\n * @param htmlContainer\n * @param topShift\n * @param isSingleLine\n * @constructor\n */\n\n\nfunction StaticTipControl(htmlContainer, topShift, isSingleLine){\n    this.htmlContainer = htmlContainer;\n    this.topShift = topShift;\n    this.isSingleLine = isSingleLine;\n}\n\nStaticTipControl.prototype = new _TipControl__WEBPACK_IMPORTED_MODULE_0__[\"TipControl\"]();\nStaticTipControl.prototype.constructor = StaticTipControl;\n\nStaticTipControl.prototype.createTip = function (funcCreateHtmlSingleLineTipStructure, funcCreateHtmlMultipleLineTipStructure) {\n    //draw the tip at origin 0 0 and do the top shift.\n    let tip = document.createElement(\"div\");\n    this.tip = tip;\n\n    if(this.isSingleLine){\n        if(funcCreateHtmlSingleLineTipStructure !== null && funcCreateHtmlSingleLineTipStructure !== undefined){\n            funcCreateHtmlSingleLineTipStructure(tip);\n        } else {\n            let seriesNameSpan = document.createElement(\"span\");\n            tip.appendChild(seriesNameSpan);\n            seriesNameSpan.appendChild(document.createTextNode(\"null\"));\n            tip.appendChild(document.createTextNode(\" -- \"));\n            let dataSpan = document.createElement(\"span\");\n            tip.appendChild(dataSpan);\n            dataSpan.appendChild(document.createTextNode(\"null\"));\n        }\n\n    } else {\n        if(funcCreateHtmlMultipleLineTipStructure !== null && funcCreateHtmlMultipleLineTipStructure !== undefined){\n            funcCreateHtmlMultipleLineTipStructure(tip);\n        } else {\n            tip.appendChild(document.createTextNode(\"null\"));//slot for series name\n            tip.appendChild(document.createElement(\"br\"));\n            tip.appendChild(document.createTextNode(\"null\")); //slot for data.\n        }\n    }\n\n    tip.setAttribute(\"class\", \"mc-tip\");\n\n    //after appending the div to document I can then safely call getBoundingClientRect\n    this.htmlContainer.appendChild(tip);\n    let bcr = tip.getBoundingClientRect();\n    tip.style.marginTop = (-bcr.height - 2 - this.topShift) + \"px\";\n    tip.style.borderColor = \"black\";\n    tip.style.display = \"none\";\n//    tip.style.webkitTransitionDuration = \"0.3s\";\n//    tip.style.MozTransitionDuration = \"0.3s\";\n//    tip.style.transitionDuration = \"0.3s\";\n};\n\nStaticTipControl.prototype.applyTranslationAndColor = function(pixelX, pixelY, mcColor){\n    this.tip.style.display = \"inline-block\";\n\n    let bcr = this.tip.getBoundingClientRect();\n    let translate = \"translate(\" + (pixelX - bcr.width/2) + \"px, \" + pixelY + \"px)\";\n    this.tip.style.MozTransform = translate;\n    this.tip.style.webkitTransform = translate;\n    this.tip.style.msTransform = translate;\n    this.tip.style.transform = translate;\n\n    this.tip.style.borderColor = mcColor.strokeColor;\n};\n\nStaticTipControl.prototype.hideTip = function () {\n    this.hideTipImmediately();\n};\n\nStaticTipControl.prototype.hideTipImmediately = function(){\n    this.tip.style.display = \"none\";\n};\n\n//# sourceURL=webpack:///./src/DataViewer/Sub/Tip/Sub/StaticControl/StaticTipControl.js?");

/***/ }),

/***/ "./src/DataViewer/Sub/Tip/TipControl.js":
/*!**********************************************!*\
  !*** ./src/DataViewer/Sub/Tip/TipControl.js ***!
  \**********************************************/
/*! exports provided: TipControl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TipControl\", function() { return TipControl; });\n/* harmony import */ var _Sub_SharedControl_SharedSeriesInfo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Sub/SharedControl/SharedSeriesInfo */ \"./src/DataViewer/Sub/Tip/Sub/SharedControl/SharedSeriesInfo.js\");\n/**\n * this class is responsible for creating and managing all the tool tips\n * @param htmlContainer     the html container to which the tool tips will be appended\n * @param topShift          how much do we want to shift the tooltip upwards\n * @param isSingleLine      if tool tip content contains only a single line.\n * @constructor\n */\n\n\nfunction TipControl(htmlContainer, topShift, isSingleLine){\n    this.tip = null;\n    this.hideTipTimeout = 0;\n    this.isShown = false;\n    this.isSingleLine= isSingleLine;\n    this.htmlContainer = htmlContainer;\n    this.topShift = topShift;\n    this.sharedSeriesInfo = new _Sub_SharedControl_SharedSeriesInfo__WEBPACK_IMPORTED_MODULE_0__[\"SharedSeriesInfo\"]();\n}\n\n/**\n * create the tip (html element) and configure its style properly\n * @param funcCreateHtmlSingleLineTipStructure      accepts a parameter (which is a div) and inserts html elements inside this div to form a tip template. If null or undefined then the method will use its default setting.\n * @param funcCreateHtmlMultipleLineTipStructure     accepts a parameter (which is a div) and inserts html elements inside this div to form a tip template. If null or undefined then the method will use its default setting.\n */\nTipControl.prototype.createTip = function (funcCreateHtmlSingleLineTipStructure, funcCreateHtmlMultipleLineTipStructure) {\n    //draw the tip at origin 0 0 and do the top shift.\n    let tip = document.createElement(\"div\");\n    this.tip = tip;\n\n    if(this.isSingleLine){\n        if(funcCreateHtmlSingleLineTipStructure !== null && funcCreateHtmlSingleLineTipStructure !== undefined){\n            funcCreateHtmlSingleLineTipStructure(tip);\n        } else {\n            let seriesNameSpan = document.createElement(\"span\");\n            tip.appendChild(seriesNameSpan);\n            seriesNameSpan.appendChild(document.createTextNode(\"null\"));\n            tip.appendChild(document.createTextNode(\" -- \"));\n            let dataSpan = document.createElement(\"span\");\n            tip.appendChild(dataSpan);\n            dataSpan.appendChild(document.createTextNode(\"null\"));\n        }\n\n    } else {\n        if(funcCreateHtmlMultipleLineTipStructure !== null && funcCreateHtmlMultipleLineTipStructure !== undefined){\n            funcCreateHtmlMultipleLineTipStructure(tip);\n        } else {\n            tip.appendChild(document.createTextNode(\"null\"));//slot for series name\n            tip.appendChild(document.createElement(\"br\"));\n            tip.appendChild(document.createTextNode(\"null\")); //slot for data.\n        }\n    }\n\n    tip.setAttribute(\"class\", \"mc-tip\");\n\n    //after appending the div to document I can then safely call getBoundingClientRect\n    this.htmlContainer.appendChild(tip);\n    let bcr = tip.getBoundingClientRect();\n    tip.style.marginTop = (-bcr.height - 2 - this.topShift) + \"px\";\n    tip.style.borderColor = \"black\";\n    tip.style.display = \"none\";\n    tip.style.webkitTransitionDuration = \"0.3s\";\n    tip.style.MozTransitionDuration = \"0.3s\";\n    tip.style.transitionDuration = \"0.3s\";\n};\n\n\nTipControl.prototype.showTip = function(pixelX, pixelY, sharedSeriesInfoRegisterIdx, nodesStrideIdx){\n    if(this.isSingleLine){\n        this.showSingleLineTip(pixelX, pixelY, sharedSeriesInfoRegisterIdx, nodesStrideIdx);\n    } else {\n        this.showDoubleLineTip(pixelX, pixelY, sharedSeriesInfoRegisterIdx, nodesStrideIdx);\n    }\n};\n\nTipControl.prototype.showSingleLineTip = function (pixelX, pixelY, sharedSeriesInfoRegisterIdx, nodesStrideIdx) {\n    //change the text.\n    let seriesName = this.sharedSeriesInfo.getSeriesName(sharedSeriesInfoRegisterIdx);\n    let mcColor = this.sharedSeriesInfo.getSeriesMCcolor(sharedSeriesInfoRegisterIdx);\n    let dataY = this.sharedSeriesInfo.getDataY(sharedSeriesInfoRegisterIdx, nodesStrideIdx);\n\n    this.genericShowTip(pixelX, pixelY, seriesName, mcColor, 0, dataY);\n};\n\nTipControl.prototype.showDoubleLineTip = function(pixelX, pixelY, sharedSeriesInfoRegisterIdx, nodesStrideIdx){\n    //change the text.\n    let seriesName = this.sharedSeriesInfo.getSeriesName(sharedSeriesInfoRegisterIdx);\n    let mcColor = this.sharedSeriesInfo.getSeriesMCcolor(sharedSeriesInfoRegisterIdx);\n    let dataX = this.sharedSeriesInfo.getDataX(sharedSeriesInfoRegisterIdx, nodesStrideIdx);\n    let dataY = this.sharedSeriesInfo.getDataY(sharedSeriesInfoRegisterIdx, nodesStrideIdx);\n\n    this.genericShowDoubleLineTip(pixelX, pixelY, seriesName, mcColor, dataX, dataY);\n};\n\nTipControl.prototype.genericShowTip = function(pixelX, pixelY, seriesName, mcColor, dataX, dataY){\n    if(this.isSingleLine){\n        this.genericShowSingleLineTip(pixelX, pixelY, seriesName, mcColor, dataY);\n    } else {\n        this.genericShowDoubleLineTip(pixelX, pixelY, seriesName, mcColor, dataX, dataY);\n    }\n};\n\nTipControl.prototype.genericShowSingleLineTip = function(pixelX, pixelY, seriesName, mcColor, dataY){\n    this.tip.childNodes[0].childNodes[0].nodeValue = seriesName;\n    this.tip.childNodes[2].childNodes[0].nodeValue = dataY;\n    this.applyTranslationAndColor(pixelX, pixelY, mcColor);\n};\n\nTipControl.prototype.genericShowDoubleLineTip = function(pixelX, pixelY, seriesName, mcColor, dataX, dataY){\n    this.tip.childNodes[0].nodeValue = seriesName;\n    this.tip.childNodes[2].nodeValue = dataX + \" -- \" + dataY;\n    this.applyTranslationAndColor(pixelX, pixelY, mcColor);\n};\n\nTipControl.prototype.genericShowDoubleLineTipDataYOnly = function(pixelX, pixelY, seriesName, mcColor, dataY){\n    this.tip.childNodes[0].nodeValue = seriesName;\n    this.tip.childNodes[2].nodeValue = dataY;\n    this.applyTranslationAndColor(pixelX, pixelY, mcColor);\n};\n\nTipControl.prototype.applyTranslationAndColor = function(pixelX, pixelY, mcColor){\n    //clear hideTip.\n    if(this.hideTipTimeout !== 0){\n        window.clearTimeout(this.hideTipTimeout);\n    }\n\n    if(!this.isShown){\n        this.isShown = true;\n        this.tip.style.webkitTransitionProperty = \"none\";\n        this.tip.style.MozTransitionProperty = \"none\";\n        this.tip.style.transitionProperty = \"none\";\n        this.tip.style.display = \"inline-block\";\n    } else {\n        this.tip.style.webkitTransitionProperty = \"-webkit-transform\";\n        this.tip.style.MozTransitionProperty = \"-moz-transform\";\n        this.tip.style.transitionProperty = \"transform\";\n    }\n\n    let bcr = this.tip.getBoundingClientRect();\n    let translate = \"translate(\" + (pixelX - bcr.width/2) + \"px, \" + pixelY + \"px)\";\n    this.tip.style.MozTransform = translate;\n    this.tip.style.webkitTransform = translate;\n    this.tip.style.msTransform = translate;\n    this.tip.style.transform = translate;\n\n\n    this.tip.style.borderColor = mcColor.strokeColor;\n};\n\nTipControl.prototype.hideTip = function () {\n    let _this = this;\n\n    if(this.hideTipTimeout !== 0){\n        window.clearTimeout(this.hideTipTimeout);\n    }\n\n    this.hideTipTimeout = window.setTimeout(function(){\n       _this.isShown = false;\n       _this.tip.style.display = \"none\";\n       _this.hideTipTimeout = 0;\n    }, 1000);\n};\n\nTipControl.prototype.hideTipImmediately = function(){\n    if(this.hideTipTimeout !== 0){\n        window.clearTimeout(this.hideTipTimeout);\n    }\n\n    this.isShown = false;\n    this.tip.style.display = \"none\";\n    this.hideTipTimeout = 0;\n};\n\n\n\n//# sourceURL=webpack:///./src/DataViewer/Sub/Tip/TipControl.js?");

/***/ }),

/***/ "./src/DataViewer/Sub/Tip/TriggerControl.js":
/*!**************************************************!*\
  !*** ./src/DataViewer/Sub/Tip/TriggerControl.js ***!
  \**************************************************/
/*! exports provided: TriggerControl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TriggerControl\", function() { return TriggerControl; });\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../Draw/Draw */ \"./src/Draw/Draw.js\");\n/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../Util/Util */ \"./src/Util/Util.js\");\n/**\n * this class is used to enable the tool tips. it mainly adds various of event listeners. these\n * listeners use tip control to display / move / style / hide the tool tips.\n * @param tipControl        tip control\n * @param seriesName        name of the series\n * @param mcColor           color of the tool tip\n * @constructor\n */\n\n\n\nfunction TriggerControl(tipControl, seriesName, mcColor){\n    this.tipControl = tipControl;\n    this.seriesName = seriesName;\n    this.mcColor = mcColor;\n    this.sharedSeriesInfo = this.tipControl.sharedSeriesInfo;\n}\n\n/**\n * enable tool tip for a column\n * @param columnTrigger\n * @param htmlContainer\n * @param seriesName\n * @param mcColor\n * @param nodes\n */\nTriggerControl.prototype.enableColumnTrigger = function(columnTrigger, htmlContainer, seriesName, mcColor, nodes){\n    let _this = this;\n    //register this thing first.\n    let sharedSeriesInfo = this.sharedSeriesInfo;\n    let sharedSeriesInfoRegisterIdx = sharedSeriesInfo.registerSingleSeries(seriesName, mcColor, null, nodes);\n\n    columnTrigger.addEventListener(\"mouseover\", function(event){\n        let pixelX = _this.sharedSeriesInfo.getPixelX(sharedSeriesInfoRegisterIdx, 0);\n        let pixelY = event.clientY - htmlContainer.getBoundingClientRect().top;\n        _this.tipControl.showTip(pixelX, pixelY, sharedSeriesInfoRegisterIdx, 0);\n        event.stopPropagation();\n    });\n\n    columnTrigger.addEventListener(\"mouseout\", function(event){\n        _this.tipControl.hideTip();\n        event.stopPropagation();\n    });\n};\n\n/**\n * This method requires the target has the following property:\n * 1. ws_nodesStrideIdx\n * @param nodeMouseOverSectionGroup     but really it can be of any shape, a column, a node\n * @param seriesName\n * @param mcColor\n * @param highlightedNode               this method activates(translates it into proper position and show it) this 'highlightedNode'.\n * @param nodes\n */\nTriggerControl.prototype.enableNodeTrigger = function(nodeMouseOverSectionGroup, seriesName, mcColor, highlightedNode, nodes){\n    //register this thing first.\n    let sharedSeriesInfo = this.sharedSeriesInfo;\n    let sharedSeriesInfoRegisterIdx = sharedSeriesInfo.registerSingleSeries(seriesName, mcColor, highlightedNode, nodes);\n    let _this = this;\n\n    let isShown = false; //set the flag yeah.\n    function highlightNode(pixelX, pixelY) {\n        if (!isShown) {\n            _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setVisibility(highlightedNode, true);\n            isShown = true;\n        }\n        _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].translate(highlightedNode, pixelX, pixelY);\n    }\n\n    function deHighlightNode() {\n       if (isShown) {\n           _Draw_Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setVisibility(highlightedNode, false);\n           isShown = false;\n       }\n    }\n    nodeMouseOverSectionGroup.addEventListener(\"mouseover\", function (event) {\n        let pixelX = sharedSeriesInfo.getPixelX(sharedSeriesInfoRegisterIdx, event.target.ws_nodesStrideIdx);\n        let pixelY = sharedSeriesInfo.getPixelY(sharedSeriesInfoRegisterIdx, event.target.ws_nodesStrideIdx);\n        highlightNode(pixelX, pixelY);\n        _this.tipControl.showTip(pixelX, pixelY, sharedSeriesInfoRegisterIdx, event.target.ws_nodesStrideIdx);\n        event.stopPropagation();\n    });\n\n    nodeMouseOverSectionGroup.addEventListener(\"mouseout\", function (event) {\n        deHighlightNode();\n        _this.tipControl.hideTip();\n        event.stopPropagation();\n    });\n\n};\n\n/**\n * enable tool tip for a routine (ie. a line, most likely not straight )\n * @param htmlContainer     to which we will append the tool tip element\n * @param seriesName\n * @param mcColor\n * @param nodes\n * @param routineGroup\n * @param constantInterval\n * @param xDrawInfo\n */\nTriggerControl.prototype.enableRoutineTrace = function(htmlContainer, seriesName, mcColor, nodes, routineGroup, constantInterval, xDrawInfo){\n    //register this thing first.\n    let sharedSeriesInfo = this.sharedSeriesInfo;\n    let sharedSeriesInfoRegisterIdx = sharedSeriesInfo.registerSingleSeries(seriesName, mcColor, null, nodes);\n\n    let _this = this;\n    let previousIdx = -1; //this idex is the stride idx. and stride idx happens to be the same of dataXarray idx.\n    let mouseX = 0;\n    let traceIntervalId = 0;\n\n    //this handler has different definitions based on whether the data has constant data interval or irregular data interval\n    let findAndHighLight;\n\n    if(constantInterval !== false){\n        findAndHighLight = function(){\n            let mouseXinSVGcoordinates = mouseX - htmlContainer.getBoundingClientRect().left;\n            let estimatedDataX = (mouseXinSVGcoordinates - xDrawInfo.startPoint)/xDrawInfo.pixelPerData + xDrawInfo.min;\n            let strideIdx = Math.round((estimatedDataX - xDrawInfo.min)/constantInterval);\n            if(strideIdx!==previousIdx){\n                previousIdx = strideIdx;\n                let pixelX = _this.sharedSeriesInfo.getPixelX(sharedSeriesInfoRegisterIdx, strideIdx);\n                let pixelY = _this.sharedSeriesInfo.getPixelY(sharedSeriesInfoRegisterIdx, strideIdx);\n//                highlightNode(pixelX, pixelY);\n                _this.tipControl.showTip(pixelX, pixelY, sharedSeriesInfoRegisterIdx, strideIdx);\n            }\n        };\n    } else {\n        //extract the dataX and make it a standalone array where stride is 1 and offset is 0.\n        let dataXarray = [];\n        for(let i = 0; i < nodes.length; i = i + 4){\n            dataXarray.push(nodes[i + 2]); //offset is 2.\n        }\n\n        findAndHighLight = function(){\n            let mouseXinSVGcoordinates = mouseX - htmlContainer.getBoundingClientRect().left;\n            let estimatedDataX = (mouseXinSVGcoordinates - xDrawInfo.startPoint)/xDrawInfo.pixelPerData + xDrawInfo.min;\n\n            //binary search, find the nearest node.\n            let strideIdx = _Util_Util__WEBPACK_IMPORTED_MODULE_1__[\"util\"].findElementIdxUsingBinarySearch(dataXarray, estimatedDataX); //the returned strideIdx is of dataXarray\n            if(strideIdx !== previousIdx) {\n                previousIdx = strideIdx;\n                let pixelX = _this.sharedSeriesInfo.getPixelX(sharedSeriesInfoRegisterIdx, strideIdx);\n                let pixelY = _this.sharedSeriesInfo.getPixelY(sharedSeriesInfoRegisterIdx, strideIdx);\n//                highlightedNode(pixelX, pixelY);\n                _this.tipControl.showTip(pixelX, pixelY, sharedSeriesInfoRegisterIdx, strideIdx);\n            }\n        };\n    }\n\n    //the mouse move event might be trigger like 280+ times per second.\n    routineGroup.addEventListener(\"mousemove\",  function(event){\n        mouseX = event.clientX;\n    });\n\n    //but we will only do checking 5 times per second since finding the right element is computational stressful.\n    routineGroup.addEventListener(\"mouseover\",  function(event){\n        //reset the previousIdx. I need to do this because if the found idx is the same as the previous idx the tip won't show up.\n        previousIdx = -1;\n        //update the mouse position and show the tip anyway.\n        mouseX = event.clientX;\n        findAndHighLight();\n\n        //now set an interval and constantly check if the mouse move to another node.\n        traceIntervalId = window.setInterval(findAndHighLight, 200);\n    });\n\n    routineGroup.addEventListener(\"mouseout\",  function(){\n        window.clearInterval(traceIntervalId);\n//        deHighlightNode();\n        _this.tipControl.hideTip();\n    });\n};\n\n//# sourceURL=webpack:///./src/DataViewer/Sub/Tip/TriggerControl.js?");

/***/ }),

/***/ "./src/Draw/Color.js":
/*!***************************!*\
  !*** ./src/Draw/Color.js ***!
  \***************************/
/*! exports provided: colors */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"colors\", function() { return colors; });\n/* harmony import */ var _Draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Draw */ \"./src/Draw/Draw.js\");\n/**\n * utility class for colors. we will be only using certain colors in this library, and all of them should be defined\n * here.\n */\n\n\nconst colors = {\n    blue: {\n        strokeColor: \"rgb(0, 122, 204)\",\n        fillColor: \"rgb(0, 153, 255)\",\n        linearGradientId:\"linear-gradient-blue\",\n        linearGradientFill: \"url(#linear-gradient-blue)\"\n    },\n\n    purple: {\n        strokeColor: \"rgb(82, 0, 163)\",\n        fillColor: \"rgb(102, 0, 204)\",\n        linearGradientId: \"linear-gradient-purple\",\n        linearGradientFill: \"url(#linear-gradient-purple)\"\n    },\n\n    lightBlue: {\n        strokeColor: \"rgb(52, 147, 184)\",\n        fillColor: \"rgb(62, 195, 246)\",\n        linearGradientId: \"linear-gradient-lightBlue\",\n        linearGradientFill: \"url(#linear-gradient-lightBlue)\"\n    },\n\n    green: {\n        strokeColor: \"rgb(0, 163, 122)\",\n        fillColor: \"rgb(0, 204, 153)\",\n        linearGradientId:\"linear-gradient-green\",\n        linearGradientFill: \"url(#linear-gradient-green)\"\n    },\n\n    darkGreen: {\n        strokeColor: \"rgb(35, 156, 97)\",\n            fillColor: \"rgb(0, 180, 94)\",\n            linearGradientId:\"linear-gradient-darkGreen\",\n            linearGradientFill: \"url(#linear-gradient-darkGreen)\"\n    },\n\n    red: {\n        strokeColor: \"rgb(173, 32, 0)\",\n        fillColor: \"rgb(255, 87, 45)\",\n        linearGradientId:\"linear-gradient-red\",\n        linearGradientFill: \"url(#linear-gradient-red)\"\n    },\n\n    yellow: {\n        strokeColor: \"rgb(163, 122, 0)\",\n        fillColor: \"rgb(204, 153, 0)\",\n        linearGradientId:\"linear-gradient-yellow\",\n        linearGradientFill: \"url(#linear-gradient-yellow)\"\n    },\n\n    /**\n     * creates all the gradients, which we will be using extensively in drawing all kinds of charts\n     * @param svg   the svg element. all the gradients definitions will be appended to this svg element.\n     */\n    initLinearGradients: function(svg){\n        /**\n         * well, here is an sample. here is basically the transition of colors starts (using the target element as coordinate system)\n         * at 0,0 and goes to 0,1. This means its a vertical transition\n         * <linearGradient x1=\"0\" y1=\"0\" x2=\"0\" y2=\"1\" id=\"highcharts-4\">\n         *     <stop offset=\"0\" stop-color=\"#7cb5ec\" stop-opacity=\"1\"></stop>\n         *     <stop offset=\"1\" stop-color=\"rgb(124,181,236)\" stop-opacity=\"0\"></stop>\n         * </linearGradient>\n         */\n        let defs = _Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createDefs();\n\n        createLinearGradient(this.blue);\n        createLinearGradient(this.purple);\n        createLinearGradient(this.red);\n        createLinearGradient(this.lightBlue);\n        createLinearGradient(this.green);\n        createLinearGradient(this.darkGreen);\n        createLinearGradient(this.yellow);\n\n        svg.appendChild(defs);\n\n        function createLinearGradient(mcColor){\n            let lg = _Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createLinearGradient([\"0%\", \"0%\"], [\"0%\", \"100%\"]);\n            _Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].addLinearGradientStop(lg, \"0\", mcColor.fillColor, \"1\");\n            _Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].addLinearGradientStop(lg, \"1\", mcColor.fillColor, \"0\");\n            _Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setId(lg, mcColor.linearGradientId);\n            defs.appendChild(lg);\n        }\n    },\n\n    /**\n     * converts a rgb color like rgb(213, 231, 100) to an webgl format, which is basically an array\n     * of three elements: red, green and blue.\n     * @param rgb\n     * @returns {string[]}      the webgl color format\n     */\n    convertToWebGLcolorArray: function(rgb){\n        let rgbComponents = rgb.substring(4, rgb.length-1)\n            .replace(/ /g, '')\n            .split(',');\n        rgbComponents[0] = +(rgbComponents[0]) / 255;\n        rgbComponents[1] = +(rgbComponents[1]) / 255;\n        rgbComponents[2] = +(rgbComponents[2]) / 255;\n        return rgbComponents;\n    }\n};\n\n//# sourceURL=webpack:///./src/Draw/Color.js?");

/***/ }),

/***/ "./src/Draw/Draw.js":
/*!**************************!*\
  !*** ./src/Draw/Draw.js ***!
  \**************************/
/*! exports provided: draw */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"draw\", function() { return draw; });\n/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Util/Util */ \"./src/Util/Util.js\");\n/**\n * offer fundamental methods to create svg elements, including groups, defs, shapes(like circles)\n * offer fundamental methods to style an svg element\n */\n\n\nconst draw = {\n    xml_namespace: \"http://www.w3.org/2000/svg\",\n\n    /*\n    ####### create tags ########\n    */\n    /**\n     * Creates an path a path svg element\n     *\n     * @param coordinatesAndCommands    the d attribute value.\n     * @returns {SVGPathElement}   the path created\n     */\n    createPath: function(coordinatesAndCommands){\n        //path sample: <path d=\"M150 0 L75 200 L225 200 Z\" />\n        let path = document.createElementNS(this.xml_namespace, \"path\");\n        path.setAttributeNS(null, \"d\", coordinatesAndCommands);\n        return path;\n    },\n\n    /**\n     * create a path composed by only straight lines.\n     *\n     * @param coordinates       an array that contains information of coordinates. However, this array may also contain information of other stuffs.\n     * @param stride            stride....see offset for more explanation.\n     * @param offset            Example: if the stride is 4 and the offset is 1, then it means in each 4 elements, the 2nd element will be x, and the 3rd\n     *                          will be y.\n     * @returns {SVGPathElement}   the path created.\n     */\n    createStraightLines: function(coordinates, stride, offset){\n        let d = \"M\" + coordinates[offset] + \" \" + coordinates[offset + 1];\n        for(let i = stride; i < coordinates.length; i = i + stride){\n            d = d + \" \" + coordinates[i] + \" \" + coordinates[i + 1];\n        }\n        return this.createPath(d);\n    },\n\n    /**\n     * this creates something like this. the coordinates creates the the line that sits on the top.\n     * this is mainly useful for stack charts.\n     *\n     *       __    /|\n     *      /  \\__/ |\n     *      |       |\n     *      |_______|\n     * left bottom  right bottom\n     * corner       corner\n     *\n     * @param coordinates   we use the coordinates to draw the top line\n     * @param stride        see `createStraightLines` for more explanation\n     * @param offset        see `createStraightLines` for more explanation\n     * @param leftBottomCorner  the left bottom corner of the stack\n     * @param rightBottomCorner the right bottom corner of the stack\n     *\n     * @return {SVGPathElement} the stack created.\n     */\n    createStackWithStraightLines: function(coordinates, stride, offset, rightBottomCorner, leftBottomCorner){\n        let d = \"M\" + coordinates[offset] + \" \" + coordinates[offset + 1];\n        for(let i = stride; i < coordinates.length; i = i + stride){\n            d = d + \" \" + coordinates[i] + \" \" + coordinates[i + 1];\n        }\n        d = d + \" \" + rightBottomCorner[0] + \" \" + rightBottomCorner[1] + \" \" + leftBottomCorner[0] + \" \" + leftBottomCorner[1] + \" \" + \"Z\";\n        return this.createPath(d);\n    },\n\n    /**\n     * creates a quadratic bezier curve\n     * @param coordinates the coordinates of the bezier curve. the first coordinate is the start, the second one is the \"curve point\",\n     * the last one specifies the end of the curve\n     *\n     * @returns {SVGPathElement} the curve created.\n     */\n    createQuadraticBezierCurve: function(coordinates){\n        let d = \"M\" + coordinates[0] + \" \" + coordinates[1] + \" Q \" + coordinates[2] + \" \" + coordinates[3] + \" \" + coordinates[4] + \" \" + coordinates[5];\n        return this.createPath(d);\n    },\n\n    /**\n     * create a svg text element.\n     *\n     * @param x             the coordinate of the text\n     * @param y             the coordinate of the text\n     * @param text          content\n     * @param fontSize      font size\n     * @param align         means horizontal alignment, should be either \"start\", \"middle\" or \"end\"\n     * @param verticalAlign means vertical alignment, should be \"middle\", or null if you just want default.\n     * @returns {SVGTextElement} the text created\n     */\n    createText: function(x, y, text, fontSize, align, verticalAlign){\n        let t = document.createElementNS(this.xml_namespace, \"text\");\n        t.setAttributeNS(null, \"x\", x);\n        t.setAttributeNS(null, \"y\", y);\n\n        if(fontSize){\n            t.setAttributeNS(null, \"font-size\", fontSize);\n        } else {\n            t.setAttributeNS(null, \"font-size\", \"11\");\n        }\n\n        if(align){\n            t.setAttributeNS(null, \"text-anchor\", align);\n        }\n        if(verticalAlign === \"middle\"){\n            t.setAttributeNS(null, \"dy\", \"0.3em\");\n        } else if (verticalAlign === \"top\"){\n            t.setAttributeNS(null, \"dy\", \"1em\");\n        }\n        if(text !== false){\n            t.textContent = text;\n        }\n        return t;\n    },\n\n    /**\n     * create a rectangular.\n     *\n     * @param x         top left of the rectangular\n     * @param y         top left of the rectangular\n     * @param width     width\n     * @param height    height\n     * @returns {SVGRectElement} the rectangular created\n     */\n    createRectangular: function(x, y, width, height){\n        let r = document.createElementNS(this.xml_namespace, \"rect\");\n        r.setAttributeNS(null, \"x\", x);\n        r.setAttributeNS(null, \"y\", y);\n        r.setAttributeNS(null, \"width\", width);\n        r.setAttributeNS(null, \"height\", height);\n        return r;\n    },\n\n    /**\n     * create a circle\n     *\n     * @param x             the center of the circle\n     * @param y             the center of the circle\n     * @param radius        radius of the circle\n     * @returns {SVGCircleElement} the circle created\n     */\n    createCircle: function(x, y, radius){\n        //<circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"black\" stroke-width=\"3\" fill=\"red\" />\n        let c = document.createElementNS(this.xml_namespace, \"circle\");\n        c.setAttributeNS(null, \"cx\", x);\n        c.setAttributeNS(null, \"cy\", y);\n        c.setAttributeNS(null, \"r\", radius);\n        return c;\n    },\n\n    /**\n     * create an arc of circle, that is, creates an \"incomplete\" circle.\n     *\n     * @param x             the center of the circle\n     * @param y             the center of the circle\n     * @param radius        radius of the circle\n     * @param startAngle    where does the arc starts\n     * @param endAngle      where does the arc ends\n     * @returns {SVGPathElement}    the arc represented as a svg element.\n     */\n    createArcOfCircle: function (x, y, radius, startAngle, endAngle){\n        let start = _Util_Util__WEBPACK_IMPORTED_MODULE_0__[\"util\"].polarToCartesian(x, y, radius, endAngle);\n        let end = _Util_Util__WEBPACK_IMPORTED_MODULE_0__[\"util\"].polarToCartesian(x, y, radius, startAngle);\n\n        let arcSweep = endAngle - startAngle <= 180 ? \"0\" : \"1\";\n\n        let d = [\n            \"M\", x, y,\n            \"\", start[0], start[1],\n            \"A\", radius, radius, 0, arcSweep, 0, end[0], end[1],\n            \"Z\"\n        ].join(\" \");\n\n        return this.createPath(d);\n    },\n\n    /*\n    ######## create structures ########\n    */\n\n    /**\n     * create a svg group with the given id\n     * @returns {SVGGElement} the \"group\" svg element.\n     */\n    createGroup: function(){\n        let g = document.createElementNS(this.xml_namespace, \"g\");\n        return g;\n    },\n\n    /**\n     * create a <defs> tag.\n     * @return {SVGDefsElement} the \"defs\" svg element\n     */\n    createDefs: function(){\n        let d = document.createElementNS(this.xml_namespace, \"defs\");\n        return d;\n    },\n\n\n    /*-----transforms-----*/\n\n    /**\n     * rotate a svg element. you can also apply this to an svg element that already has a transform attribute.\n     * existing transform attribute such as translate wont be overridden.\n     * @param x     center of the rotation\n     * @param y     center of the rotation\n     * @param angle angle of the rotation\n     * @param svgElement    the svg element being rotated.\n     */\n    rotate: function(svgElement, x, y, angle){\n        let transform = svgElement.getAttributeNS(null, \"transform\");\n        if(transform){\n            let transforms = transform.split(\") \");\n            for(let i = 0; i < transforms.length; i++){\n                if(transforms[i].substr(0, 6) === \"rotate\") {\n                    transforms[i] = \"rotate(\" + angle + \" \" + x + \" \" + y + \")\";\n                }\n            }\n            transform = transforms.join(\" \");\n\n        } else {\n            transform = \"rotate(\" + angle + \" \" + x + \" \" + y + \")\";\n        }\n        svgElement.setAttributeNS(null, \"transform\", transform);\n    },\n\n    /**\n     * translate an svg element. you can even apply this function to an svg element that already\n     * has transform attribute. other transform attribute such as rotate will not be overridden.\n     *\n     * @param svgElement    the svg element being translated.\n     * @param x             distance to translate in x axis\n     * @param y             distance to translate in y axis\n     */\n    translate: function(svgElement, x, y){\n        let translate = \"translate(\" + x + \"px, \" + y + \"px)\";\n        svgElement.style.MozTransform = translate;\n        svgElement.style.webkitTransform = translate;\n        svgElement.style.msTransform = translate;\n        svgElement.style.transform = translate;\n    },\n\n    /**\n     * scale an svg element. you can even apply this function to an svg element that already\n     * has transform attribute. other transform attribute such as rotate will not be overridden.\n     *\n     * @param svgElement    the svg element being scaled.\n     * @param scaleFactor   the scale\n     */\n    scale: function(svgElement, scaleFactor){\n        let transform = svgElement.getAttributeNS(null, \"transform\");\n        if(transform){\n            let transforms = transform.split(\") \");\n            for(let i = 0; i < transforms.length; i++){\n                if(transforms[i].substr(0, 5) === \"scale\") {\n                    transforms[i] = \"scale(\" +  scaleFactor + \")\";\n                }\n            }\n            transform = transforms.join(\" \");\n\n        } else {\n            transform = \"scale(\" + scaleFactor + \")\";\n        }\n        svgElement.setAttributeNS(null, \"transform\", transform);\n    },\n\n    /*\n    ######## presentation attributes ########\n    */\n\n    /**\n     * set the stroke, stroke-width and fill\n     * @param svgElement    the svg element to which we are setting style.\n     * @param stroke        stroke color\n     * @param strokeWidth   stroke width\n     * @param fill          fill color\n     */\n    setStrokeFill: function(svgElement, stroke, strokeWidth, fill){\n        if(stroke){\n            svgElement.setAttributeNS(null, \"stroke\", stroke);\n        }\n        if(strokeWidth !== false){\n            svgElement.setAttributeNS(null, \"stroke-width\", strokeWidth);\n        }\n        if(fill){\n            svgElement.setAttributeNS(null, \"fill\", fill);\n        }\n    },\n\n    /**\n     * this function creates a svg linear gradient. it should be used together with addLinearGradientStop\n     * @param startPosition     needs to be [percentage, percentage]\n     * @param endPosition       needs to be [percentage, percentage]\n     * @returns {SVGLinearGradientElement}  the linear gradient svg element created.\n     */\n    createLinearGradient: function(startPosition, endPosition){\n        let linearGraident = document.createElementNS(this.xml_namespace, \"linearGradient\");\n        linearGraident.setAttributeNS(null, \"x1\", startPosition[0]);\n        linearGraident.setAttributeNS(null, \"y1\", startPosition[1]);\n        linearGraident.setAttributeNS(null, \"x2\", endPosition[0]);\n        linearGraident.setAttributeNS(null, \"y2\", endPosition[1]);\n        return linearGraident;\n    },\n\n    /**\n     * add a linear stop color to a linear gradient svg element\n     * @param linearGradient    linearGradient\n     * @param stopPosition      stopPosition\n     * @param stopRawColor      stopRawColor\n     * @param stopOpacity       stopOpacity\n     */\n    addLinearGradientStop: function(linearGradient, stopPosition, stopRawColor, stopOpacity){\n        //<stop offset=\".8\" stop-color=\"black\" stop-opacity=\"0.5\"/>\n        let stop = document.createElementNS(this.xml_namespace, \"stop\");\n        stop.setAttributeNS(null, \"offset\", stopPosition);\n        stop.setAttributeNS(null, \"stop-color\", stopRawColor);\n        if(stopOpacity){\n            stop.setAttributeNS(null, \"stop-opacity\", stopOpacity);\n        }\n\n        linearGradient.appendChild(stop);\n    },\n\n    /**\n     * configure the visibility of an element.\n     * @param svgElement        target svg element\n     * @param isVisible         visible or hidden\n     */\n    setVisibility: function(svgElement, isVisible){\n        if(isVisible){\n            svgElement.setAttributeNS(null, \"visibility\", \"visibile\");\n        } else {\n            svgElement.setAttributeNS(null, \"visibility\", \"hidden\");\n        }\n    },\n\n    /**\n     * configure pointer events. https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/pointer-events\n     * basically, if fill, then when mouse over filled area, registered call back will be invoked\n     * if stroke, then when mouse over the stroke area, registered call back will be invoked.\n     * @param svgElement        target svg element\n     * @param fill              sets pointer-events to fill\n     * @param stroke            sets pointer0events to stroke.\n     */\n    setPointerEvent: function(svgElement, fill, stroke){\n        if(fill){\n            svgElement.setAttributeNS(null, \"pointer-events\", \"fill\");\n        }\n\n        if(stroke){\n            svgElement.setAttributeNS(null, \"pointer-events\", \"stroke\");\n        }\n    },\n\n    /*\n    ######## other attributes ########\n    */\n    /**\n     * set an id for an element\n     * @param id            the new id\n     * @param svgElement    target svg element\n     */\n    setId: function(svgElement, id){\n        svgElement.setAttribute(\"id\", id);\n    }\n\n};\n\n//# sourceURL=webpack:///./src/Draw/Draw.js?");

/***/ }),

/***/ "./src/Draw/NodeDrawer.js":
/*!********************************!*\
  !*** ./src/Draw/NodeDrawer.js ***!
  \********************************/
/*! exports provided: nodeDrawer */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"nodeDrawer\", function() { return nodeDrawer; });\n/* harmony import */ var _Draw__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Draw */ \"./src/Draw/Draw.js\");\n/**\n * offers convenient methods to draw colorful circles, rectangulars and so on.\n */\n\n\nconst nodeDrawer = {\n\n    /**\n     * draws a standard shape, using the given color\n     * @param nodeShape                 the shape: circle | rectangular | triangle | reverse-triangle\n     * @param mcColor                   color defined in `Color.js`\n     * @param x                         position of the shape\n     * @param y                         position of the shape\n     * @returns {SVGCircleElement | SVGPathElement | SVGRectElement}    the shaped created\n     */\n    draw: function (nodeShape, mcColor, x, y) {\n        switch (nodeShape) {\n            case \"circle\":\n                return this.drawCircleNode(mcColor, x, y, 4, 1);\n            case \"rectangular\":\n                return this.drawRectangularNode(mcColor, x, y, 8, 8, 1);\n            case \"triangle\":\n                return this.drawTriangleNode(mcColor, x, y, 5, 1);\n            case \"reverse-triangle\":\n                return this.drawReverseTriangleNode(mcColor, x, y, 5, 1);\n        }\n    },\n\n    /**\n     * draws a highlighted shape, using the given color, the shape is positioned at the origin\n     * if u need the highlight a (original) node, you should apply transform.translate to a highlighted node\n     * and position it above the original node.\n     *\n     * @param nodeShape                 the shape: circle | rectangular | triangle | reverse-triangle\n     * @param mcColor                   color defined in `Color.js`\n     * @returns {SVGCircleElement | SVGPathElement | SVGRectElement}    the shaped created\n     */\n    drawHighlightedNode: function(nodeShape, mcColor) {\n        switch (nodeShape) {\n            case \"circle\":\n                return this.drawCircleNode(mcColor, 0, 0, 6, 3);\n            case \"rectangular\":\n                return this.drawRectangularNode(mcColor, 0, 0, 12, 12, 3);\n            case \"triangle\":\n                return this.drawTriangleNode(mcColor, 0, 0, 7, 3);\n            case \"reverse-triangle\":\n                return this.drawReverseTriangleNode(mcColor, 0, 0, 7, 3);\n        }\n    },\n\n    /**\n     * draws a circle element with given color, radius and stroke width\n     * @param x             center of the circle node\n     * @param y             center of the circle node\n     * @param mcColor       color\n     * @param radius        radius\n     * @param strokeWidth   stroke width\n     * @returns {SVGCircleElement}  returns a svg circle\n     */\n    drawCircleNode: function (mcColor, x, y, radius, strokeWidth) {\n        let vn = _Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createCircle(x, y, radius);\n        _Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setStrokeFill(vn, mcColor.strokeColor, strokeWidth, mcColor.fillColor);\n        return vn;\n    },\n\n    /**\n     * draws a rectangular svg element\n     * @param x                     top left of the rectangular\n     * @param y                     top left of the rectangular\n     * @param mcColor               color\n     * @param width                 width of the rectangular\n     * @param height                height of the rectangular\n     * @param strokeWidth           stroke width\n     * @returns {SVGRectElement}    returns a svg rectangular with the above settings.\n     */\n    drawRectangularNode: function (mcColor, x, y, width, height, strokeWidth) {\n        x = x - width/2;\n        y = y - height/2;\n        let d = \"M\" + x + \" \" + y + \" \" + (x + width) + \" \" + y + \" \" + (x + width) + \" \" + (y + height) + \" \" + x + \" \" + (y + height) + \"Z\";\n        let vn = _Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createPath(d);\n        _Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setStrokeFill(vn, mcColor.strokeColor, strokeWidth, mcColor.fillColor);\n        return vn;\n    },\n\n    /**\n     * draws a path that forms a triangle\n     * @param x                     center of the triangle\n     * @param y                     center of the triangle\n     * @param mcColor               color\n     * @param size                  size of the triangle\n     * @param strokeWidth           stroke width\n     * @returns {SVGPathElement}    the triangle path.\n     */\n    drawTriangleNode: function(mcColor, x, y, size, strokeWidth){\n        let h = size * Math.sin(Math.PI / 6);\n        let w = size * Math.cos(Math.PI / 6);\n        let v = (size + h)/2;\n        let d = \"M\" + x + \" \" + (y-v) + \" \" + (x-w) + \" \" + (y+v) + \" \" + (x+w) + \" \" + (y+v) + \"Z\";\n        let vn = _Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createPath(d);\n        _Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setStrokeFill(vn, mcColor.strokeColor, strokeWidth, mcColor.fillColor);\n        return vn;\n    },\n\n    /**\n     * draws a reversed triangle\n     * @param x                     center of the triangle\n     * @param y                     center of the triangle\n     * @param mcColor               color\n     * @param size                  size of the triangle\n     * @param strokeWidth           stroke width\n     * @returns {SVGPathElement}    the triangle path.\n     */\n    drawReverseTriangleNode: function(mcColor, x, y, size, strokeWidth){\n        let h = size * Math.sin(Math.PI / 6);\n        let w = size * Math.cos(Math.PI / 6);\n        let v = (size + h)/2;\n        let d = \"M\" + (x-w) + \" \" + (y-v) + \" \" + (x+w) + \" \" + (y-v) + \" \" + x + \" \" + (y+v) + \"Z\";\n        let vn = _Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createPath(d);\n        _Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setStrokeFill(vn, mcColor.strokeColor, strokeWidth, mcColor.fillColor);\n        return vn;\n    },\n\n    /**\n     * draws a section that is used to trigger tip / visual node highlight. normally we create a trigger for a data\n     * point, and a data point is usually just an element to in an array. the node stride idx tells the stride idx\n     * of the data point. so that when the triggered emits some events, we can easily find out the responding data point.\n     * @param pixelX                the center of the trigger\n     * @param pixelY                the center of the trigger\n     * @param nodesStrideIdx        node stride idx.\n     * @returns {SVGCircleElement}\n     */\n    drawTrigger: function(pixelX, pixelY, nodesStrideIdx){\n        let trigger = _Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].createCircle(pixelX, pixelY, 10); //this is the part that triggers things.\n        _Draw__WEBPACK_IMPORTED_MODULE_0__[\"draw\"].setStrokeFill(trigger, false, false, \"rgba(0,0,0,0)\");\n        trigger.ws_nodesStrideIdx = nodesStrideIdx;\n        return trigger;\n    }\n};\n\n\n//# sourceURL=webpack:///./src/Draw/NodeDrawer.js?");

/***/ }),

/***/ "./src/Layout/Layout.js":
/*!******************************!*\
  !*** ./src/Layout/Layout.js ***!
  \******************************/
/*! exports provided: Layout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Layout\", function() { return Layout; });\n/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Util/Util */ \"./src/Util/Util.js\");\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Draw/Draw */ \"./src/Draw/Draw.js\");\n/**\n * For more details refer to the design blueprint. This class implements the layout of a typical 'Basic Line' chart.\n */\n\n\n\nfunction Layout(){\n    this.smallMargin = 10;\n    this.mediumMargin = 20;\n    this.bigMargin = 50;\n    this.mainTitleHeight = 30;\n    this.mainTitleFontSize = 25;\n    this.subTitleHeight = 20;\n    this.subTitleFontSize = 15;\n    this.yAxisTitleWidth = this.xAxisTitleHeight = 20;\n    this.yAxisTitleFontSize = this.xAxisTitleFontSize = 15;\n    this.xAxisHeight = 20;\n    this.yAxisWidth = 30;\n    this.areas = null;\n}\n\n/**\n * returns the top fixed margin\n * @returns {Number}\n */\nLayout.prototype.calculateHeightOfFixedTopMargin = function(){\n    return this.smallMargin;\n};\n\n/**\n * returns the total height of the main title component.\n * @returns {Number}\n */\nLayout.prototype.calculateHeightOfMainTitleComponent = function(){\n    return _Util_Util__WEBPACK_IMPORTED_MODULE_0__[\"util\"].chooseBetween(this.mainTitle, this.mainTitleHeight + this.smallMargin, 0);\n};\n\nLayout.prototype.calculateHeightOfSubTitleComponent = function(){\n    return _Util_Util__WEBPACK_IMPORTED_MODULE_0__[\"util\"].chooseBetween(this.subTitle , this.subTitleHeight + this.smallMargin, 0);\n};\n\nLayout.prototype.calculateHeightOfTopLegendComponent = function(){\n    return _Util_Util__WEBPACK_IMPORTED_MODULE_0__[\"util\"].chooseBetween(this.legend.positionRelativeToLayout === \"top\", this.legend.height + this.mediumMargin, 0);\n};\n\nLayout.prototype.calculateWidthOfLeftFixedMargin = function(){\n    return this.smallMargin;\n};\n\nLayout.prototype.calculateWidthOfLeftLegendComponent = function(){\n    return _Util_Util__WEBPACK_IMPORTED_MODULE_0__[\"util\"].chooseBetween(this.legend.positionRelativeToLayout === \"left\", this.legend.width + this.smallMargin, 0);\n};\n\nLayout.prototype.calculateWidthOfYAxisTitleComponent = function(){\n    return _Util_Util__WEBPACK_IMPORTED_MODULE_0__[\"util\"].chooseBetween(this.yAxisTitle, this.yAxisTitleWidth + this.smallMargin, 0)\n};\n\nLayout.prototype.calculateHeightOfFixedBottomMargin = function(){\n    return this.smallMargin;\n};\n\nLayout.prototype.calculateHeightOfBottomLegendComponent = function(){\n    return _Util_Util__WEBPACK_IMPORTED_MODULE_0__[\"util\"].chooseBetween(this.legend.positionRelativeToLayout === \"bottom\", this.legend.height + this.smallMargin, 0);\n};\n\nLayout.prototype.calculateHeightOfXAxisTitleComponent = function(){\n    return _Util_Util__WEBPACK_IMPORTED_MODULE_0__[\"util\"].chooseBetween(this.xAxisTitle, this.xAxisTitleHeight + this.smallMargin, 0);\n};\n\nLayout.prototype.calculateWidthOfRightFixedMargin = function(){\n    return this.smallMargin;\n};\n\nLayout.prototype.calculateWidthOfRightLegendComponent = function(){\n    return _Util_Util__WEBPACK_IMPORTED_MODULE_0__[\"util\"].chooseBetween(this.legend.positionRelativeToLayout === \"right\", this.legend.width + this.smallMargin, 0);\n};\n\nLayout.prototype.calculateOuterAreasSizes = function(){\n    if(this.areas !== null){\n        return this.areas;\n    }\n\n    let layout = this;\n\n    let topOuterHeight = calculateTopOuterHeight();\n    let leftOuterWidth = calculateLeftOuterWidth();\n    let bottomOuterHeight = calculateBottomOuterHeight();\n    let rightOuterWidth = calculateRightOuterWidth();\n\n    let svgWidth = +(this.svg.getAttribute(\"width\"));\n    let svgHeight = +(this.svg.getAttribute(\"height\"));\n\n    let topArea = {\n        origin : [leftOuterWidth, 0],\n        width : svgWidth - leftOuterWidth - rightOuterWidth,\n        height: topOuterHeight\n    };\n\n    let leftArea = {\n        origin : [0, topOuterHeight],\n        width : leftOuterWidth,\n        height : svgHeight - topOuterHeight - bottomOuterHeight - this.xAxisHeight\n    };\n\n    let rightArea = {\n        origin : [svgWidth - rightOuterWidth, topOuterHeight],\n        width: rightOuterWidth,\n        height: leftArea.height\n    };\n\n    let bottomArea = {\n        origin : [leftOuterWidth, svgHeight - bottomOuterHeight],\n        width : topArea.width,\n        height: bottomOuterHeight\n    };\n\n    this.areas = {\n        topArea: topArea,\n        leftArea: leftArea,\n        rightArea: rightArea,\n        bottomArea: bottomArea\n    };\n\n\n    return this.areas;\n\n    function calculateTopOuterHeight(){\n        return layout.calculateHeightOfFixedTopMargin() + layout.calculateHeightOfMainTitleComponent()\n            + layout.calculateHeightOfSubTitleComponent() + layout.calculateHeightOfTopLegendComponent();\n    }\n\n    function calculateLeftOuterWidth(){\n        return layout.calculateWidthOfLeftFixedMargin() + layout.calculateWidthOfLeftLegendComponent()\n            + layout.calculateWidthOfYAxisTitleComponent();\n    }\n\n    function calculateBottomOuterHeight(){\n        return layout.calculateHeightOfFixedBottomMargin() + layout.calculateHeightOfBottomLegendComponent()\n            + layout.calculateHeightOfXAxisTitleComponent();\n    }\n\n    function calculateRightOuterWidth(){\n        return layout.calculateWidthOfRightFixedMargin() + layout.calculateWidthOfRightLegendComponent();\n    }\n\n};\n\n/**\n * returns the total lengths of x axis and y axis (including padding) and the position of the origin.\n * @returns {{origin: *, xAxisLength: number, yAxisLength: *}}\n */\nLayout.prototype.analyze = function(){\n    let layout = this;\n    let outerAreas = this.calculateOuterAreasSizes();\n    let origin = calculateOriginPosition(outerAreas);\n    let yAxisLength = outerAreas.leftArea.height;\n    let xAxisLength = outerAreas.topArea.width - this.yAxisWidth;\n\n    return {\n        originPosition: origin,\n        xAxisLength: xAxisLength,\n        yAxisLength: yAxisLength\n    };\n\n\n    function calculateOriginPosition(outerAreas){\n        let originX = outerAreas.leftArea.width + layout.yAxisWidth;\n        let originY = outerAreas.topArea.height + outerAreas.leftArea.height;\n        return [originX, originY];\n    }\n};\n\n\nLayout.prototype.drawTitles = function(){\n    let outerAreas = this.calculateOuterAreasSizes();\n    let top = outerAreas.topArea;\n    let left = outerAreas.leftArea;\n    let right = outerAreas.rightArea;\n    let bottom = outerAreas.bottomArea;\n\n    if(this.mainTitle){\n        let x = top.origin[0] + top.width / 2;\n        let y = this.calculateHeightOfFixedTopMargin() + this.mainTitleHeight / 2;\n        this.svg.appendChild(_Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createText(x, y, this.mainTitle, this.mainTitleFontSize, \"middle\", \"middle\"));\n    }\n\n    if(this.subTitle){\n        let x = top.origin[0] + top.width / 2;\n        let y = this.calculateHeightOfFixedTopMargin() + this.calculateHeightOfMainTitleComponent() + this.subTitleHeight/2;\n        let subTitle = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createText(x, y, this.subTitle, this.subTitleFontSize, \"middle\", \"middle\");\n        _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].setStrokeFill(subTitle, \"none\", false, \"#6E6F6F\");\n        this.svg.appendChild(subTitle);\n    }\n\n    if(this.yAxisTitle){\n        let x = left.origin[0] + this.calculateWidthOfLeftFixedMargin() + this.calculateWidthOfLeftLegendComponent()\n            + this.yAxisTitleWidth / 2;\n        let y = top.height + left.\n            height / 2;\n        let yAxisTitle = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createText(x, y, this.yAxisTitle, this.yAxisTitleFontSize, \"middle\", \"middle\");\n        _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].setStrokeFill(yAxisTitle, \"none\", false, \"#6E6F6F\");\n        _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].rotate(yAxisTitle, x, y, -90);\n        this.svg.appendChild(yAxisTitle);\n    }\n\n    if(this.xAxisTitle){\n        let x = bottom.origin[0] + bottom.width / 2;\n        let y = bottom.origin[1] + this.smallMargin + this.xAxisTitleHeight / 2;\n        let xAxisTtile = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createText(x, y, this.xAxisTitle, this.xAxisTitleFontSize, \"middle\", \"middle\");\n        _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].setStrokeFill(xAxisTtile, \"none\", false, \"#6E6F6F\");\n        this.svg.appendChild(xAxisTtile);\n    }\n};\n\nLayout.prototype.drawLegend = function(){\n    let areas = this.calculateOuterAreasSizes();\n    //center of the left legend\n    if(this.legend.positionRelativeToLayout === \"left\"){\n        this.legend.draw(areas.leftArea.origin[0] + this.legend.width / 2,\n                areas.leftArea.origin[1] + areas.leftArea.height / 2);\n    }\n    //center of the right legend\n    if(this.legend.positionRelativeToLayout === \"right\"){\n        this.legend.draw(areas.rightArea.origin[0] + this.legend.width / 2,\n                areas.rightArea.origin[1] + areas.rightArea.height / 2);\n    }\n    //center of the top legend\n    if(this.legend.positionRelativeToLayout === \"top\"){\n        let x = areas.topArea.origin[0] + areas.topArea.width / 2;\n        let y = this.calculateHeightOfFixedTopMargin() + this.calculateHeightOfMainTitleComponent()\n            + this.calculateHeightOfSubTitleComponent() + this.legend.height / 2;\n        this.legend.draw(x, y);\n    }\n    //center of the bottom legend\n    if(this.legend.positionRelativeToLayout === \"bottom\"){\n        let x = areas.bottomArea.origin[0] + areas.bottomArea.width / 2;\n        let y = areas.bottomArea.origin[1] + this.calculateHeightOfXAxisTitleComponent()\n            + this.smallMargin + this.legend.height / 2;\n        this.legend.draw(x, y);\n    }\n};\n\n\nLayout.prototype.draw = function(){\n    this.drawTitles();\n    this.drawLegend();\n};\n\n\n\n//# sourceURL=webpack:///./src/Layout/Layout.js?");

/***/ }),

/***/ "./src/Layout/Sub/GeneralLayout.js":
/*!*****************************************!*\
  !*** ./src/Layout/Sub/GeneralLayout.js ***!
  \*****************************************/
/*! exports provided: GeneralLayout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GeneralLayout\", function() { return GeneralLayout; });\n/* harmony import */ var _Layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Layout */ \"./src/Layout/Layout.js\");\n/**\n * general layout with 2 axis and 1 legend\n * @param svg           svg container\n * @param mainTitle     main title\n * @param subTitle      sub title\n * @param yAxisTitle    title of y axis\n * @param xAxisTitle    title of x axis\n * @param legend        legend\n * @constructor\n */\n\n\nfunction GeneralLayout(svg, mainTitle, subTitle, yAxisTitle, xAxisTitle, legend){\n    this.svg = svg;\n    this.mainTitle = mainTitle;\n    this.subTitle = subTitle;\n    this.yAxisTitle = yAxisTitle;\n    this.xAxisTitle = xAxisTitle;\n    this.legend = legend;\n}\n\nGeneralLayout.prototype = new _Layout__WEBPACK_IMPORTED_MODULE_0__[\"Layout\"]();\nGeneralLayout.prototype.constructor = GeneralLayout;\n\nGeneralLayout.prototype.calculateHeightOfFixedTopMargin = function(){\n    if(!this.mainTitle && !this.subTitle){\n        return this.bigMargin; //top outer adds up to 50\n    } else if(!this.mainTitle && this.subTitle) {\n        return this.mediumMargin; //top outer adds up to 50\n    } else {\n        //in other cases the outer adds up to 50 (only mainTitle) or more than 50 (both main title and sub title exist).\n        return this.smallMargin;\n    }\n};\n\n\n//# sourceURL=webpack:///./src/Layout/Sub/GeneralLayout.js?");

/***/ }),

/***/ "./src/Layout/Sub/LayoutNoAxes.js":
/*!****************************************!*\
  !*** ./src/Layout/Sub/LayoutNoAxes.js ***!
  \****************************************/
/*! exports provided: LayoutNoAxes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LayoutNoAxes\", function() { return LayoutNoAxes; });\n/* harmony import */ var _Layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Layout */ \"./src/Layout/Layout.js\");\n/**\n * this layout assumes there is no axis, mainly used for 3d chart.\n * @param svg           svg container\n * @param mainTitle     main title\n * @param subTitle      sub title\n * @param legend        legend\n * @constructor\n */\n\n\nfunction LayoutNoAxes(svg, mainTitle, subTitle, legend){\n    this.svg = svg;\n    this.mainTitle = mainTitle;\n    this.subTitle = subTitle;\n    this.yAxisTitle = undefined; //since there is no axis there will be no axis title.\n    this.xAxisTitle = undefined; //since there is no axis there will be no axis title.\n    //these two override the values in the Layout.js\n    this.xAxisHeight = 0;\n    this.yAxisWidth = 0;\n\n    this.legend = legend;\n}\n\nLayoutNoAxes.prototype = new _Layout__WEBPACK_IMPORTED_MODULE_0__[\"Layout\"]();\nLayoutNoAxes.prototype.constructor = LayoutNoAxes;\n\nLayoutNoAxes.prototype.analyze = function(){\n    let layout = this;\n    let outerAreas = this.calculateOuterAreasSizes();\n    let origin = calculateOriginPosition(outerAreas);\n    let dataDrawAreaY = outerAreas.leftArea.height;\n    let dataDrawAreaX = outerAreas.topArea.width - this.yAxisWidth;\n    let radii = calculateSuggestedRadius();\n\n    return {\n        dataDrawAreaX: dataDrawAreaX,\n        dataDrawAreaY: dataDrawAreaY,\n        center: [origin[0] + dataDrawAreaX/2, origin[1] - dataDrawAreaY/2],\n        radiusForLabel: radii[0],\n        radiusForPie: radii[1],\n        radiusForConnectionLine: radii[2]\n    };\n\n    function calculateOriginPosition(outerAreas){\n        let originX = outerAreas.leftArea.width + layout.yAxisWidth;\n        let originY = outerAreas.topArea.height + outerAreas.leftArea.height;\n        return [originX, originY];\n    }\n\n    function calculateSuggestedRadius(){\n        let suggestedDataLabelHeight = 19;\n\n        let d;\n        if(dataDrawAreaX < dataDrawAreaY){\n            d = dataDrawAreaX/2;\n        } else {\n            d = dataDrawAreaY/2;\n        }\n\n        //the data label position is really the position of the connector of the data label.\n        //that's why i need to divide suggestedDataLabelHeight by 2.\n        let radiusOfCircleForPositioningLabels = d - suggestedDataLabelHeight / 2;\n        let radiusOfPie = radiusOfCircleForPositioningLabels - 30;\n        let radiusOfCircleForConnectionLineTurn = radiusOfCircleForPositioningLabels - 20;\n        //draw these hateful circle to see what they do if you forget about them.\n\n        return [radiusOfCircleForPositioningLabels, radiusOfPie, radiusOfCircleForConnectionLineTurn];\n    }\n};\n\n//# sourceURL=webpack:///./src/Layout/Sub/LayoutNoAxes.js?");

/***/ }),

/***/ "./src/Layout/Sub/MultipleLegendLayout.js":
/*!************************************************!*\
  !*** ./src/Layout/Sub/MultipleLegendLayout.js ***!
  \************************************************/
/*! exports provided: MultipleLegendLayout */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MultipleLegendLayout\", function() { return MultipleLegendLayout; });\n/* harmony import */ var _Layout__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Layout */ \"./src/Layout/Layout.js\");\n/**\n * this layout allows for multiple legends\n * @param svg               to which we will append all the created svg element\n * @param mainTitle         main title\n * @param subTitle          sub title\n * @param legendList        the list of legends\n * @constructor\n */\n\n\nfunction MultipleLegendLayout(svg, mainTitle, subTitle, legendList){\n    this.svg = svg;\n    this.mainTitle = mainTitle;\n    this.subTitle = subTitle;\n    this.yAxisTitle = undefined; //since there is no axis there will be no axis title.\n    this.xAxisTitle = undefined; //since there is no axis there will be no axis title.\n    //these two override the values in the Layout.js\n    this.xAxisHeight = 0;\n    this.yAxisWidth = 0;\n    this.legendList = legendList;\n}\n\nMultipleLegendLayout.prototype = new _Layout__WEBPACK_IMPORTED_MODULE_0__[\"Layout\"]();\nMultipleLegendLayout.prototype.constructor = MultipleLegendLayout;\n\nMultipleLegendLayout.prototype.calculateHeightOfFixedTopMargin = function(){\n    if(!this.mainTitle && !this.subTitle){\n        return this.bigMargin; //top outer adds up to 50\n    } else if(!this.mainTitle && this.subTitle) {\n        return this.mediumMargin; //top outer adds up to 50\n    } else {\n        //in other cases the outer adds up to 50 (only mainTitle) or more than 50 (both main title and sub title exist).\n        return this.smallMargin;\n    }\n};\n\nMultipleLegendLayout.prototype.calculateHeightOfTopLegendComponent = function(){\n    for(let i = 0; i < this.legendList.length; i++){\n        if(this.legendList[i].positionRelativeToLayout === \"top\"){\n            return this.legendList[i].height + this.mediumMargin;\n        }\n    }\n    return 0;\n};\n\nMultipleLegendLayout.prototype.calculateWidthOfLeftLegendComponent = function(){\n    for(let i = 0; i < this.legendList.length; i++){\n        if(this.legendList[i].positionRelativeToLayout === \"left\"){\n            return this.legendList[i].width + this.smallMargin;\n        }\n    }\n    return 0;\n};\n\nMultipleLegendLayout.prototype.calculateHeightOfBottomLegendComponent = function(){\n    for(let i = 0; i < this.legendList.length; i++){\n        if(this.legendList[i].positionRelativeToLayout === \"bottom\") {\n            return this.legendList[i].height + this.smallMargin;\n        }\n    }\n    return 0;\n};\n\nMultipleLegendLayout.prototype.calculateWidthOfRightLegendComponent = function(){\n    for(let i = 0; i < this.legendList.length; i++){\n        if(this.legendList[i].positionRelativeToLayout === \"right\"){\n            console.log(this.legendList[i].width + this.smallMargin);\n            return this.legendList[i].width + this.smallMargin;\n        }\n    }\n    return 0;\n};\n\nMultipleLegendLayout.prototype.analyze = function(){\n    let layout = this;\n    let outerAreas = this.calculateOuterAreasSizes();\n    let origin = calculateOriginPosition(outerAreas);\n    let dataDrawAreaY = outerAreas.leftArea.height;\n    let dataDrawAreaX = outerAreas.topArea.width - this.yAxisWidth;\n\n    return {\n        originPosition: origin,\n        dataDrawAreaX: dataDrawAreaX,\n        dataDrawAreaY: dataDrawAreaY\n    };\n\n    function calculateOriginPosition(outerAreas){\n        let originX = outerAreas.leftArea.width + layout.yAxisWidth;\n        let originY = outerAreas.topArea.height + outerAreas.leftArea.height;\n        return [originX, originY];\n    }\n};\n\nMultipleLegendLayout.prototype.drawLegend = function(){\n    let areas = this.calculateOuterAreasSizes();\n    for(let i = 0; i < this.legendList.length; i++){\n        //center of the left legend\n        if(this.legendList[i].positionRelativeToLayout === \"left\"){\n            this.legendList[i].draw(areas.leftArea.origin[0] + this.legendList[i].width / 2,\n                    areas.leftArea.origin[1] + areas.leftArea.height / 2);\n        }\n        //center of the right legend\n        if(this.legendList[i].positionRelativeToLayout === \"right\"){\n            this.legendList[i].draw(areas.rightArea.origin[0] + this.legendList[i].width / 2,\n                    areas.rightArea.origin[1] + areas.rightArea.height / 2);\n        }\n        //center of the top legend\n        if(this.legendList[i].positionRelativeToLayout === \"top\"){\n            let x = areas.topArea.origin[0] + areas.topArea.width / 2;\n            let y = this.calculateHeightOfFixedTopMargin() + this.calculateHeightOfMainTitleComponent()\n                + this.calculateHeightOfSubTitleComponent() + this.legendList[i].height / 2;\n            this.legendList[i].draw(x, y);\n        }\n        //center of the bottom legend\n        if(this.legendList[i].positionRelativeToLayout === \"bottom\"){\n            let x = areas.bottomArea.origin[0] + areas.bottomArea.width / 2;\n            let y = areas.bottomArea.origin[1] + this.calculateHeightOfXAxisTitleComponent()\n                + this.smallMargin + this.legendList[i].height / 2;\n            this.legendList[i].draw(x, y);\n        }\n    }\n};\n\n\n//# sourceURL=webpack:///./src/Layout/Sub/MultipleLegendLayout.js?");

/***/ }),

/***/ "./src/Legend/Legend.js":
/*!******************************!*\
  !*** ./src/Legend/Legend.js ***!
  \******************************/
/*! exports provided: Legend */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Legend\", function() { return Legend; });\n/* harmony import */ var _Util_RandomPicker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Util/RandomPicker */ \"./src/Util/RandomPicker.js\");\n/* harmony import */ var _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Draw/Draw */ \"./src/Draw/Draw.js\");\n/* harmony import */ var _Util_Util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Util/Util */ \"./src/Util/Util.js\");\n/* harmony import */ var _Draw_NodeDrawer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../Draw/NodeDrawer */ \"./src/Draw/NodeDrawer.js\");\n\n\n\n\n\n/**\n * creates a legend. the legend created is highly customizable..and hence the amount of parameters we need to consider.\n * after an instance of legend is created, we first need to provide data and run `analyze` method, to determine the width\n * , height and other information dynamically, before we can draw the legend.\n */\nfunction Legend(svg, multipleSeries, positionRelativeToLayout, shape, color){\n    this.svg = svg;\n    this.height = 0;\n    this.width = 0;\n    this.rowHeight = 25;\n    this.fontSize = 15;\n    this.multipleSeries = multipleSeries;\n    this.positionRelativeToLayout = positionRelativeToLayout;\n    this.shape = shape;\n    this.color = color;\n    this.legendSVG_Group = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createGroup();\n}\n\nLegend.prototype.analyze = function(directMultipleSeriesName, includeNodeShape){\n    if(this.positionRelativeToLayout === \"none\") return;\n\n    this.svg.appendChild(this.legendSVG_Group);\n    let randomPicker = new _Util_RandomPicker__WEBPACK_IMPORTED_MODULE_0__[\"RandomPicker\"]();\n\n    let multipleSeriesNames;\n    if(!directMultipleSeriesName){\n        multipleSeriesNames = [];\n        for(let i = 0; i < this.multipleSeries.length; i++){\n            multipleSeriesNames.push(this.multipleSeries[i][0]);\n        }\n    } else {\n        multipleSeriesNames = directMultipleSeriesName;\n    }\n\n    //vertical\n    if(this.positionRelativeToLayout === \"left\" || this.positionRelativeToLayout === \"right\"){\n        for(let i = 0; i < multipleSeriesNames.length; i++){\n            let singleSeriesName = multipleSeriesNames[i];\n            let legendText = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createText(20, this.rowHeight * i + this.rowHeight/2, singleSeriesName, this.fontSize, \"start\", \"middle\");\n\n            this.legendSVG_Group.appendChild(legendText);\n            if(includeNodeShape === undefined /*not specified, by default we include it.*/ || includeNodeShape === true){\n                let singleSeriesNode = _Draw_NodeDrawer__WEBPACK_IMPORTED_MODULE_3__[\"nodeDrawer\"].draw(\n                    _Util_Util__WEBPACK_IMPORTED_MODULE_2__[\"util\"].pickFirstAvailable(this.shape, randomPicker.pickNodeShape()),\n                    _Util_Util__WEBPACK_IMPORTED_MODULE_2__[\"util\"].pickFirstAvailable(this.color, randomPicker.pickSeriesColor()),\n                    10,\n                    this.rowHeight * i + this.rowHeight/2);\n                this.legendSVG_Group.appendChild(singleSeriesNode);\n            }\n        }\n    }\n\n    //horizontal\n    if(this.positionRelativeToLayout === \"top\" || this.positionRelativeToLayout === \"bottom\"){\n        let columnWidth = 0;\n        for(let i = 0; i < multipleSeriesNames.length; i++){\n            let singleSeriesName = multipleSeriesNames[i];\n            let legendText = _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].createText(10 + columnWidth, this.rowHeight/2, singleSeriesName, this.fontSize, \"start\", \"middle\");\n            this.legendSVG_Group.appendChild(legendText);\n\n            if(includeNodeShape === undefined /*not specified, by default we include it.*/ || includeNodeShape === true){\n                let singleSeriesNode = _Draw_NodeDrawer__WEBPACK_IMPORTED_MODULE_3__[\"nodeDrawer\"].draw(\n                    _Util_Util__WEBPACK_IMPORTED_MODULE_2__[\"util\"].pickFirstAvailable(this.shape, randomPicker.pickNodeShape()),\n                    _Util_Util__WEBPACK_IMPORTED_MODULE_2__[\"util\"].pickFirstAvailable(this.color, randomPicker.pickSeriesColor()),\n                    columnWidth,\n                    this.rowHeight/2);\n                this.legendSVG_Group.appendChild(singleSeriesNode);\n            }\n\n            columnWidth = columnWidth + 30 + legendText.getBoundingClientRect().width;\n        }\n    }\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].setVisibility(this.legendSVG_Group, false);\n    this.width = this.legendSVG_Group.getBoundingClientRect().width;\n    this.height = this.legendSVG_Group.getBoundingClientRect().height;\n};\n\n/**\n * draws the legend. x y should be the center of the legend.\n * @param x\n * @param y\n */\nLegend.prototype.draw = function(x, y){\n    x = x - this.width / 2;\n    y = y - this.height / 2;\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].translate(this.legendSVG_Group, x, y);\n    _Draw_Draw__WEBPACK_IMPORTED_MODULE_1__[\"draw\"].setVisibility(this.legendSVG_Group, true);\n};\n\n//# sourceURL=webpack:///./src/Legend/Legend.js?");

/***/ }),

/***/ "./src/Util/RandomPicker.js":
/*!**********************************!*\
  !*** ./src/Util/RandomPicker.js ***!
  \**********************************/
/*! exports provided: RandomPicker */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RandomPicker\", function() { return RandomPicker; });\n/* harmony import */ var _Draw_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Draw/Color */ \"./src/Draw/Color.js\");\n/**\n * offers methods to return the next not so random colors / or shapes.\n */\n\n\nfunction RandomPicker(){\n    this.seriesColors = [\"blue\", \"green\", \"red\", \"lightBlue\", \"darkGreen\", \"yellow\", \"purple\"]; //TODO: add these \"purple\", \"gray\"\n    this.currentSeriesColorIndex = 0;\n    this.nodeShape = [\"circle\", \"rectangular\", \"triangle\", \"reverse-triangle\"];\n    this.currentNodeShapeIndex = 0;\n}\n\n/**\n * pick a series color. it returns the elements in this.seriesColors in the array order.\n * @returns {*}\n */\nRandomPicker.prototype.pickSeriesColor = function(){\n    let color =  this.seriesColors[this.currentSeriesColorIndex];\n\n    if(this.currentSeriesColorIndex === this.seriesColors.length - 1){\n        this.currentSeriesColorIndex = 0;\n    } else {\n        this.currentSeriesColorIndex ++;\n    }\n    return _Draw_Color__WEBPACK_IMPORTED_MODULE_0__[\"colors\"][color];\n};\n\n/**\n * pick a node shape. It returns the elements in this.nodeShape in the array order\n * @returns {*}\n */\nRandomPicker.prototype.pickNodeShape = function(){\n    let shape = this.nodeShape[this.currentNodeShapeIndex];\n\n    if(this.currentNodeShapeIndex === this.nodeShape.length - 1){\n        this.currentNodeShapeIndex = 0;\n    } else {\n        this.currentNodeShapeIndex ++;\n    }\n    return shape;\n};\n\n//# sourceURL=webpack:///./src/Util/RandomPicker.js?");

/***/ }),

/***/ "./src/Util/Util.js":
/*!**************************!*\
  !*** ./src/Util/Util.js ***!
  \**************************/
/*! exports provided: util */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"util\", function() { return util; });\n/**\n * just some friendly neighborhood utility methods.\n */\nconst util = {\n\n    /**\n     * takes any number of parameter, will return the first none null / undefined parameter\n     * @returns {*}\n     */\n    pickFirstAvailable : function(/*accept any number of arguments*/){\n        for(let idx in arguments){\n            let argument = arguments[idx];\n            if(argument !== undefined && argument !== null){\n                return argument;\n            }\n        }\n    },\n\n    /**\n     * just another version of a ? c : d;\n     * @param condition             a condition that evaluates to true or false.\n     * @param chooseWhenTrue        returned when condition is true\n     * @param chooseWhenFalse       returned when condition is false\n     * @returns {*}\n     */\n    chooseBetween: function(condition, chooseWhenTrue, chooseWhenFalse){\n        return condition ? chooseWhenTrue : chooseWhenFalse;\n    },\n\n    /**\n     * to cope with floating point accuracy issue.\n     * @param {Number} number   a number\n     * @returns {Number}        returnsa number whose precision is 12.\n     */\n    perfectNumber: function (number) {\n        return (parseFloat(number.toPrecision(12)));\n    },\n\n    /**\n     * If target is not inside the array at all, then this method will return the index of the element that is\n     * closest to the target.\n     *\n     * @param array     a sorted array\n     * @param target    we will search this element\n     * @returns {Number}         the (closest) element idx.\n     */\n    findElementIdxUsingBinarySearch: function(array, target){\n        let startIdx = 0;\n        let endIdx = array.length - 1;\n        let half = 0;\n\n        while(endIdx - startIdx > 1){\n            half = Math.floor((endIdx - startIdx)/2);\n            if(target < array[startIdx + half]) {\n                endIdx = startIdx + half;\n            } else {\n                startIdx = startIdx + half;\n            }\n        }\n\n        /*\n            when the codes reaches here, there are only two elements sitting next to each other,\n            and the target is either one of them, or between them. (if between them then the target\n            not in the array. we choose the closet element).\n         */\n        let a = target - array[startIdx];\n        let b = array[endIdx] - target;\n        if(a < b) {\n            return startIdx;\n        } else if (a > b){\n            return endIdx;\n        } else {\n            return startIdx;\n        }\n    },\n\n    /**\n     * converts polar coordinates to cartesian coordinates\n     * @param centerX\n     * @param centerY\n     * @param radius\n     * @param angleInDegrees\n     * @returns {number[]} an array, first element is x coordinate and second is y coordinate\n     */\n    polarToCartesian: function(centerX, centerY, radius, angleInDegrees) {\n        let angleInRadians = (angleInDegrees-90) * Math.PI / 180.0;\n\n        return [\n            centerX + (radius * Math.cos(angleInRadians)),\n            centerY + (radius * Math.sin(angleInRadians))\n        ];\n    }\n};\n\n//# sourceURL=webpack:///./src/Util/Util.js?");

/***/ }),

/***/ "./src/Weaver.js":
/*!***********************!*\
  !*** ./src/Weaver.js ***!
  \***********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Draw_Color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Draw/Color */ \"./src/Draw/Color.js\");\n/* harmony import */ var _Legend_Legend__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Legend/Legend */ \"./src/Legend/Legend.js\");\n/* harmony import */ var _Layout_Sub_GeneralLayout__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Layout/Sub/GeneralLayout */ \"./src/Layout/Sub/GeneralLayout.js\");\n/* harmony import */ var _Axis_Sub_LinearAxis__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Axis/Sub/LinearAxis */ \"./src/Axis/Sub/LinearAxis.js\");\n/* harmony import */ var _DataViewer_BasicLine_BasicLineRegularDataViewer__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./DataViewer/BasicLine/BasicLineRegularDataViewer */ \"./src/DataViewer/BasicLine/BasicLineRegularDataViewer.js\");\n/* harmony import */ var _Axis_Sub_CategoryAxis__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Axis/Sub/CategoryAxis */ \"./src/Axis/Sub/CategoryAxis.js\");\n/* harmony import */ var _DataViewer_Category_BasicCategoryDataViewer__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DataViewer/Category/BasicCategoryDataViewer */ \"./src/DataViewer/Category/BasicCategoryDataViewer.js\");\n/* harmony import */ var _Axis_Sub_TimeAxis__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Axis/Sub/TimeAxis */ \"./src/Axis/Sub/TimeAxis.js\");\n/* harmony import */ var _DataViewer_Stack_BasicSingleTimeDataViewer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./DataViewer/Stack/BasicSingleTimeDataViewer */ \"./src/DataViewer/Stack/BasicSingleTimeDataViewer.js\");\n/* harmony import */ var _DataViewer_Stack_BasicStackRegularDataViewer__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./DataViewer/Stack/BasicStackRegularDataViewer */ \"./src/DataViewer/Stack/BasicStackRegularDataViewer.js\");\n/* harmony import */ var _DataViewer_BasicLine_BasicLineIrregularDataViewer__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./DataViewer/BasicLine/BasicLineIrregularDataViewer */ \"./src/DataViewer/BasicLine/BasicLineIrregularDataViewer.js\");\n/* harmony import */ var _Layout_Sub_LayoutNoAxes__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./Layout/Sub/LayoutNoAxes */ \"./src/Layout/Sub/LayoutNoAxes.js\");\n/* harmony import */ var _DataAnalyst_BasicLine_BasicLineRegularDataAnalyst__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./DataAnalyst/BasicLine/BasicLineRegularDataAnalyst */ \"./src/DataAnalyst/BasicLine/BasicLineRegularDataAnalyst.js\");\n/* harmony import */ var _DataAnalyst_BasicLine_BasicLineIrregularDataAnalyst__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./DataAnalyst/BasicLine/BasicLineIrregularDataAnalyst */ \"./src/DataAnalyst/BasicLine/BasicLineIrregularDataAnalyst.js\");\n/* harmony import */ var _DataAnalyst_Category_BasicCategoryDataAnalyst__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./DataAnalyst/Category/BasicCategoryDataAnalyst */ \"./src/DataAnalyst/Category/BasicCategoryDataAnalyst.js\");\n/* harmony import */ var _DataAnalyst_Pie_BasicPieDataAnalyst__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./DataAnalyst/Pie/BasicPieDataAnalyst */ \"./src/DataAnalyst/Pie/BasicPieDataAnalyst.js\");\n/* harmony import */ var _DataAnalyst_Stack_BasicStackRegularDataAnalyst__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./DataAnalyst/Stack/BasicStackRegularDataAnalyst */ \"./src/DataAnalyst/Stack/BasicStackRegularDataAnalyst.js\");\n/* harmony import */ var _DataViewer_Pie_BasicPieDataViewer__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./DataViewer/Pie/BasicPieDataViewer */ \"./src/DataViewer/Pie/BasicPieDataViewer.js\");\n/* harmony import */ var _Layout_Sub_MultipleLegendLayout__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./Layout/Sub/MultipleLegendLayout */ \"./src/Layout/Sub/MultipleLegendLayout.js\");\n/* harmony import */ var _DataViewer_3D_webgl_main__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./DataViewer/3D/webgl-main */ \"./src/DataViewer/3D/webgl-main.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * reads the user config and data input and constructs various types of charts\n * the is the entry point of the lib\n */\nwindow.weaver = {\n    createContainers: function(container, options){\n        container.setAttribute(\"class\", \"mc-container\");\n        let bcr = container.getBoundingClientRect();\n        let width = bcr.width;\n        let height = bcr.height;\n        let svg;\n        let tipContainer;\n        let svgTriggerLayer;\n        let canvas;\n        let canvasTrigger;\n        let offScreenCanvas;\n\n        //this one is always hidden and does not matter\n        if(options.offScreenCanvas){\n            offScreenCanvas = document.createElement(\"canvas\");\n            offScreenCanvas.style.display = \"none\";\n            container.appendChild(offScreenCanvas);\n        }\n\n        if(options.svg){\n            svg = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n            svg.style.position = \"absolute\";\n            svg.style.left = \"0px\";\n            svg.style.top = \"0px\";\n            svg.setAttributeNS(null, \"width\", width.toString());\n            svg.setAttributeNS(null, \"height\", height.toString());\n            container.appendChild(svg);\n        }\n\n        if(options.canvas){\n            canvas = document.createElement(\"canvas\");\n            container.appendChild(canvas);\n\n            //position can only be set after the relevant layout has been analyzed.\n        }\n\n        if(options.tipContainer){\n            tipContainer = document.createElement(\"div\");\n            tipContainer.setAttribute(\"class\", \"mc-div-draw-layer\");\n            container.appendChild(tipContainer); //tip layer should be above the\n        }\n\n        if(options.svgTrigger){\n            svgTriggerLayer = document.createElementNS(\"http://www.w3.org/2000/svg\", \"svg\");\n            svgTriggerLayer.setAttributeNS(null, \"width\", width.toString());\n            svgTriggerLayer.setAttributeNS(null, \"height\", height.toString());\n            svgTriggerLayer.style.position = \"absolute\";\n            svgTriggerLayer.style.left = \"0\";\n            svgTriggerLayer.style.top = \"0\";\n            container.appendChild(svgTriggerLayer);\n        }\n\n        if(options.canvasTrigger){\n            canvasTrigger = document.createElement(\"div\");\n            container.appendChild(canvasTrigger);\n        }\n\n\n\n        return {\n            svg: svg,\n            div: tipContainer, //which is really tip container....bad naming but lazy to rename it..\n            svgTrigger: svgTriggerLayer,\n            canvas: canvas,\n            offScreenCanvas: offScreenCanvas,\n            canvasTrigger: canvasTrigger\n        }\n    },\n\n\n    weave: function (type, input /* in the future also various kinds of options */, container) {\n        switch (type) {\n            case \"basicLineIrregular\":\n                this.weaveBasicLineIrregular(input, container);\n                break;\n            case \"basicLineRegular\":\n                this.weaveBasicLineRegular(input, container);\n                break;\n            case \"basicCategory\":\n                this.weaveBasicCategory(input, container);\n                break;\n            case \"singleTime\":\n                this.weaveSingleTime(input, container);\n                break;\n            case \"basicStackRegular\":\n                this.weaveBasicStackRegular(input, container);\n                break;\n            case \"basicPieChart\":\n                this.weaveBasicPieChart(input, container);\n                break;\n            case \"3dGrid\":\n                this.weave3dGrid(input, container);\n                break;\n        }\n    },\n\n\n    weaveBasicLineIrregular: function (input, container) {\n        let subContainers = this.createContainers(container, {svg: true, svgTrigger: true, tipContainer: true});\n        let svg = subContainers.svg;\n        let tipContainer = subContainers.div;\n        let svgTrigger = subContainers.svgTrigger;\n        _Draw_Color__WEBPACK_IMPORTED_MODULE_0__[\"colors\"].initLinearGradients(svg);//this draws a <defs> containing all those linear gradients that can be used by others.\n\n        let legend = new _Legend_Legend__WEBPACK_IMPORTED_MODULE_1__[\"Legend\"](svg, input.series, input.legend/*this is really legendPosition*/);\n        legend.analyze();\n\n        let layout = new _Layout_Sub_GeneralLayout__WEBPACK_IMPORTED_MODULE_2__[\"GeneralLayout\"](svg, input.mainTitle, input.subTitle, input.yAxisTitle,\n            input.xAxisTitle, legend);\n\n        let xLeftPadding = 10;\n        let xRightPadding = 10;\n        let lar = layout.analyze(); //layout analyze result.\n        let xAxisDataAreaLength = lar.xAxisLength - xLeftPadding - xRightPadding;\n\n        let dar = new _DataAnalyst_BasicLine_BasicLineIrregularDataAnalyst__WEBPACK_IMPORTED_MODULE_13__[\"BasicLineIrregularDataAnalyst\"](input, xAxisDataAreaLength).analyze(); //data analyze result.\n\n        /* Even though the data intervals are irregular, but the marks on the x axis is linear and regular.*/\n        let xAxis = new _Axis_Sub_LinearAxis__WEBPACK_IMPORTED_MODULE_3__[\"X_LinearAxis\"](svg, xAxisDataAreaLength, dar.minX, dar.maxX, lar.originPosition, xLeftPadding, xRightPadding);\n        let yAxis = new _Axis_Sub_LinearAxis__WEBPACK_IMPORTED_MODULE_3__[\"Y_LinearAxis\"](svg, lar.yAxisLength, dar.minY, dar.maxY, lar.originPosition, xAxis, false, false);\n\n        let xDrawInfo = xAxis.analyze(); //drawing information related to X axis.\n        let yDrawInfo = yAxis.analyze();\n\n        let dataViewer = new _DataViewer_BasicLine_BasicLineIrregularDataViewer__WEBPACK_IMPORTED_MODULE_10__[\"BasicLineIrregularDataViewer\"](tipContainer, svg, svgTrigger, input, xDrawInfo, yDrawInfo, dar.isContinual);\n\n        layout.draw();\n        xAxis.draw();\n        yAxis.draw();\n        dataViewer.draw();\n    },\n\n    weaveBasicLineRegular: function(input, container){\n        let subContainers = this.createContainers(container, {svg: true, svgTrigger: true, tipContainer: true});\n        let svg = subContainers.svg;\n        let tipContainer = subContainers.div;\n        let svgTrigger = subContainers.svgTrigger;\n        _Draw_Color__WEBPACK_IMPORTED_MODULE_0__[\"colors\"].initLinearGradients(svg);//this draws a <defs> containing all those linear gradients that can be used by others.\n\n        let legend = new _Legend_Legend__WEBPACK_IMPORTED_MODULE_1__[\"Legend\"](svg, input.series, input.legend/*this is really legendPosition*/);\n        legend.analyze();\n\n        let layout = new _Layout_Sub_GeneralLayout__WEBPACK_IMPORTED_MODULE_2__[\"GeneralLayout\"](svg, input.mainTitle, input.subTitle, input.yAxisTitle,\n            input.xAxisTitle, legend);\n\n        let xLeftPadding = 0;\n        let xRightPadding = 0;\n        let lar = layout.analyze(); //layout analyze result.\n        let xAxisDataAreaLength = lar.xAxisLength - xLeftPadding - xRightPadding;\n\n        let dar = new _DataAnalyst_BasicLine_BasicLineRegularDataAnalyst__WEBPACK_IMPORTED_MODULE_12__[\"BasicLineRegularDataAnalyst\"](input, xAxisDataAreaLength).analyze();\n\n        let xAxis = new _Axis_Sub_LinearAxis__WEBPACK_IMPORTED_MODULE_3__[\"X_LinearAxis\"](svg, xAxisDataAreaLength, input.start, dar.maxX, lar.originPosition, xLeftPadding, xRightPadding);\n        let yAxis = new _Axis_Sub_LinearAxis__WEBPACK_IMPORTED_MODULE_3__[\"Y_LinearAxis\"](svg, lar.yAxisLength, dar.minY, dar.maxY, lar.originPosition, xAxis, false, false);\n\n        let xDrawInfo = xAxis.analyze(); //drawing information related to X axis.\n        let yDrawInfo = yAxis.analyze();\n\n        let dataViewer = new _DataViewer_BasicLine_BasicLineRegularDataViewer__WEBPACK_IMPORTED_MODULE_4__[\"BasicLineRegularDataViewer\"](tipContainer, svg, svgTrigger, input, xDrawInfo, yDrawInfo, dar.isContinual);\n\n        layout.draw();\n        xAxis.draw();\n        yAxis.draw();\n        dataViewer.draw();\n    },\n\n    weaveBasicCategory: function(input, container){\n        let subContainers = this.createContainers(container, {svg: true, svgTrigger: true, tipContainer: true});\n        let svg = subContainers.svg;\n        let tipContainer = subContainers.div;\n        let svgTrigger = subContainers.svgTrigger;\n        _Draw_Color__WEBPACK_IMPORTED_MODULE_0__[\"colors\"].initLinearGradients(svg);//this draws a <defs> containing all those linear gradients that can be used by others.\n\n        let legend = new _Legend_Legend__WEBPACK_IMPORTED_MODULE_1__[\"Legend\"](svg, input.series, input.legend/*this is really legendPosition*/, \"rectangular\");\n        legend.analyze();\n\n        let layout = new _Layout_Sub_GeneralLayout__WEBPACK_IMPORTED_MODULE_2__[\"GeneralLayout\"](svg, input.mainTitle, input.subTitle, input.yAxisTitle,\n            input.xAxisTitle, legend);\n\n        let lar = layout.analyze(); //layout analyze result.\n        let dar = new _DataAnalyst_Category_BasicCategoryDataAnalyst__WEBPACK_IMPORTED_MODULE_14__[\"BasicCategoryDataAnalyst\"](input).analyze();\n\n        let xLeftPadding = 0;\n        let xRightPadding = 0;\n\n        //because leftPadding and rightPadding are both 0 therefore xAxisDataAreaLength is equal to lar.xAxisLength.\n        let xAxis = new _Axis_Sub_CategoryAxis__WEBPACK_IMPORTED_MODULE_5__[\"X_CategoryAxis\"](svg, lar.xAxisLength -xLeftPadding-xRightPadding, lar.originPosition,\n            dar.seriesNames, xLeftPadding, xRightPadding);\n        let yAxis = new _Axis_Sub_LinearAxis__WEBPACK_IMPORTED_MODULE_3__[\"Y_LinearAxis\"](svg, lar.yAxisLength, dar.minY, dar.maxY, lar.originPosition, xAxis, false, false);\n\n        let xDrawInfo = xAxis.analyze();\n        let yDrawInfo = yAxis.analyze();\n\n        let d = new _DataViewer_Category_BasicCategoryDataViewer__WEBPACK_IMPORTED_MODULE_6__[\"BasicCategoryDataViewer\"](tipContainer, svg, svgTrigger, input, xDrawInfo, yDrawInfo);\n\n        layout.draw();\n        xAxis.draw();\n        yAxis.draw();\n        d.draw();\n    },\n\n    weaveSingleTime: function(input, container){\n        let subContainers = this.createContainers(container, {svg: true, svgTrigger: true, tipContainer: true});\n        let svg = subContainers.svg;\n        let tipContainer = subContainers.div;\n        let svgTrigger = subContainers.svgTrigger;\n        _Draw_Color__WEBPACK_IMPORTED_MODULE_0__[\"colors\"].initLinearGradients(svg);//this draws a <defs> containing all those linear gradients that can be used by others.\n\n        let legend = new _Legend_Legend__WEBPACK_IMPORTED_MODULE_1__[\"Legend\"](svg, input.series, input.legend/*this is really legendPosition*/, \"rectangular\");\n        legend.analyze();\n\n        let layout = new _Layout_Sub_GeneralLayout__WEBPACK_IMPORTED_MODULE_2__[\"GeneralLayout\"](svg, input.mainTitle, input.subTitle, input.yAxisTitle,\n            input.xAxisTitle, legend);\n\n        let lar = layout.analyze(); //layout analyze result.\n\n        let dar = new _DataAnalyst_BasicLine_BasicLineRegularDataAnalyst__WEBPACK_IMPORTED_MODULE_12__[\"BasicLineRegularDataAnalyst\"](input, lar.xAxisLength).analyze();\n\n        let xAxis = new _Axis_Sub_TimeAxis__WEBPACK_IMPORTED_MODULE_7__[\"TimeAxis\"](svg, lar.xAxisLength, dar.maxX, lar.originPosition, input.unit, input.interval);\n        let yAxis = new _Axis_Sub_LinearAxis__WEBPACK_IMPORTED_MODULE_3__[\"Y_LinearAxis\"](svg, lar.yAxisLength, dar.minY, dar.maxY, lar.originPosition, xAxis, false, false);\n\n        let xDrawInfo = xAxis.analyze();\n        let yDrawInfo = yAxis.analyze();\n\n        let d = new _DataViewer_Stack_BasicSingleTimeDataViewer__WEBPACK_IMPORTED_MODULE_8__[\"BasicSingleTimeData\"](tipContainer, svg, svgTrigger, input, xDrawInfo, yDrawInfo, dar.isContinual);\n\n        layout.draw();\n        xAxis.draw();\n        yAxis.draw();\n        d.draw();\n    },\n\n    weaveBasicStackRegular: function(input, container){\n        let subContainers = this.createContainers(container, {svg: true, svgTrigger: true, tipContainer: true});\n        let svg = subContainers.svg;\n        let tipContainer = subContainers.div;\n        let svgTrigger = subContainers.svgTrigger;\n        _Draw_Color__WEBPACK_IMPORTED_MODULE_0__[\"colors\"].initLinearGradients(svg);//this draws a <defs> containing all those linear gradients that can be used by others.\n\n        let legend = new _Legend_Legend__WEBPACK_IMPORTED_MODULE_1__[\"Legend\"](svg, input.series, input.legend/*this is really legendPosition*/);\n        legend.analyze();\n\n        let layout = new _Layout_Sub_GeneralLayout__WEBPACK_IMPORTED_MODULE_2__[\"GeneralLayout\"](svg, input.mainTitle, input.subTitle, input.yAxisTitle,\n            input.xAxisTitle, legend);\n\n        let xLeftPadding = 0;\n        let xRightPadding = 0;\n        let lar = layout.analyze(); //layout analyze result.\n        let xAxisDataAreaLength = lar.xAxisLength - xLeftPadding - xRightPadding;\n\n        let dar = new _DataAnalyst_Stack_BasicStackRegularDataAnalyst__WEBPACK_IMPORTED_MODULE_16__[\"BasicStackRegularDataAnalyst\"](input, xAxisDataAreaLength).analyze();\n\n        let xAxis = new _Axis_Sub_LinearAxis__WEBPACK_IMPORTED_MODULE_3__[\"X_LinearAxis\"](svg, xAxisDataAreaLength, input.start, dar.maxX, lar.originPosition, xLeftPadding, xRightPadding);\n        let yAxis = new _Axis_Sub_LinearAxis__WEBPACK_IMPORTED_MODULE_3__[\"Y_LinearAxis\"](svg, lar.yAxisLength, dar.minY, dar.maxY, lar.originPosition, xAxis, true, false);\n\n        let xDrawInfo = xAxis.analyze(); //drawing information related to X axis.\n        let yDrawInfo = yAxis.analyze();\n\n        let dataViewer = new _DataViewer_Stack_BasicStackRegularDataViewer__WEBPACK_IMPORTED_MODULE_9__[\"BasicStackRegularDataViewer\"](tipContainer, svg, svgTrigger, input, xDrawInfo, yDrawInfo, dar.isContinual);\n\n        layout.draw();\n        xAxis.draw();\n        yAxis.draw();\n        dataViewer.draw();\n    },\n\n    weaveBasicPieChart: function(input, container){\n        let subContainers = this.createContainers(container, {svg: true, svgTrigger: true, tipContainer: true});\n        let svg = subContainers.svg;\n        let tipContainer = subContainers.div;\n        let svgTrigger = subContainers.svgTrigger;\n        _Draw_Color__WEBPACK_IMPORTED_MODULE_0__[\"colors\"].initLinearGradients(svg);//this draws a <defs> containing all those linear gradients that can be used by others.\n\n        let legend = new _Legend_Legend__WEBPACK_IMPORTED_MODULE_1__[\"Legend\"](svg, input.series, input.legend/*this is really legendPosition*/);\n        legend.analyze();\n\n        let layout = new _Layout_Sub_LayoutNoAxes__WEBPACK_IMPORTED_MODULE_11__[\"LayoutNoAxes\"](svg, input.mainTitle, input.subTitle, legend);\n        let lar = layout.analyze();\n\n        let analyst = new _DataAnalyst_Pie_BasicPieDataAnalyst__WEBPACK_IMPORTED_MODULE_15__[\"BasicPieDataAnalyst\"](input);\n        let dar = analyst.analyze();\n\n        let dataViewer = new _DataViewer_Pie_BasicPieDataViewer__WEBPACK_IMPORTED_MODULE_17__[\"BasicPieDataViewer\"](tipContainer, svg, svgTrigger, input, lar.center, lar.dataDrawAreaX,\n        lar.dataDrawAreaY, lar.radiusForLabel, lar.radiusForPie, lar.radiusForConnectionLine,  dar.total);\n        dataViewer.draw();\n\n        layout.draw();\n    },\n\n    /**\n     *\n     * @param input\n     */\n    weave3dGrid: function(input, container){\n        /**\n         * svg               this is used to draw layout, legends as well as 2D data.\n         * svgTrigger        this is used as trigger in 2d data. This needs to be set \"display:none\" in 3d context.\n         * tipContainer      both tips in 3d context and in 2d context can be put here.\n         * canvas            this is the place I use webgl to draw the 3d grids. This needs to be set \"display:none\" in 2d context.\n         * offScreenCanvas   this is the place I use 2d canvas to generate label image data. This needs to be set \"display:none\" all the time.\n         * canvasTrigger     this is used as the trigger in 3d context. Notice that this htmlTrigger should be of the same size\n         *                   of canvas and positioned exactly at the same place.\n         */\n        let subContainers = this.createContainers(container, {svg: true, svgTrigger: true, tipContainer: true, canvas: true, offScreenCanvas: true, canvasTrigger: true});\n        //set the sub container's background color to white...\n        container.style.background = \"white\";\n\n        let svg = subContainers.svg;\n        let tipContainer = subContainers.div;\n        let svgTrigger = subContainers.svgTrigger;\n        let canvas = subContainers.canvas;\n        let offScreenCanvas = subContainers.offScreenCanvas;\n        let canvasTrigger = subContainers.canvasTrigger;\n        _Draw_Color__WEBPACK_IMPORTED_MODULE_0__[\"colors\"].initLinearGradients(svg);//this draws a <defs> containing all those linear gradients that can be used by others.\n\n\n        let legendList = [];\n        let rowLegend = new _Legend_Legend__WEBPACK_IMPORTED_MODULE_1__[\"Legend\"](svg, input.series, input.rowLegend/*this is really legendPosition*/, \"rectangular\");\n        rowLegend.analyze(input.series.rows, true);\n        let columnLegend = new _Legend_Legend__WEBPACK_IMPORTED_MODULE_1__[\"Legend\"](svg, input.series, input.columnLegend/*this is really legendPosition*/);\n        columnLegend.analyze(input.series.columns, false);\n        legendList.push(rowLegend);\n        legendList.push(columnLegend);\n\n        let layout = new _Layout_Sub_MultipleLegendLayout__WEBPACK_IMPORTED_MODULE_18__[\"MultipleLegendLayout\"](svg, input.mainTitle, input.subTitle, legendList);\n        let lar = layout.analyze();\n\n        let relativePositionOfCanvasAndItsTrigger = [lar.originPosition[0], lar.originPosition[1]-lar.dataDrawAreaY];\n        let canvasDimension = [lar.dataDrawAreaX, lar.dataDrawAreaY];\n\n        canvas.style.position = \"absolute\";\n        canvas.style.left = relativePositionOfCanvasAndItsTrigger[0] + \"px\";\n        canvas.style.top = relativePositionOfCanvasAndItsTrigger[1] + \"px\";\n        canvas.width = canvasDimension[0];\n        canvas.height = canvasDimension[1];\n\n        //show it when in 3d context (default context)\n        canvasTrigger.style.position = \"absolute\";\n        canvasTrigger.style.left = relativePositionOfCanvasAndItsTrigger[0] + \"px\";\n        canvasTrigger.style.top = relativePositionOfCanvasAndItsTrigger[1] + \"px\";\n        canvasTrigger.style.width = canvasDimension[0] + \"px\";\n        canvasTrigger.style.height = canvasDimension[1] + \"px\";\n\n        //set the tip container to be of the same size of canvas, and sits at the same spot. When turning on 2d context,\n        //then it should be of the same size and position as the svg layer.\n        tipContainer.style.left = relativePositionOfCanvasAndItsTrigger[0] + \"px\";\n        tipContainer.style.top = relativePositionOfCanvasAndItsTrigger[1] + \"px\";\n        tipContainer.style.width = canvasDimension[0] + \"px\";\n        tipContainer.style.height = canvasDimension[1] + \"px\";\n\n\n        svgTrigger.style.display = \"none\"; //show it when in 2d context\n\n        layout.draw();\n        _DataViewer_3D_webgl_main__WEBPACK_IMPORTED_MODULE_19__[\"threeDgridWebgl\"].draw(input, canvas, offScreenCanvas, canvasTrigger, tipContainer);\n    }\n};\n\n//# sourceURL=webpack:///./src/Weaver.js?");

/***/ })

/******/ });