<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title></title>
    <link type="text/css" rel="stylesheet" href="src/CSS/my-chart.css"/>
    <style>
        body {
            background-color: lightgrey;
        }

        body > div {
            margin-bottom: 30px;
            margin-left: auto;
            margin-right: auto;
            background: white;
            box-shadow: 2px 2px 2px 0px grey;
        }
    </style>

    <script id="shader-vertex" type="x-shader/x-vertex">
            /*vertex shader*/
            uniform mat4 MVMatrix;
            uniform mat4 MVPMatrix;
            uniform mat3 NormalMatrix;

            uniform vec3 ecDirectionalLightPositionOne;
            uniform vec3 ecDirectionalLightPositionTwo;

            attribute vec4 MCVertex;
            attribute vec3 MCNormal;

            uniform bool IsTranslucent;

            varying vec3 colorFactor;

            const vec3 DirectionalLightColor = vec3(1.0, 1.0, 1.0);

            //here I only include diffuse light. There is no ambient (which hemisphere light has already done its job), or specular light.
            vec3 computeSingleDirectionalLight(const in vec3 ecNormal, const in vec3 ecVertexPosition, const in vec3 ecDirectionalLightPosition, const in bool calculateBackFaceLight){
                vec3 lightDir = normalize(ecDirectionalLightPosition - ecVertexPosition);
                float diffuseFactor = dot(lightDir, ecNormal);
                if(calculateBackFaceLight && diffuseFactor < 0.0){
                    diffuseFactor = dot(lightDir, -ecNormal);
                } else {
                    diffuseFactor = max(diffuseFactor, 0.0);
                }
                return DirectionalLightColor * diffuseFactor;
            }

            vec3 computeDirectionalLight(const in vec3 ecNormal, const in vec3 ecVertexPosition, const in bool calculateBackFaceLight){
                vec3 directionalLightOne = computeSingleDirectionalLight(ecNormal, ecVertexPosition, ecDirectionalLightPositionOne, calculateBackFaceLight);
                vec3 directionalLightTwo = computeSingleDirectionalLight(ecNormal, ecVertexPosition, ecDirectionalLightPositionTwo, calculateBackFaceLight);
                return directionalLightOne * 0.7 + directionalLightTwo * 0.3;
            }


            void main() {
                vec3 ecVertexPosition = vec3(MVMatrix * MCVertex);
                vec3 ecNormal = normalize(NormalMatrix * MCNormal);

                if(IsTranslucent){
                    vec3 directionalLightColor = computeDirectionalLight(ecNormal, ecVertexPosition, true);
                    //只用directional diffuse来做半透明的明暗调节。这是因为如果用hemisphere+directional diffuse一起来做调节系数的话。hemisphere的ground color（黑色）会导致半透明体底部过暗。
                    colorFactor = vec3(0.85) + directionalLightColor * 0.15;
                } else {
                    vec3 directionalLightColor = computeDirectionalLight(ecNormal, ecVertexPosition, false);
                    colorFactor = vec3(0.65) + directionalLightColor * 0.35;
                }

                gl_Position = MVPMatrix * MCVertex;
            }
        </script>

    <script id="shader-fragment" type="x-shader/x-fragment">
            precision mediump float;

            uniform vec3 materialColor;

            varying vec3 colorFactor;

            void main(){
                gl_FragColor = vec4(materialColor * colorFactor, 1.0);
            }
        </script>

    <script id="shader-simple-vertex" type="x-shader/x-vertex">
            uniform mat4 MVPMatrix;

            attribute vec4 MCVertex;

            void main(){
                gl_Position = MVPMatrix * MCVertex;
            }
        </script>

    <script id="shader-simple-fragment" type="x-shader/x-fragment">
            precision mediump float;

            uniform vec3 materialColor;

            void main(){
                gl_FragColor = vec4(materialColor, 1.0);
            }
        </script>

    <script id="shader-label-vertex" type="x-shader/x-vertex">
            uniform mat4 MVPMatrix;

            attribute vec4 MCVertex;
            attribute vec2 aTexCoord;

            varying vec2 vTexCoord;

            void main(){
                gl_Position = MVPMatrix * MCVertex;
                vTexCoord = aTexCoord;
            }
        </script>

    <script id="shader-label-fragment" type="x-shader/x-vertex">
            precision mediump float;

            uniform sampler2D uSampler;
            varying vec2 vTexCoord;

            void main(){
                gl_FragColor = texture2D(uSampler, vTexCoord);
            }
        </script>
</head>
<body>
<div id="container1" style="width:900px; height:500px;"></div>
<div id="container2" style="width:900px; height:500px;"></div>
<div id="container3" style="width:900px; height:500px;"></div>
<div id="container4" style="width:900px; height:500px;"></div>
<div id="container5" style="width:900px; height:500px;"></div>
<div id="container6" style="width:900px; height:500px;"></div>
<div id="container7" style="width:900px; height:500px;"></div>
<div id="container8" style="width:900px; height:500px;"></div>
<div id="container9" style="width:900px; height:700px;"></div>

<script type="text/javascript" src="dist/bundle.js"></script>
<script type="text/javascript" src="index.js"></script>
</body>
</html>